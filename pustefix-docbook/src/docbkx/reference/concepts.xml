<?xml version="1.0"?>
<chapter xml:id="concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0CR7/xsd/docbook.xsd"
>
  <title>Important Concepts</title>

  <section xml:id="concepts.servlets">
    <title>HTTP request handling</title>
    <para>
      In a typical Pustefix application the <classname>DispatcherServlet</classname>
      provided by Spring is usually the only servlet. This servlet instantiates a 
      Spring <interfacename>ApplicationContext</interfacename> on startup and delegates
      all requests to the <interfacename>HttpRequestHandler</interfacename>
      found by using the <interfacename>HandlerMapping</interfacename>.
      If you want to do request processing for a certain path without using the
      <interfacename>HttpRequestHandler</interfacename>s provided by Pustefix, you can
      add your own instance of an <interfacename>UriProvidingHttpRequestHandler</interfacename>
      to the Spring configuration file.
    </para>
    <para>
      All request handlers used by Pustefix are based on <classname>AbstractPustefixRequestHandler</classname>.
      The main feature of it's session handling is that it's mostly transparent to the user. You can submit data
      to a URL, and the system will take care to store the supplied data (this is done in the form of a
      <literal>PfixServletRequest</literal>, which can be seen as basically the same as a
      <literal>HttpServletRequest</literal>, with some additional features, e.g. more or less transparent handling of
      file uploads), create a session, redirect to the URL with an embedded session id, and continue with the business
      logic and the data submitted with the original request afterwards.
    </para>
    <para>
      Even SSL is handled transparently. A descending request handler must implement the method <literal>+ needsSession(): boolean</literal>
      to decide if the the current request should result into the session to be "secure". You don't have to make sure that
      the webpages use "https://" in all needed links, the target itself tells the system that it want's to run under SSL.
    </para>
    <para>
      If the request handler decides that it want's to run under SSL from now on, a complex redirect sequence happens that makes sure
      that all data is copied from the previous insecure session into a new, secure session (a session is secure if it's
      session id was never transmitted over an insecure channel). After a session has once transformed into a secure one, there's
      no way back: Every time you try to use the session with "http://" it will create a new, secure session dropping the old
      one (because it's tainted now). If the visitor's browser supports cookies, the system manages to map request with the old, 
      original, insecure session id (which can happen whenever the user uses the back button of her browser to go back to a page
      that has still the old session id embedded in every link) to the new, currently running secure session and silenty and
      securely redirects to this session.
    </para>
    <section xml:id="concepts.httprequesthandlers.core">
      <title>HttpRequestHandlers provided by the core framework</title>
      <para>
        <xref linkend="concepts.servlets.core.figure"/> shows some of the <interfacename>HttpRequestHandler</interfacename>s 
        that are already provided by the core framework
        and should be sufficient for most of your needs when building a web application with Pustefix.
      </para>
      <figure xml:id="concepts.servlets.core.figure">
        <title>Pustefix HTTP request handlers</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/reference/concepts-servlets.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section>
        <title>DerefRequestHandler</title>
        <para>
          This is a small request handler that should be used whenever a link to a URL outside the own site is made. All such
          external links must be of the form <uri>/deref?link=http://some.other.domain/foo/bar</uri>. This is important
          because for any link that goes directly to a foreign destination (e.g. <literal>&lt;a href="http://some.other.domain/foo/bar"&gt;</literal>)
          the session id visible in the logfile of the foreign site's webserver (via the Referer header). This is of course
          a security problem. Using the <literal>DerefServlet</literal> avoids this by using a redirect loop so the <literal>Referer</literal>
          header transmitted will no longer contain the session id.
        </para>
      </section>
      <section>
        <title>AbstractPustefixXMLRequestHandler</title>
        <para>
          This HTTP request handler, while still abstract, implements most of the output handling needed for request handlers
          that want use XSLT/XML to produce the final html sent to the browser.
        </para>
        <para>
          The only thing a descendant needs to implement is the abstract method <literal>getDom(PfixServletRequest)</literal>,
          whose return value can be thought of as a small container around a <literal>org.w3c.Document</literal>. The additional data stored in
          a <literal>SPDocument</literal> is among other things a map of XSLT transformation parameters that should be set and the "page name"
          which the system uses to choose the correct target stylesheet to transform the DOM with.
        </para>
      </section>
      <section>
        <title>PustefixContextDirectOutputRequestHandler</title>
        <para>
          In contrast to <classname>AbstractPustefixXMLRequestHandler</classname> and descendants, this request handler
          does not produce it's output by transforming XML with a XSLT
          stylesheet into HTML. There are situations where you need to stream some other format like pdf or images like
          PNG or GIF instead.
          The <classname>PustefixContextDirectOutputRequestHandler</classname> is used for exactly this purpose, because 
          it delegates request processing to
          <literal>DirectOutputState</literal> objects which are allowed to write directly to the <literal>HttpServletResponse</literal>'s
          <literal>OutputStream</literal>.
        </para>
      </section>
      <section>
        <title>PustefixContextXMLRequestHandler</title>
        <para>
          This is the main request handler that handles almost all pages in a typical Pustefix application - everything
          that produces HTML to be
          precise. The servlet doesn't do much on it's own, it delegates the request processing to a
          <literal>de.schlund.pfixcore.workflow.Context</literal> object. This Context is created by the 
          <classname>PustefixContextXMLRequestHandler</classname>
          once for every session, stored into the <literal>HttpSession</literal> and reused for all later requests.
        </para>
        <para>
          A Pustefix application has exactly one <classname>PustefixContextXMLRequestHandler</classname>. 
          Although more than one additional <classname>>PustefixContextDirectOutputRequestHandler</classname>
          could be used, there is usually no need for such a configuration.
        </para>
      </section>
    </section>
  </section>

  <section xml:id="concepts.request_processing">
    <title>Processing of Requests</title>
    <para>
      Every request that arrives at a pustefix application is processed in a specific way, depending
      on the HTTP request handler that is being
      selected by the <classname>PustefixHandlerMapping</classname>.
      In this chapter we will show how <classname>PustefixContextXMLRequestHandler</classname> handles
      requests.
    </para>
    <para>
      The special processing of requests by this HTTP request handler is called the
      <emphasis>Pustefix Request Cycle</emphasis>. It is important to understand how this cycle works, and how to configure it in such a way to achieve the desired result
      for each request.
    </para>
    <para>
      The main "director" in this cycle is the
      <code>Context</code>
      object, that will handle all the processing logic and call other objects to handle the business logic part of the request
      cycle (aka: do something useful with all the user supplied parameters of the request). The other main participants are
      implementations of the
      <code>State</code>
      and
      <code>PageFlow</code>
      interfaces.
    </para>
    <para>
      Pustefix supplies default implementations of these interfaces.
    </para>
      
    <section xml:id="concepts.request_processing.context">
      <title>The Context</title>
      <para>
        The <classname>PustefixContextXMLRequestHandler</classname> does most of the request handling in an object called the
        <literal>"context"</literal>. The interface <interfacename>Context</interfacename> provides the applications
        view on this object. From the applications view the context mainly is:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Providing an interface to <literal>de.schlund.pfixcore.workflow.ContextResource</literal> objects.
            These objects contain the data and the methods needed to implement the desired functionality of a project.
            Each Context objects initializes one de.schlund.pfixcore.workflow.ContextResourceManager, which in turn
            initializes all the requested ContextResources. All user data must be stored in ContextResources instead
            of directly into the HttpSession (this is by design, because a HttpSession only allows to store untyped
            String-to-Object relations, while the ContextResources can expose arbitrary complex access methods to the stored data).
          </para>
        </listitem>
        <listitem>
          <para>
            Providing a pluggable authentication mechanism that is called before any request processing to check if the
            current session has the needed privileges.
          </para>
        </listitem>
        <listitem>
          <para>
            Mapping of requested pagenames (aka "PageRequests") to the objects that implement the functionality that should
            be supplied by the page. The Context (with the help of a PageMap object initialized on startup of the Context)
            checks which page is requested and uses the associated de.schlund.pfixcore.workflow.State object to dispatch the
            request processing to. See below for more details on this process. Note that for each State only one instance is
            created, so no local data can be stored in States - all session data must be stored in ContextResources.
          </para>
        </listitem>
        <listitem>
          <para>
            Organizing pages into PageFlows to provide a small scale "workflow management". PageFlows are linear lists of
            PageRequests which should be stepped through in order. The Context advances a PageFlow after a request has been
            handled sucessfully, ie. no error has happened as the result of processing the request data. The detailed rules on how
            page flows work and how the Context steps through them are explained below.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The context provides a de.schlund.pfixxml.SPDocument to the servlet. This class is a small wrapper around a
        org.w3c.Document and supplies the XML input document for the final transformation which produces the HTML output.
        Besides the DOM tree it contains the information the system needs to choose the right stylesheet for the desired
        page that is to be shown plus some other stuff like XSLT parameters that should be set for the transformation process.
        The Context doesn't produce the SPDocument itself but delegates this to the State's getDocument() method.      
      </para>
    </section>

  <section xml:id="concepts.request_processing_pageflow">
    <title>PageFlow</title>
      <para>
      For the <code>PageFlow</code>
      interface there is currently only one implementation, and at the time of this writing it's not yet possible to change this
      implementation by supplying your own, although this is planned for the near future. The current implementation is called
      <code>DataDrivenPageFlow</code>, and it will be explained in more detail below. For the discussion presented 
      here, it is sufficient to know the general <code>PageFlow</code> interface.

      <programlisting language="java"><![CDATA[
public interface PageFlow {
    String getName();
    String getRootName();
    boolean containsPage(String pagename);
    String findNextPage(PageFlowContext context, String currentpagename, boolean stopatcurrentpage, boolean stopatnextaftercurrentpage) throws PustefixApplicationException;    
    boolean precedingFlowNeedsData(PageFlowContext context, String currentpagename) throws PustefixApplicationException;
    boolean hasHookAfterRequest(String currentpagename);
    void hookAfterRequest(Context context, ResultDocument resdoc) throws PustefixApplicationException, PustefixCoreException;
    void addPageFlowInfo(String currentpagename, Element root);
}
      ]]></programlisting>
          
        Both <code>getName()</code> and <code>getRootName()</code> return the name of the pageflow, the difference being that <code>getName()</code> contains the full qualified name (the root name
        together with any variant name, if present) while get RootName() only returns the root name.   
    </para>
    <para>
      <code>containsPage(String pagename)</code> must return true if the given page name is part of the page flow. 
    </para>
    <para>
      <code>findNextPage(...)</code> is more interesting. It implements the main duty of a page flow: To supply some sort of "next" page, given the context (in the form of a 
      <code>PageFlowContext</code> which is just a stripped down version of the <code>Context</code> interface to only support getting information, but no
      changing the inner state of the context object), the information what the current page name is (<code>currentpagename</code>), and two
      flags:
        <itemizedlist>
          <listitem><para><code>stopatcurrentpage</code>: If set to true and the current page is part of the pageflow, then the page flow searches no 
          further for another matching page then the current page. I.e. for the linear page flows of the <code>DataDrivenPageFlow</code> implementation
           this means checking all the (accessible) pages starting at the head of the flow if they need data (that means: The associated <code>State</code> returns <code>true</code> for method call
           <code>needsData(...)</code>) - if yes, that page is returned. But if the page under consideration
           is the current page, return it in any case even if it doesn't need data.</para></listitem>
           <listitem><para><code>stopatnextaftercurrent</code>: This is is similar to the first flag, only that we don't stop the page flow search at the current page, but 
           instead at the next accessible page <emphasis>after</emphasis> the current page.</para></listitem>
        </itemizedlist>
    </para>
    <para>The rest of the methods will be explained in more detail below.</para>
    </section>
 
    <section xml:id="concepts.request_processing_states">
    <title>States</title>
    <para>
      The situation is different for
      <code>State</code>s; Pustefix supplies implementations to cover most of the needs one may have in a normal application, however there are
      always situations where it is needed or at least much easier to write a specialized
      <code>State</code>
      instead of trying to re- or misuse one of the two "standard" implementations supplied with the framework.
    </para>
    <para>
      These two implementations are
      <code>StaticState</code>
      and
      <code>DefaultIWrapperState</code>. The first is used for all
      <emphasis>static</emphasis>
      pages, i.e. pages that don't need to process any input parameters, but merely display more or less static content. The only
      dynamic thing this state can do is to include information from
      <emphasis>context resources</emphasis>
      into it's output DOM tree. The second one implements the concept of
      <emphasis>wrappers and handlers</emphasis>, which is the standard way in pustefix to handle input data.
    </para>
    <para>
      Both of these states inherit from the abstract class
      <code>StateImpl</code>, a class that implements a bunch of helper methods useful for basically every conceivable state implementation. So it is
      strongly suggested to use this (or one of the two described states) as the base class for your own implementations.
    </para>
    <para>
      While both of these states will be explained in detail below, it is important to note that the context only knows about
      states, not a special implementation of it. So on this level it makes no difference if a request supplies data to be
      processed, or if it only request the display of a certain page. So the only thing we need to know for this chapter is the
      interface all states have to implement:

      <programlisting language="java"><![CDATA[
public interface State {
    boolean        isAccessible(Context context, PfixServletRequest preq) throws Exception;
    boolean        needsData(Context context, PfixServletRequest preq) throws Exception;
    ResultDocument getDocument(Context context, PfixServletRequest preq) throws Exception;
}
      ]]></programlisting>

      These three methods are quite easy to explain.
      <code>isAccessible(...)</code>
      is used to check if a page is accessible (the exact wording would be "the associated
      <code>State</code>
      of the page", but we use page/state interchangeable here, as there is a n:1 association of pages to states anyway, i.e.
      every page has exactly one associated state, but most of the time many pages share the same state. States are singletons, so
      they don't store any data themselves. This allows to share them between many pages).

      <code>getDocument(...)</code>
      is the method that does all the work. Here we produce the result DOM tree that is used to render the final HTML page with.

      <code>needsData(...)</code>
      is (or better: can be) used only during
      <emphasis>page flow processing</emphasis>
      to determine what the next page is that needs to be shown. This method will be explained when we describe the
      <code>PageFlow</code>
      and it's default implementation in greater detail below.
    </para>
    </section>

    <section>
      <title>Influencing the page request cycle</title>
        <para>During the request-response cycle, the <code>Context</code> maintains a set of variables that influence the processing of the request.
        These are listed in the following table. Use these as a reference to see how they can be set and changed, either by specifying
        values for them in the request (directly, or by referencing an action that sets them) or by calling a method of <code>Context</code>
        somewhere from Java code during the processing of the request.</para>
         
        <table rules="all" frame="box">
          <caption>Variables of the context during processing</caption>
            <thead>
              <tr>
                <th>Variable</th>
                <th>Type</th>
                <th>Usage</th>
                <th>How to set?</th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td>currentpagerequest</td>
                <td>PageRequest</td>
                <td>
                  This is basically the object representing the current page we use to process the request. The value of
                  currentpagerequest that is valid at the end of processing becomes the page to be displayed.
                  <para>
                  This variable must never be unset again after initialization during the whole request cycle (it only changes to other
                  PageRequests).</para>
                </td>
                <td>
                  Supplied by the request via either the first request path element (e.g.
                  http://host.dom/PAGE?...) or if this is not given via the request parameter
                  <code>__page</code>.
                  
                  <para> In Pustefix, this is usually transparent to the user: For POST requests, use the
                  <code>send-to-page</code> attribute of <code>pfx:forminput</code>
                  (this defaults to the current page if <code>send-to-page</code> is not given) and for GET requests, use
                  the <code>page</code> attribute of <code>pfx:button</code>.
                  </para>
                  <para> If no page information can be retrieved from 
                  the request, use the default page given in the configuration.
                  </para>
                </td>
              </tr>
              <tr>
                <td>currentpageflow</td>
                <td>PageFlow</td>
                <td>
                  Default is null. This object represents the currently valid page flow (if any). 
                  If it is null, there is no page flow selected.
                </td>
                <td>
                  Can be explicitly set via the parameter <code>__pageflow</code> (in Pustefix used via the 
                  attribute <code>pageflow</code> to either 
                  <code>pfx:button</code> or <code>pfx:xinp type="submit|image"</code> via the request or by setting
                  the <code>pageflow</code> attribute of a configured action).
                  <para>
                    Can also be set from Java by using the <code>context</code> method <code>setCurrentPageFlow(String name).</code>
                  </para>
                  <para><emphasis>
                  The current page flow is very often not set explicitly, but selected automatically by the context. See below for 
                  a detailed explanation of the rules that apply in these cases.
                  </emphasis></para>
                </td>
              </tr>
              <tr>
                <td>prohibitcontinue</td>
                <td>boolean</td>
                <td>
                Default is <code>false</code>, if set to <code>true</code> during the request processing, the context will
                not use the pageflow (if any) to determine the next page to show, but instead use the currentpagerequest and
                display the associated page.</td>
                <td>
                Can be set from the outside by using the request parameter <code>__forcestop=true</code> (maps to setting
                the <code>forcestop</code> attribute of <code>pfx:button</code> or <code>pfx:xinp type="submit|image"</code> 
                to <code>true</code> or by calling a configured action with this attribute set to <code>true</code>).
                <para> 
                There is also a method in the context called <code>prohibitContinue()</code> to set this value to <code>true</code>.
                <emphasis>If by any means this value becomes <code>true</code>, there is no way to reset the value
                to <code>false</code> again!</emphasis>
                </para>
                </td>
              </tr>
              <tr>
                <td>jumptopage and jumptopageflow</td>
                <td>String</td>
                <td>
                Default is null for both. If set, <code>jumptopage</code> is interpreted as a page name that should be displayed 
                <emphasis>after</emphasis> the current request is processed and only if <code>prohibitcontinue</code> is 
                not set to <code>true</code> (in which case, as described below in more detail, no further processing takes place
                and the current page is displayed).
                <para>
                The <code>jumptopageflow</code> variable only has an effect if also <code>jumptopage</code> is set. It is used to set the current page flow to
                another page flow when jumpting to the target page of <code>jumptopage</code>.
                </para>
                <para>
                With other words, 
                this mechanism is used to <emphasis>jump</emphasis> to another page after the current request has been successfully
                handled.</para></td>
                <td>
                  This entry can be set quite similar to the <code>pageflow</code> variable above: We have <code>__jumptopage</code> and
                  <code>__jumptopageflow</code>, normally created via the attributes <code>jumptopage</code> and 
                  <code>jumptopageflow</code> in either <code>pfx:button</code>, <code>pfx:xinp type="submit|image"</code> or a
                  configured action.
                  <para>
                    There are also two methods in the <code>context</code> that can be used to set these values from Java: 
                    <code>setJumpToPage(String name)</code> 
                    and <code>setJumpToPageFlow(String name)</code>.
                  </para>
                </td>
              </tr>
              <tr>
                <td>stopnextforcurrentrequest</td>
                <td>boolean</td>
                <td>Default is <code>false</code>. Only has an effect if a page flow is set, and the current page is indeed 
                a member of this page flow.
                <para> 
                If set to true the pageflow is expected to return the next accessible page <emphasis>after</emphasis> the 
                current page in the pageflow. The meaning of "after" depends on the implementation of the <code>PageFlow</code> 
                used for the current flow. The default implementation (<code>DataDrivenPageFlow</code>) 
                works with linear flows, so there is always a clear 
                understanding of what is "before" and "after" a page in the flow. 
                Other implementations may have a more complicated interpretation.
                </para>
                </td>
                <td>
                  Can be set directly in a request by using <code>__forcestop=step</code> (and of course the same for the 
                  attributes to the Pustefix tags and configured actions). 
                  <para>This may seem strange, as that parameter is also 
                  used to set the <code>prohibitcontinue</code> variable, but as it makes no sense to specify both of 
                  them at the same time (<code>prohibitcontinue</code> effectively prohibits the use of a pageflow because the current page
                  is being displayed anyway and no page flow is asked for the next page to display), there is no need to have an independent 
                  parameter or attribute.
                  </para> 
                </td>
              </tr>
              <tr>
                <td>startwithflow</td>
                <td>boolean</td>
                <td>Default is <code>false</code>. This variable is used to instruct the <code>Context</code> to not directly use the page that is 
                submitted with the request (and which is still used to set the <code>currentpagerequest</code> variable), but instead ask the current pageflow for
                the next page to use. So the caller doesn't actually know which page will be the one to display. Most often, setting this parameter also implies explicitely 
                setting a page flow via the methods listed above. We will cover this special case in more detail below.</td>
                <td>This variable can be set via the request parameter <code>__startwithflow</code>. With Pustefix tags this is achived by setting the
                <code>startwithflow</code> attribute of <code>pfx:button</code> to <code>true</code>. 
                <para>There is no such possibility for <code>pfx:xinp type="submit|image"</code>, because 
                it makes no sense for a request which supplies data to not know where to submit to. Also using <code>startwithflow="true"</code> with 
                <code>pfx:button</code> implies that the request will not being marked as one that sends data, even if there are <code>pfx:argument</code> nodes attached.
                </para>
                </td>
              </tr>
            </tbody>
        </table>
        <para>
        The <code>currentpageflow</code> variable needs some more 
        explanation, as in many cases, it is not given explicitly neither by submitting an action that specifies the page flow nor directly from the request parameter <code>__pageflow</code>.
        If this is the case, the <code>Context</code> tries to find a <emphasis>matching</emphasis> page flow by using the following algorithm.
        
        <orderedlist>
          <listitem><para>
            If the current page is a member of exactly one page flow, this flow will become the current page flow.
          </para></listitem>
          <listitem><para>
            If the current page is a member of more than one page flow, the <code>Context</code> checks if one of these flows has been the <emphasis>last flow</emphasis> 
            the system has used in any request before (so this even applies if the system didn't use a page flow at all during the last requests). If this is the case,
            the system uses this flow as the current page flow. This has the effect that a page flow will remain the current flow as long as the pages used for requests are at least
            a member of this flow.
          </para></listitem>
          <listitem><para>
            If the last flow isn't part of the list of flows matching the current page, the system checks if the current page specifies a <code>defaultflow</code> in its 
            configuration (and makes sure that the page is really a member of this flow!). 
            If yes, this flow is preferred and returned as the current page flow. If not, the first of the list will be returned. 
          </para></listitem>
          <listitem><para>
            If the current page is not a member of any flow, the current page flow remains unset (the <code>currentpageflow</code> variable remains <code>null</code>).
          </para></listitem>
        </orderedlist>
      </para>
    </section>

    <section>
      <title>The basic Pustefix Request Cycle</title>
      <para> 
        In this section we want to explain the way the request cycle is handled in Pustefix by the <code>Context</code> and its peer objects (<code>State</code>, <code>PageFlow</code>) used during
        processing.
      </para>
      <para>
        After the variables have been initialized, we have two different ways to go on. Either <code>startwithflow</code> is set to <code>true</code>, or not.
        The first case will be explained below in more detail, for now we assume that the value of <code>startwithflow</code> is <code>false</code>.
        We also do neglect some other aspects, that have to be taken care of during request processing: Role based authentication isn't mentioned here and also the fact that each 
        <code>State</code> will always be asked if it is accessible before calling one of the other two methods won't be mentioned explicitly for the remainder of this explanation.  
      </para>
      <para>
        <orderedlist>
          <listitem><para>
            The first action to take is calling <code>getDocument(...)</code> on the <code>State</code> associated with the current page. 
          </para></listitem>
          <listitem><para>
            If the current page flow has <emphasis>After-Request-Hooks</emphasis> defined (this is checked by calling the method 
            <code>hasHookAfterRequest(...)</code> on 
            the current <code>PageFlow</code>), these hooks are being run by calling <code>hookAfterRequest(Context context, 
            ResultDocument resdoc)</code>. The <code>ResultDocument</code> used
            here is the return value from the <code>getDocument(...)</code> call above. These hooks can basically do anything that can 
            be achieved with the help of the <code>Context</code>
            interface (changing <code>jumptopage/jumptopageflow</code>, calling <code>prohibitContinue()</code> and so on). The interesting 
            thing here is that they not only have access to the
            <code>Context</code> object, but also the resulting DOM-Tree of the processing of the current page. We will learn about an 
            example of such hooks when we look at the current standard 
            implementation <code>DataDrivenPageFlow</code>. 
          </para></listitem>
          <listitem><para>
            Now we check if <code>prohibitcontinue</code> is set to <code>true</code>. If yes, the <code>ResultDocument</code> will be 
            used to display the current page. The request cycle ends here.
          </para></listitem>
          <listitem><para>
            If <code>prohibitcontinue</code> is still false, check if  <code>jumptopage</code> is set. If yes, set the 
            <code>currentpagerequest</code> to the <code>jumptopage</code> (and also change
            <code>currentpageflow</code> to something that matches, preferring <code>jumptopageflow</code>, if it is set); 
            <code>jumptopage/jumptopageflow</code> are unset to avoid recursion, then we re-enter the process at point 1.
          </para></listitem>
          <listitem><para>
            If <code>jumptopage</code> is not set, we try to use the current page flow to get the next page by calling 
            <code>findNextPage(..., ..., false, stopnextforcurrentrequest)</code>. We set this page to be the current page, 
            call <code>getDocument</code> on its associated <code>State</code> and use the 
            returned <code>ResultDocument</code> to display the page. The request cycle ends here (there is 
            no recursive call of the page flow process!). 
          </para></listitem>
          <listitem><para>
            If no current page flow is set (<code>currentpageflow == null</code>), we simply use the resulting ResultDocument
            of the initial call to <code>getDocument(...)</code> and use it
            to display the current page.             
          </para></listitem>
        </orderedlist>
      </para>
      
      <section>
         <title>Accessibility of pages</title>
         <para>
           Up to now, we mostly neglected the fact that a page could also be not accessible, which it is if the associated <code>State</code>
           returns <code>false</code> for a call to its method <code>isAccessible(...)</code>. This method is checked each time before the
           <code>Context</code> tries to call <code>getDocument(...)</code> for a page. The <code>PageFlow</code> is also expected to only
           return a page that is accessible, and to check the accessibility before each call to <code>needsData(...)</code>. 
           </para>
           <para>
           If the initially requested page is not accessible, but a page flow is set, 
           the <code>Context</code> will try to find a matching page by calling 
           <code>findNextPage(..., ..., false, stopnextforcurrentrequest)</code>. Because this method is expected to only return 
           a page that is accessible (if it doesn't find one, it must throw an exception) we can safely set this page to be 
           the new current page and start with the request cycle as usual.
         </para>
         <para>
            If no page flow is set, the system will try to use the default page from the configuration. If this is indeed accessible,
            it will be set as the new current page, and the whole process continues normally from there. If also the default page
            is not accessible, an exception will be thrown.
         </para>
         <para>
           Usually this case won't happen, because you have to force Pustefix to generate a link to a page that is currently 
           not accessible by using the <code>mode="force"</code> attribute on <code>pfx:button</code>. But this procedure is
           also done when the current page has been set from the <code>jumptopage</code> variable and the request 
           cycle is being restarted (see above). To avoid to see any strange behavior and pages that have never been
           intended to be displayed, it's important to make sure that a <code>jumptopage</code> request only references a page 
           that will be accessible. 
         </para>
         <para>
           This accessibility check must also be run by the <code>PageFlow</code> before calling <code>needsData(...)</code> or 
           before returning any page name from <code>findNextPage(...)</code>. It is expected to simply ignore any page that is not
           accessible and continue searching for another "next" page. As already explained above, if it is not able to find a page that 
           is accessible, it must throw an exception.
         </para>
      </section>

      <section>
         <title>Processing when <code>startwithflow=true</code></title>
         <para>
         Another change in request processing happens when the startwithflow variable is set to <code>true</code>. In this case,
         the context doesn't expect to get a valid pagerequest from the request itself (although there is one supplied, see below
         for the special meaning of this page name), so it has to "search" for the page to handle
         the request processing. This search is done by directly switching to the page flow handling part of the code to retrieve 
         the "next" page that is suggested by the page flow. 
         </para>
         <para>
           Other than in the case of the usual page flow processing, 
           there is some special trick
           involved: If during searching for the next page the page flow encounters the supplied page from the request, it will return
           this page regardless if it needs data or not. In other words: You can limit the search in the page flow by supplying a 
           page that is part of this flow. If the page is not part of the page flow or it is inaccessible, it is ignored (But note that
           the default page flow implementation <emphasis>DataDrivenPageFlow</emphasis> also sets the supplied page to be the <emphasis>
           final page</emphasis> (see below for details on this), so essentially every supplied page becomes part of the 
           page flow. But this behavior is not part of the contract between PageFlow and Context and just an implementation detail
           of <code>DataDrivenPageFlow</code>).
         </para>
         <para>
           On a quick look, this seems to be almost the same as what is done when a request comes in to a page, that is not
           accessible (see above). In this case, too, a new page ist searched by asking the page flow for the next page.
           The main difference is that a "normal" request will always use the supplied page, as long as it is accessible, while
           in the startwithflow case it will only be used if no other "earlier" candidates have been returned by the page flow.
         </para>
      </section>
    </section>
   
    <section>
      <title>Pustefix <code>State</code> implementations</title>
      <para>
        Despite all the explanation about States, most of the time one doesn't write States directly, but rather uses one of two predefined
        States (or trivial descendants of them).
      </para>
      <section>
        <title>StaticState</title>
        <para>
           The first is <literal>de.schlund.pfixcore.workflow.app.StaticState</literal>literal>. This State is used when the page doesn't
           need to process any input data. This is true for most of the purely informative pages of a website (e.g. documentation,
           product information).  StaticState returns true for any call to needsData, which makes it of course unusable for any
           non-trivial pageflow as described here. Also any call to isAccessible returns true. For the creation of the output DOM tree,
           the State respects the <literal>&lt;output&gt;</literal> nodes of the page definition in the context configuration file, but of course any
           <literal>&lt;input&gt;</literal> nodes are ignored.
        </para>
      </section>
      <section>
        <title>DefaultIWrapperState and IHandlers</title>
        <para>
          Of course it would be possible to write specialised States for every page that needs application logic.
          Experience shows however that the reuseable components of the application logic are not complete pages, but smaller
          parts that make up the whole functionality of the page. So we need a way to aggregate these smaller parts into a
          predefined State that delegates and distributes the calls made by the Context.
        </para>
        <para>
          The State that implements this is called <literal>de.schlund.pfixcore.workflow.app.DefaultIWrapperState</literal>.
          The corresponding logical "atomic" components are implementations of <literal>de.schlund.pfixcore.generator.IHandler</literal>.
          Associated to these IHandlers are container classes (implementations of de.schlund.pfixcore.generator.IWrapper) that
          hold the user supplied input data that these handlers should work on. The IWrapper classes are autogenerated from a
          XML description that is explained in more detail here.
        </para>
        <para>
          An IHandler has the following simple interface:
        </para>
        <itemizedlist>
          <listitem><para>boolean needsData(Context)</para></listitem>
          <listitem><para>boolean prerequisitesMet(Context)</para></listitem>
          <listitem><para>boolean isActive(Context)</para></listitem>
          <listitem><para>void retrieveCurrentStatus(Context, IWrapper)</para></listitem>
          <listitem><para>void handleSubmittedData(Context, IWrapper)</para></listitem>
        </itemizedlist>
        <para>
          The corresponding methods of the <literal>State</literal> interface and the mappings to the <literal>IHandler</literal> 
          methods are:
        </para>
        <itemizedlist>
          <listitem><para><literal>boolean needsData(Context, PfixServletRequest)</literal>: 
           this method is just delegated to all defined IHandlers. If any of those returns true, the return value of the State
           methods is true, too and false otherwise.</para></listitem>
          <listitem><para><literal>boolean isAccessible(Context, PfixServletRequest)</literal>: this method maps on the two 
          IHandler methods prerequisitesMet and isActive. The default algorithm works like this: In a first round, on all 
          IHandlers the prerequisitesMet() method is called. If any of the IHandlers returns false here, the return value of 
          the whole State method is false. If all IHandler return true, a second iteration over the IHandler is made with a call 
          to their isActive method. This time, the logic is reversed: if any IHandler returns true, the State method is true, too.
           It only returns false when no IHandler's isActive method returns true. It's possible to customize the behavior for this 
           second iteration in the config file with the policy attribute of the <literal>&lt;input&gt;</literal> node.</para></listitem>
          <listitem><para><literal>ResultDocument getDocument(Context, PfixServletRequest)</literal>: this method is mapped on 
          either retrieveCurrentStatus or handleSubmittedData depending if the request is submitting user data by means of a GET
           request or a form submit (in this case handleSubmittedData would be called) or if the request just wants a page to be 
           displayed (which would result in retrieveCurrentStatus to be called).</para></listitem>
        </itemizedlist>
        <para>
          Some important things to note:
        </para>
        <itemizedlist>
          <listitem><para>No IHandler method returns a ResultDocument (which is basically a wrapper around the DOM tree that is 
          used for the final transformation to generate the HTML output). In a State it's possible (in fact needed) to 
          create the ResultDocument itself and it's easy to put additional nodes into the DOM tree inside the getDocument 
          method. By design, this no longer works with IHandlers. All output should be generated from the configured
           ContextRessources listed below the <literal>&lt;output&gt;</literal> node of the config file.</para></listitem>
          <listitem><para>IHandlers don't have access to the PfixServletRequest (which is basically a wrapper around 
          HttpServletRequest). All in- or output of parameters must take place via the typesave getter and setter methods 
          of the associated IWrapper object. In the handleSubmittedData method one typically reads the values as they are 
          supplied from the request, and in the retrieveCurrentStatus method one sets the parameters as they are given by the
          current status of the application to pre-fill form elements on the user interface (Note: the Pustefix elements
          to create form elements take care to automatically use the values as supplied via the IWrapper to pre-fill form
          elements. If you generate your form with other XSLT tags or with the original html elements, this will no longer
          work ot of the box).</para></listitem>
        </itemizedlist>
        <section>
          <title>The Context and DefaultIWrapperState</title>
          <para>
            It's an important property of Pustefix that the Context doesn't know anything of IHandlers/IWrappers. From the view of
            the Context, it always works with States and nothing else. This section describes the way the DefaultIWrapperState and
            the Context play together.
          </para>
          <para>
            A request can be processed in two different ways by the getDocument(...) method of DefaultIWrapperState:
          </para>
          <orderedlist>
            <listitem>
              <para>
                A request that submits data (as can be detected with the help of the method isSubmittrigger(...)) will be
                processed like this (EOR means end of request):
              </para>
              <itemizedlist>
                <listitem>
                  <para>
                    All IWrappers will initialize their data from the request.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    On all IHandlers will be called handleSubmit(...) with the approbiate IWrapper object as a parameter.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The system checks if there has been an error during processing the reuqest.
                  </para>
                  <para>
                    If yes, put all the error codes into the ResultDocument and tell the context to stop at the current page
                    (by calling context.prohibitContinue()). EOR.
                  </para>
                  <para>
                    If no, the system needs to decide to either stay on the current page (and display it again) or hand back the control
                    to the Context to start a pageflow process that determines the next page to display. This decision is made be
                    looking at the state of the context and the set of IHandlers. There are 3 different cases to consider:
                  </para>
                  <orderedlist>
                    <listitem>
                      <para>
                        First we need to decide if there is anything that actively forces the system to stay on the page even
                        in the case of a successful submit. Two cases must be consideres here: The context method prohibitContinue()
                        has already been called (which can be checked by calling the Context method isProhibitContinueSet()).
                        This will always force the context to stop the process, use the returned ResultDocument and display
                        the current page. For the second case, depending on which IHandlers have been called to handle data
                        (this can be a subset of all the IHandlers on the page, see here on how to restrict the submit to a subset
                        of the full set of defined IHandlers), the DefaultIWrapperState decides to stay on the current page.
                        A simplified explanation of the algorithm is like this: When only a subset of the IHandlers have been
                        used to handle a data submiting request, force the system to stay on the current page. There is an
                        exception to this rule, though: When all the IHandlers of the restricted subset are also marked with
                        the continue attribute on the corresponding <literal>&lt;interface&gt;</literal> node in the config file set to
                        <literal>true</literal>, then don't force the system to stay on the current page. All of this does NOT
                        apply when the request has set a JumpToPage (this can be queried from the Context with the method
                        isJumpToPageSet()) - in this case the JumpToPage takes precedence. NOTE: this will maybe be removed in
                        the future and the default will be to try to continue with the pageflow in any case, despite any restricted
                        subset of IHandlers.
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Alternatively we try to check if we really want to give control back to the Context to determine the next page.
                        This will happen if one of three conditions is true:
                      </para>
                      <itemizedlist>
                        <listitem><para>A JumpToPage has been set.</para></listitem>
                        <listitem><para>The current page is part of the current pageflow</para></listitem>
                        <listitem><para>
                          Or the current pageflow has been set explicitly by the request (in this case, the current page
                          doesn't need to be a member of this flow).</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                    <listitem>
                      <para>
                        The default for the DefaultIWrapperState if none of the above conditions is true is to stay on the current page.
                      </para>
                      <para>
                        If the result of these checks is to stay on the current page, call prohibitContinue() on the Context and
                        call retrieveCurrentStatus() on the suitable IHandlers - suitable in this case means a) if no restriceted
                        subset of IHandlers is selected, use all that are defined or b) use the restricted subset and additionally
                        all IHandlers that have the alwaysretrieve attribute on their corresponding <literal>&lt;interface&gt;</literal>
                        node in the config file set to true. EOR.
                      </para>
                    </listitem>
                  </orderedlist>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>
                A request for a page that doesn't submit data (direct trigger), or a request that comes in while a pageflow
                is processed or a request that is the result of a final page instruction.
              </para>
              <itemizedlist>
                <listitem><para>All IWrappers will initialize their data from the request.</para></listitem>
                <listitem><para>
                  call retrieveCurrentStatus() on all the defined IHandlers, and force the Context to stop
                  further processing by calling prohibitContinue(). EOR.</para>
                </listitem>
             </itemizedlist>
           </listitem>
          </orderedlist>
        </section>
      </section>
    </section>
      
    <section>
      <title>Pustefix <code>PageFlow</code> implementation: <code>DataDrivenPageFlow</code></title>
      <para> 
      </para>
    </section>
      
  </section>
  
  <section>
    <title>The data model: Context resources</title>
    <para>
      Pustefix provides an abstraction layer for management of application state. You generally don't directly work on the Servlet API layer,
      e.g. you don't directly store session state in the <literal>HttpSession</literal> object, but you use Java beans which are automatically managed 
      by the framework, so-called <literal>ContextResource</literal> beans. 
    </para>
    <para>
      In prior versions Pustefix itself controlled the lifecycle of these beans, e.g. instantiated them on session startup, and you had to
      implement a specific interface (<literal>de.schlund.pfixcore.workflow.ContextResource</literal>). Beginning with Pustefix 0.13 
      <literal>ContextResource</literal> beans are automatically managed by Spring and can be arbitrary POJOs.
    </para>
    <para>
      <literal>ContextResource</literal> beans are not only used to manage application state, but they are also linked to the view. They can be 
      declaratively assigned to pages and thus serialized to the XML tree, which is used as source of the XSL transformation producing the output. 
      A <literal>ContextResource</literal> can either be automatically serialized to XML, or it can implement its own method manually creating according
      DOM output.
    </para>
  </section>
   
  <section>
    <title>Wrappers and Handlers</title>
    <para>
      Write introduction...
    </para>
    <section>
      <title>IWrappers</title>
      <para>
        IWrappers are used to store the request data that is used as input for corresponding
        IHandler classes. IWrappers are not explicitly written by the developer, but are
        generated from .iwrp files which contain a high level XML description of the parameter
        types and certain checks that should be applied to them. Each .iwrp file is translated
        into a .java file with the same name during the build process, and a java class is
        created. In the corresponding IHandler, you use the IWrapper to access or store data
        by calling the IWrapper's get and set methods.
      </para>
      <para>
        The syntax of the .iwrp file is given below.
      </para>
      <programlisting language="xml"><![CDATA[<interface xmlns="http://www.pustefix-framework.org/2008/namespace/iwrapper"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.pustefix-framework.org/2008/namespace/iwrapper 
                      http://www.pustefix-framework.org/2008/namespace/iwrapper.xsd"
  extends="mypackage.MyIWrapperClass">
  <!--
    The class attribute references the associated IHandler class. Alternatively you can
    reference an existing Spring bean using the bean-ref attribute.
    The ihandler node is optional, but if it is left out, the generated
    IWrapper will be abstract and cannot be used directly, unless an extends attribute
    has been given to the interface node. Normally you will want to specify an ihandler
    class here.
  -->
  <ihandler class="mypackage.MyIHandlerClass"/>
  <!-- or <ihandler bean-ref="aBean"/> -->
  <!--
    This node can (and usually will) occur multiple times, one for every parameter that
    should be part of the interface
  -->
  <param name="AName" type="some.java.Type" occurrence="optional|mandatory|indexed" frequency="single|multiple" missingscode="some.defined.statuscode">
    <!--
      The whole node is optional. It allows to specify a default value (or multiple) for
      a parameter to use, when no value is supplied via the request. Note that this makes
      the destinction between optional and mandatory parameters nonsensical.
    -->
    <default>
      <value>a_default_value</value>
      <value>an_other_default_value</value>
    </default>
      
    <!--
      To test if a param value conforms to the rules, you can specify Check-Classes here
      whose check method will be called to test if the param value makes sense.
      The Check-Classes must implement de.schlund.pfixcore.generator.IWrapperParamPreCheck
      (the interface defines the check(...) method).
    -->
    <precheck class="a.prechecker.class">
      <cparam name="APreCheckerParamName" value="APreCheckerParamValue"></cparam>
    </precheck>
      
    <!--
      Each parameter must be casted from a String to the specific type (unless the type is java.lang.String itself, in this case, no caster need to be supplied). This is done by means of a class implementing de.schlund.pfixcore.generator.IWrapperParamCaster. For the usual simple types you can use a caster from the package de.schlund.pfixcore.generator.casters.
    -->
    <caster class="de.caster.class">
      <cparam name="ACasterParamName" value="ACasterParamValue"></cparam>
    </caster>

    <postcheck class="a.postchecker.class">
      <cparam name="APostCheckerParamName" value="APostCheckerParamValue"></cparam>
    </postcheck>
  </param>
</interface>]]></programlisting>
      <section>
        <title>Parameters</title>
        <para>
          When defining the parameters for your wrapper, the following attributes are
          supported in the <literal>iwrp</literal> format:
        </para>
        <para>
          <table rules="all" frame="box">
            <caption>Attributes of an iwrp parameter</caption>
            <thead>
              <tr>
                <th>Attribute name</th>
                <th>Mandatory?</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>name</td>
                <td>mandatory</td>
                <td>The name of the parameter. This is used in the getter and setter methods that are generated. E.g. for the parameter name Foo there will be - amongst others - a corresponding java method called getFoo.</td>
              </tr>
              <tr>
                <td>type</td>
                <td>mandatory</td>
                <td>The java type of the parameter. This will determine the return type of the generated getter method.</td>
              </tr>
              <tr>
                <td>occurrence</td>
                <td>Optional, default is mandatory</td>
                <td>This attribute specifies if the parameter must be given (mandatory), or if it's not considered to be an error if it is omitted (optional). The special value indexed tells the system that it should search for occurrences of the parameter name with a suffix appended of the form AParamName.ASuffix. The suffix string must be unique for every occurrence of the parameter named AParamName. Indexed parameters are never mandatory.</td>
              </tr>
              <tr>
                <td>frequency</td>
                <td>Optional, default is single</td>
                <td>This attribute specifies if only one parameter of the same name should be accepted or multiple. This determines if the generated getter method's return value is a single object or an array.</td>
              </tr>
              <tr>
                <td>missingscode</td>
                <td>Optional, default is de.schlund.pfixcore.generator.MISSING_PARAM</td>
                <td>This attribute applies only to mandatory parameters. It allows to specify a different than the default StatusCode to use when the parameter is not supplied.</td>
              </tr>
            </tbody>
          </table>
        </para>
        <para>
          IWrappers support different parameter types that result in  different
          method signatures in the generated wrapper code.
        </para>
        <para>
          The parameter type is influenced by the attributes <literal>occurrence</literal>
          and <literal>frequency</literal>
        </para>
        <section>
          <title>Single mandatory/optional parameters</title>
          <para>
            In most cases, your wrappers will be used to accept and validate simple input parameters, like
            data entered in input fields. These parameters are created setting <literal>frequency</literal>
            to <literal>single</literal> and <literal>occurrence</literal> to <literal>mandatory</literal>
            or <literal>optional</literal>.
          </para>
          <para>
            This will lead to the following methods:
          </para>
          <programlisting language="java"><![CDATA[public class MyWrapper {
    Bar  getFoo();
    void setFoo(Bar value);
    void setStringValFoo(String str_value);
    void addSCodeFoo(de.schlund.util.statuscode.StatusCode scode);
    void addSCodeWithArgsFoo(de.schlund.util.statuscode.StatusCode scode, String[] args);
}]]></programlisting>
        </section>
        <section>
          <title>Multiple mandatory/optional parameters</title>
          <para>
            In some cases, a parameter might be present in a page more than once. This might be the
            case for a list of checkboxes, where all input tags have the same name, but different
            values. These parameters are created setting <literal>frequency</literal>
            to <literal>multiple</literal> and <literal>occurrence</literal> to <literal>mandatory</literal>
            or <literal>optional</literal>.
          </para>
          <para>
            This will lead to the following methods:
          </para>
          <programlisting language="java"><![CDATA[public class MyWrapper {
    Bar[] getFoo();
    void  setFoo(Bar[] value);
    void  setStringValFoo(String[] str_value);
    void  addSCodeFoo(de.schlund.util.statuscode.StatusCode scode);
    void  addSCodeWithArgsFoo(de.schlund.util.statuscode.StatusCode scode, String[] args);
}]]></programlisting>
        </section>
        <section>
          <title>Single indexed parameters</title>
          <para>
            Pustefix also allows you to repeat a parameter inside a page/request and access
            all occurrences of the parameter using an index. In the request, the parameter and
            the index are separated using a <literal>.</literal> (dot).
          </para>
          <para>
            These parameters are created setting <literal>frequency</literal>
            to <literal>single</literal> and <literal>occurrence</literal> to <literal>indexed</literal>.
          </para>
          <para>
            This will lead to the following methods:
          </para>
          <programlisting language="java"><![CDATA[public class MyWrapper {
    Bar  getFoo(String index);
    void setFoo(Bar value, String index);
    void setStringValFoo(String str_value, String index);
    void addSCodeFoo(de.schlund.util.statuscode.StatusCode scode, String index);
    void addSCodeWithArgsFoo(de.schlund.util.statuscode.StatusCode scode, String[] args, String index);
}]]></programlisting>
        <para>
          This is very helpful, if you have a list of entities (like users, books, etc.) and it is possible
          to edit the data of several of these entities in one form.
        </para>
        </section>
        <section>
          <title>Multiple indexed parameters</title>
          <para>
            Of course, it is also possible to combine multiple and indexed parameters in
            a wrapper.
          </para>
          <para>
            These parameters are created setting <literal>frequency</literal>
            to <literal>multiple</literal> and <literal>occurrence</literal> to <literal>indexed</literal>.
          </para>
          <para>
            This will lead to the following methods:
          </para>
          <programlisting language="java"><![CDATA[public class MyWrapper {
    Bar[] getFoo(String index);
    void  setFoo(Bar[] value, String index);
    void  setStringValFoo(String[] str_value, String index);
    void  addSCodeFoo(de.schlund.util.statuscode.StatusCode scode, String index);
    void  addSCodeWithArgsFoo(de.schlund.util.statuscode.StatusCode scode, String[] args, String index);
}]]></programlisting>
        </section>
      </section>
    </section>
   <section>
      <title>The <literal>InputHandler</literal> interface</title>
      <para>
        The <literal>InputHandler</literal> interface is the replacement for the deprecated <literal>IHandler</literal> interface.
        Its advantages are: you get rid of casting because it's generic, and the methods don't declare to throw <literal>Exception</literal>,
        which forces sensible exception handling.
      </para>
      <programlisting language="java"><![CDATA[public interface InputHandler<T extends IWrapper> {
    void    handleSubmittedData(T wrapper);
    void    retrieveCurrentStatus(T wrapper);
    boolean prerequisitesMet();
    boolean isActive();
    boolean needsData();
}]]></programlisting>
    </section>
    <section>
      <title>The deprecated <literal>IHandler</literal> interface</title>
      <para>
        The <literal>IHandler</literal> interface is deprecated. Use <literal>InputHandler</literal> instead.
      </para>
      <programlisting language="java"><![CDATA[public interface IHandler {
    void    handleSubmittedData(Context context, IWrapper wrapper) throws Exception;
    void    retrieveCurrentStatus(Context context, IWrapper wrapper) throws Exception;
    boolean prerequisitesMet(Context context) throws Exception;
    boolean isActive(Context context) throws Exception;
    boolean needsData(Context context) throws Exception;
}]]></programlisting>
    </section>
  </section>
<section xml:id="concepts.statuscodes">
<title>StatusCodes</title>
<para>
StatusCodes are assigned to IWrapper parameters and form fields to indicate invalid data and display according error messages. They are automatically assigned by the framework when prechecks, casters or postchecks fail, or they can be assigned programmatically by the application logic.
</para>
<para>
The framework predefines some common StatusCodes, e.g. <literal>MISSING_PARAM</literal> - indicating the missing of a mandatory form value, or StatusCodes for builtin prechecks, casters and postchecks, like <literal>precheck.REGEXP_NO_MATCH</literal> - indicating that a form field's value doesn't match a given regular expression. Application developers can arbitrarily define additional StatusCodes.
</para>
<para>
StatusCodes are defined as normal include parts. They're placed in their own files located under the <literal>dyntxt</literal> directory. Within such a statuscode file the part names uniquely identify the StatusCode, the content nested inside the part element represents the message. 
</para>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<include_parts xmlns:ixsl="http://www.w3.org/1999/XSL/Transform" xmlns:pfx="http://www.schlund.de/pustefix/core">
  <part name="ILLEGAL_LOGIN">
    <theme name="default">Illegal login data.</theme>
  </part>
  ...
</include_parts>
]]></programlisting>
<para>
Those StatusCode files are used by the build process to automatically create Java classes containing the StatusCodes as constants, using the part names as field names (in uppercase form). Thus the StatusCodes can be safely referenced from within Java code. 
</para>
<para>
Before the StatusCode files are recognized by the build process, they have to be configured inside a statuscode metainformation file. The file has to be called statuscodeinfo.xml and has to be located in the project's <literal>conf</literal> directory or in the <literal>dyntxt</literal> directory. Within this file you define which StatusCode constant class is built from which StatusCode files.
</para>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<statuscodeinfo xmlns="http://www.pustefix-framework.org/2008/namespace/statuscodeinfo" 
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.pustefix-framework.org/2008/namespace/statuscodeinfo 
                                    http://www.pustefix-framework.org/2008/namespace/statuscodeinfo.xsd">
  <statuscodes class="example.bank.BankStatusCodes">
    <file>statusmessages.xml</file>
    <file>...</file>
  </statuscodes>
  ...
</statuscodeinfo>
]]></programlisting>
<para>
Using the above examples Pustefix will build the following Java class (excerpt):
</para>
<programlisting language="java"><![CDATA[
package example.bank;
...
public class BankStatusCodes {
    public static StatusCode getStatusCodeByName(String name) { ... }
    ...
    public static final StatusCode ILLEGAL_LOGIN = new StatusCode("ILLEGAL_LOGIN", __RES[0]);
}
]]></programlisting>
<para>
The following login handling example uses the generated StatusCode class to indicate a failed login:
</para>
<programlisting language="java"><![CDATA[
public class LoginHandler implements InputHandler<Login> {
    public void handleSubmittedData(Login login) {
        //check login data
        //if invalid
        login.addSCodeUser(BankStatusCodes.ILLEGAL_LOGIN);
    }
}
]]></programlisting>
<para>
If you take a look at the resulting XML tree, you see like the according include part is referenced inside the <literal>error</literal> element (and thus can be displayed on the page using the <literal>pfx:checkfield</literal>, <literal>pfx:error</literal> and <literal>pfx:scode</literal> tags).
</para>
<programlisting language="xml"><![CDATA[
<formresult ...>
   ...
   <formvalues>
      <param name="login.User">xyz</param>
      ...
   </formvalues>
   <formerrors>
     <error name="login.User">
        <pfx:include href="samplebank/dyntxt/statusmessages.xml" part="ILLEGAL_LOGIN"/>
     </error>
   </formerrors>
   ...
</formresult>
]]></programlisting>
<para>
If your error message should contain dynamic data, you can use placeholders, which will be replaced by the arguments passed along with the addScode call at the IWrapper:
</para>
<programlisting language="xml"><![CDATA[
<part name="ILLEGAL_LOGIN">
  <theme name="default">User <pfx:argref pos="1"/> is illegal.</theme>
</part>
]]></programlisting>
<para>
StatusCodes can be also referenced from within IWrapper definitions. If you're using a built-in StatusCode (from org.pustefixframework.generated.CoreStatusCodes), you can just use its name, if you're using a StatusCode from another module, you have to prefix the name with the class name of the generated class separated by a <literal>#</literal> sign:
</para>
<programlisting language="xml"><![CDATA[
<interface xmlns="http://www.pustefix-framework.org/2008/namespace/iwrapper">

  <ihandler class="..."/>
  
  <param name="Login" type="..." missingscode="example.bank.BankStatusCodes#MISSING_LOGIN_DATA">
    ...
  </param>

</interface> 
]]></programlisting>
<para>
The statusmessage files for statuscodes coming from the Pustefix core or arbitrary modules can be edited to customize the messages for your project's requirements. Therefor the original statusmessage files are initially copied or if a copy already exists, the files are merged (statusmessages for new statuscodes are added, statusmessages for omitted statuscodes are removed) by the build process. You should only customize these merged files, changes in the original files will be overwritten with the next module update.
</para>
<para>
The built-in core and editor statuscodes are merged to <literal>projects/core-override/dyntxt/statusmessages-core-merged.xml</literal> and <literal>projects/core-override/dyntxt/statusmessages-editor-merged.xml</literal>. Pustefix module statuscodes are merged to <literal>projects/modules-override/MODULENAME/dyntxt/statusmessages-merged.xml</literal>.
</para>
</section>
<section xml:id="concepts.interceptors">
  <title>ContextInterceptors</title>
  <para>
    Pustefix provides a mechanism to hook custom logic into the request processing lifecycle. Therefor it provides a set of interception points, where you can register classes or Spring beans implementing the <literal>ContextInterceptor</literal> interface, which then are automatically called during the processing of a request. 
  </para>
  <itemizedlist>
    <para>Common use cases for <literal>ContextInterceptors</literal> are:</para>
    <listitem>
      <para>
        Implementation of cross-cutting concerns like logging, cleanup.
      </para>
    </listitem>
    <listitem>
      <para>
        Implementation of standard design patterns like Hibernate's "Open Session in view".
      </para>
    </listitem>
    <listitem>
      <para>
        Triggering logic/setting data independent of the requested page, e.g. setting a variant.
      </para>
    </listitem>
    <listitem>
      <para>
        Handling of common, page-independent/shared parameters.
      </para>
    </listitem>
  </itemizedlist>
  <para>
  <figure xml:id="concepts.interceptors.figure">
        <title>ContextInterceptors</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/reference/concepts-interceptors.png" format="PNG"/>
          </imageobject>
        </mediaobject>
  </figure>
  </para>
  <para>
    Currently Pustefix supports three interception points: <literal>start</literal>, which is right before the actual request handling gets started, <literal>end</literal>, which is right after the DOM result tree has been created, and <literal>postrender</literal>, which is right after the view has been rendered.
  </para>
<programlisting language="java"><![CDATA[
public interface ContextInterceptor {
    void process(Context context, PfixServletRequest preq);
}
]]></programlisting>
  <para>
    The framework calls the <literal>process</literal> method of the registered <literal>ContextInterceptor</literal> implementations, passing the <literal>Context</literal> and <literal>PfixServletRequest</literal> as parameters.
  </para>
  <note>
    Comparison with <literal>ServletFilters</literal>: <literal>ServletFilters</literal> apply right before/right after a request/response enters/leaves the framework's processing layer and give you means to manipulate the incoming <literal>ServletRequest</literal> and outgoing <literal>ServletResponse</literal>, whereas <literal>ContextInterceptors</literal> are part of the framework's lifecycle and give you direct access to the request (but not the response), <literal>Context</literal> and other Spring beans, and are meant to trigger logic or set data.
  </note>
  <para>
   <literal>ContextInterceptors</literal> are configured in the <literal>Context's</literal> configuration file. Below you can see an a sample configuration fragment showing all available configuration options:
  </para>
<programlisting language="xml"><![CDATA[
<context-xml-service-config>
 
   <context> ... </context>

   <!-- ContextInterceptors are defined within the <interceptors> element directly following the <context> element. -->
   <interceptors>

     <!-- The interceptors are grouped by their interception points (start, end, postrender), which are represented 
            by accordingly named elements. -->
     <start>

        <!-- Interceptors are registered either by setting the ContextInterceptor implementation class or by setting 
               an according reference to a Spring bean configured elsewhere. -->
        <interceptor class="mypackage.MyStartInterceptor"/>

        <!-- If you're setting an implementation class, the framework will create an according Spring bean for you. 
               By default it will get Singleton scope, but you can provide an alternative scope using the scope attribute. --> 
        <interceptor class="mypackage.MySessionScopedInterceptor" scope="session"/>

        <interceptor bean-ref="myStartInterceptor"/>

     </start>

     <end> ... </end>

     <postrender> ... </postrender>

   </interceptors>

   ...

</context-xml-service-config>
]]></programlisting>
  <para>
    The following example interceptor tries to guess from which country the client request is coming and sets a special variant if it comes from Germany. Therefor it checks the client's IP retrieved from the servlet request using a GeoLocationAPI. It sets a flag after the first check to avoid multiple checks. Remembering the flag this way only works when the interceptor has session scope and synchronization can be omitted because the operation is repeatable and boolean access is atomic.
  </para>
<programlisting language="java"><![CDATA[
public class MySessionScopedInterceptor implements ContextInterceptor {
	
	private boolean checked;

	@Override
	public void process(Context context, PfixServletRequest preq) {
		if(!checked) {
			String country = GeoLocationAPI.getCountry(preq.getRemoteAddr());
			if(country.equals("DE")) context.setVariant("foo");
			checked = true;
		}
	}
	
}
]]></programlisting>
  <note>
    <para><literal>ContextInterceptors</literal> are singleton-scoped beans by default. So if you want to store data or call non-threadsafe code, you possibly will have to do some synchronization or use an appropriate scope.</para>
    <para><literal>ContextInterceptors</literal> are called on every request. So you shouldn't execute long-running tasks and avoid that time-consuming code is unnecessarily called with each invocation.</para>
  </note>
</section>
</chapter>
