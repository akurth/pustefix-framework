<?xml version="1.0"?>
<chapter xml:id="advanced" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0CR7/xsd/docbook.xsd">
  <title>Advanced topics</title>

  <section xml:id="advanced.variantsandthemes">
    <title>Variants and Themes</title>
    <para></para>
    <section xml:id="advanced.variantsandthemes.themes">
      <title>Themes</title>
      <para>
        Describe themes here.
      </para>
    </section>
    <section xml:id="advanced.variantsandthemes.variants">
      <title>Variants</title>
      <para>
        Variants are a way to have the same page look and behave different depending
        on a variant id that can be set freely at runtime. This allows to select different
        look and behaviour depending on data collected during the user sesion.
      </para>
      <section>
        <title>Selecting a variant</title>
        <para>
          Variants can be selected by calling the method <literal>setVariant(Variant var)</literal>
          in the Context. This will store and reuse the id for the current and all following
          requests until it is set to a different id (or erased by setting it to null).
        </para>
        <para>
          The <literal>Context</literal> takes care to set the variant in the
          <literal>SPDocument</literal> it returnes to the AbstractXMLServer which
          in turn tries to get the matching target for the requested page and
          requested variant.
          If no target matching the variant is found, the "root" variant
          (in other words, the page without a variant at all) will be tried.
        </para>
        <para>
          When defining variants of pages, the system automatically makes sure
          that you can only define variants for a page that has also a no-variant
          definition. This works for pages defined using the &lt;standardpage&gt; tag and
          for pages defined by hand using &lt;target&gt; tags directly.
        </para>
        <para>
          The valid characters for variants are a-zA-Z0-9_+- (but see below for compound variants and the use of the : character).
        </para>
      </section>
      <section>
        <title>Compound Variants</title>
        <para>
          Variants can be variants of variants themself which in turn can be considered variants of another variant. The name of a variant that is a subvariant of another variant must be expressed in the following way: foo:bar:baz
        </para>
        <para>
          Here we have a variant that is a subvariant of foo:bar which in turn is a subvariant of foo. This information is used when determining the right Target for generating the output. Say the variant foo:bar:baz has been set via the setVariant(Variant var) method of the Context and the request wants to display the page Home. When trying to get the matching Target for transforming the output the system first tries to get the matching Target for Home, variant foo:bar:baz. If it gets no result, it goes on trying Home, variant foo:bar; then Home, variant foo before finally requesting the "root" variant of page Home.
        </para>
      </section>
      <section>
        <title>Variant features</title>
        <para>
          Variants can influence the way an application works:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              They can change the look and content of a page. This is implemented in
              terms of themes that depend on the selected variant. See below for more
              details.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              They can change the backend definition of a pagerequest
              (aka: Handlers, State, and output from ContextRessources)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              They can change the definition of a pageflow
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Defining variants of pages</title>
        <para>
          Different variants of pages are usually defined via the standardpage tag:
        </para>
        <programlisting language="xml"><![CDATA[<standardpage xml="MyProject/xml/frame.xml" name="Home" variant="foo:bar:baz">]]></programlisting>
        <para>
          What's interesting here is how the system produces the themes attribute used for
          the two targets that result from the expansion of the standardpage tag.
        </para>
        <para>
          If we have not given a special local themes attribute to the standardpage tag,
          and no global themes attribute has been given (see here), then the value of the
          themes attribute for both targets is in this example <literal>baz bar foo MyProject default</literal>.
        </para>
        <para>
          As can be seen, the use of the variant attribute will expand the themes as they would
          be valid for the targets produced from the standardpage tag (either by using a
          locally defined themes attribute of the standardpage tag, or automatically by
          using the global fallback) by putting more specific themes in front of the
          themes list, which are generated from the given variant id. If the variant id
          is a compount variant, then each segment of the compound variant will be used,
          from right to left, to generate a theme name to be put before the "normal"
          themes valid for the page.
        </para>
        <para>
          If the standardpage had its own themes attribute given (say for example
          "<literal>theme_a theme_b default</literal>"), the resulting themes after taking the
          variant id into account would of course be <literal>baz bar foo theme_a theme_b default</literal>.
        </para>
      </section>
      <section>
        <title>Defining variants of pagerequests</title>
        <para>
          Variants can also be used to create different implementations for the same
          pagerequest. This is done by a simple extension to the way a pagerequest is
          defined in the servlet configuration file.
        </para>
        <programlisting language="xml"><![CDATA[<pagerequest name="foo">
  <default>
    [Any other tag that is allowed inside a pagerequest]
  </default>
  <variant name="var_id">
    [Any other tag that is allowed inside a pagerequest]
  </variant>
  <variant name="another_var_id">
    [Any other tag that is allowed inside a pagerequest]
  </variant>
 </pagerequest>]]></programlisting>
        <note>
          <para>You must give a <literal>&lt;default&gt;</literal> definition when using named variants.</para>
          <para>Each of the <literal>&lt;default&gt;</literal> and all <literal>&lt;variant&gt;</literal> definitions are self contained, full definitions of pagerequests. Nothing is shared between them.</para>
        </note>
       </section>
      <section>
        <title>Defining variants of pageflows</title>
        <para>
          Variants can also be used to create different implementations for the
          same pageflow. This is done by a simple extension to the way a pageflow is
          defined in the servlet configuration file.
        </para>
        <programlisting language="xml"><![CDATA[<pageflow name="fooFlow">
  <default>
    [Any other tag that is allowed inside a pageflow]
  </default>
  <variant name="var_id">
    [Any other tag that is allowed inside a pageflow]
  </variant>
  <variant name="another_var_id">
    [Any other tag that is allowed inside a pageflow]
  </variant>
</pageflow>]]></programlisting>
        <note>
          <para>You must give a <literal>&lt;default&gt;</literal> definition when using named variants.</para>
          <para>Each of the <literal>&lt;default&gt;</literal> and all <literal>&lt;variant&gt;</literal> definitions are self contained, full definitions of pagerequests. Nothing is shared between them.</para>
        </note>
      </section>
    </section>   
  </section>

  <section xml:id="advanced.pagealternatives">
    <title>Page alternatives</title>
     <para>
        Page alternatives are different representations of the same logical page. Page
        alternatives are internally used to create different versions for languages/tenants, but can be also used for
        pages which are based on a common page, assigned to the same logical page, but with different content and display pagename, e.g.
        landing pages (see <xref linkend="configuration.sitemap"/>).
      </para>
      <para>
        Conceptually related to page variants, page alternatives are implemented on a lower level. Creating a page alternative
        automatically creates alternatives for all variants of a page, i.e. all existing standardpage definitions of a page
        are copied, thus providing an own stylesheet per alternative.
      </para>
      <para>
        The definition of page alternatives is done within the sitemap configuration:
      </para>
<programlisting language="xml"><![CDATA[<sitemap>
  <page name="Info">
    <alt key="cities" name="Cities"/>
    <alt key="nationalparks" name="NationalParks"/>
    <alt key="mountains" name="Mountains"/>
  </page>
</sitemap>]]></programlisting>
      <para>
         Every page alternative has a key, which is referred to select the matching alternative. The key can be programmatically
         set using the <literal>Context</literal> method <literal>setPageAlternative(String key)</literal>. During the XSL transformation
         the key can be accessed using the parameter <literal>$pageAlternative</literal>. The key will be also inserted into
         the theme fallback chain. Thus you can produce different content per alternative.
      </para>
  </section>

  <section xml:id="advanced.i18n">
    <title>Internationalization</title>
    <para>
      Pustefix provides various mechanisms to implement internationalized applications. You can write applications
      which have a fixed language which is selected/resolved at buildtime using the theme mechanism 
      (see <xref linkend="advanced.variantsandthemes"/>) or the dynamic include mechanism 
      (see <xref linkend="advanced.dyninclude"/>). You can make the language
      switchable at runtime using the language-aware core tags (see <xref linkend="xslt.pfx.langselect"/>).
    </para>
    <para>
      Using Pustefix's multitenancy support (see <xref linkend="advanced.multitenancy"/> you get a combination
      of both mechanisms. Pages have a fixed language, but an own instance is created for each language, and thus
      the language is switchable at runtime too.
    </para>
      <para>
		Your business logic can query the currently selected language using the <literal>Context</literal>
	        method <literal>getLanguage()</literal>, using <literal>setLanguage(String language)</literal>,
		you can change the selected language at runtime.
      </para>
  </section>

  <section xml:id="advanced.multitenancy">
    <title>Multitenancy</title>
    <para>
      Pustefix provides basic multitenancy support, i.e. a single application instance can serve multiple tenants, like markets or 
      countries. Tenants are automatically selected by matching host name patterns against the requested
      host name. Tenant configuration is done within <literal>project.xml</literal> or included configuration fragments 
      (see <xref linkend="configuration.project.projectxml"/>).
    </para>
<programlisting language="xml"><![CDATA[<project-config>
  
  <tenant name="CA_market">
    <choose>
      <when test="$mode='prod'">
        <host>.*\.ca$</host>
      </when>
      <otherwise>
        <host>^ca\..*</host>
      </otherwise>
    </choose>
    <lang default="true">en_CA</lang>
    <lang>fr_CA</lang>
  </tenant>

  <!-- include tenants config fragments from all modules found in classpath -->
  <config-include file="conf/project-fragment.xml" section="tenants" module="*"/>
  
</project-config>]]></programlisting> 
    <para>
      The current multitenancy support concentrates on the view layer. Pustefix automatically creates tenant and language specific 
      versions of all pages. Tenant/language specific page content is created by applying filters to the dynamic include mechanism, 
      thus overriding and extending the core page content with tenant- and/or language-specific content from according 
      tenant/language modules (see the following examples of a tenant and language Pustefix module descriptor, also see 
      (<xref linkend="modulessupport.types.new"/>).
    </para>
<programlisting language="xml"><![CDATA[<module-descriptor>

  <module-name>pustefix-i18n-tenant-ca</module-name>

  <default-search priority="1">
    <filter-attribute name="tenant" value="CA_market"/>
  </default-search>
  
</module-descriptor>]]></programlisting> 
<programlisting language="xml"><![CDATA[<module-descriptor>

  <module-name>pustefix-i18n-lang-fr</module-name>

  <override-modules>
    <filter-attribute name="lang" value="fr"/>
    ...
  </override-modules>

</module-descriptor>]]></programlisting>
    
    <para>
       Application developers can query the currently set tenant at runtime using the <literal>Context</literal> method 
       <literal>getTenant()</literal>. Additionally Pustefix automatically adds an element <literal>&lt;tenant&gt;</literal>
       to the result DOM tree. During XSL transformations the tenant targeted by the transformation can be accessed
       using the XSL parameter <literal>$tenant</literal>.
    </para>
    <para>
       Static resources, like error pages, can also be delivered in a language/tenant-specific way. Optionally resources can be
       searched using tenant and language as path components, e.g. with tenant set to "Canada" and language set to "fr_CA", the
       static page <literal>/pages/error404.html</literal> will be searched in the following locations (highest priority first):
    </para>
    <screen>/pages/Canada/fr_CA/error404.html
/pages/Canada/fr/error404.html
/pages/Canada/error404.html
/pages/fr_CA/error404.html
/pages/fr/error404.html
/pages/error404.html
</screen>
  </section>

  <section xml:id="advanced.dyninclude">
    <title>Dynamic resource inclusion</title>
    <para>
      Pustefix applications can be modularized by packaging/sharing application parts or components as Pustefix modules, which are regular
      Jar files with a defined directory structure and a special deployment descriptor (see <xref linkend="modulessupport"/>). Pustefix modules
      not only contain Java classes, but can contain any kind of resource, like XML, XSL, Javascript, CSS or image files.
    </para>
    <para>
      Prior Pustefix releases required that these resources were extracted to the file system by the build process to be usable in an application.
      Meanwhile Pustefix supports that XML and XSL files used by the rendering engine (TargetGenerator) can be directly loaded from the module
      jar files.
    </para>
    <para>
      Developing strongly modularized applications often requires, that you want to be able to adapt parts of a shared
      module to your application's context without breaking the modularization. Therefor Pustefix supports the dynamic inclusion of resources,
      which allows you to provide a local version of a resource, which will be automatically taken instead of the according version from a module jar.
      Additionally resources from modules can be overridden by other modules.
    </para>
    <section xml:id="advanced.dyninclude.modinclude">
      <title>Including resources from modules</title>
      <para>
        Resources from modules are directly used by additionally specifying the name of the module. Therefor the according tags from the Pustefix tag library and
        the configuration elements in <literal>depend.xml</literal> provide a <literal>module</literal> attribute.
      </para>
      <para>
        samplemodule.jar
        <screen>META-INF/pustefix-module.xml
PUSTEFIX-INF/img/image.png
PUSTEFIX-INF/img/theme/image.png
PUSTEFIX-INF/txt/common.xml
PUSTEFIX-INF/txt/pages/main_page.xml
PUSTEFIX-INF/xml/frame.xml
PUSTEFIX-INF/xsl/metatags.xsl
PUSTEFIX-INF/xsl/skin.xsl</screen>
      </para>
      <para>
        Let's take a look at how the various resources from the sample module can be directly included using the Pustefix tag library:
        <programlisting language="xml"><![CDATA[<pfx:xinp type="image" src="img/image.png" module="samplemodule"/>]]></programlisting>
        <programlisting language="xml"><![CDATA[<pfx:image themed-path="img" themed-img="image.png" module="samplemodule"/>]]></programlisting>
        <programlisting language="xml"><![CDATA[<pfx:include part="foo" href="txt/common.xml" module="samplemodule"/>]]></programlisting>
        <programlisting language="xml"><![CDATA[<pfx:maincontent part="content" path="txt/pages" module="samplemodule"/>]]></programlisting>
      </para>
      <para>
        You just have to set the <literal>module</literal> attribute and be aware that the file paths are relative to the <literal>PUSTEFIX-INF</literal> root folder from the module jar file.
      </para>
      <note>
        If you're using includes from within a module and you're omitting the <literal>href</literal> or <literal>module</literal> attribute, you should be aware of the following behaviour:
        <itemizedlist>
          <listitem>if you're only specifying the <literal>part</literal> attribute, the include is loaded from the current file from within the current module</listitem>
          <listitem>if you're specifying <literal>part</literal> and <literal>href</literal>, the include is loaded from the specified href/path from within the current module</listitem>
          <listitem>if you're specifying <literal>part</literal> and <literal>module</literal>, the include is loaded from the href/path of the current file from within the specified module</listitem>
        </itemizedlist>
      </note>
      <note xml:id="advanced.dyninclude.modinclude.special">
        <title>Special module names</title>
        If you want to explicitly reference an include from the application, you can use the special module name <emphasis>webapp</emphasis>, which indicates
        Pustefix, that it shouldn't look in the current module as done by default, but load the file from the webapp folder.
        If you want to explicitly reference an include from the module where the page is defined (where the config fragment with the <literal>standardpage</literal> definition resides), you can use the special name <emphasis>pagedef</emphasis>.
      </note>
      <para>
        If you want to directly reference XML/XSL files in the <literal>depend.xml</literal> configuration file, this works the same way by adding a <literal>module</literal> attribute to the according elements:
      </para>
<programlisting language="xml"><![CDATA[
<standardmaster>
  <include stylesheet="xsl/skin.xsl" module="samplemodule"/>
</standardmaster>
]]></programlisting>
<programlisting language="xml"><![CDATA[
<standardmetatags>
  <include stylesheet="xsl/metatags.xsl" module="samplemodule"/>
</standardmetatags>
]]></programlisting>
<programlisting language="xml"><![CDATA[
<standardpage name="page" xml="xml/frame.xml" module="samplemodule"/>
]]></programlisting>
      <para>
        Including or importing a stylesheet from a module into another stylesheet can be done using a <literal>module</literal> URI:
      </para>
<programlisting language="xml"><![CDATA[
<xsl:import href="module://samplemodule/xsl/test.xsl"/>
]]></programlisting>
      <para>
         A module URI complies with the hierarchical URI syntax <literal>[scheme:][//authority][path][?query][#fragment]</literal>. The <literal>scheme</literal> has to be set to <literal>module</literal> and the authority part is set to the module name. The <literal>path</literal> has to be relative to the <literal>PUSTEFIX-INF</literal> folder.
      </para>
      <para>
        Such URIs also can be programmatically used to get a module resource with the <literal>ResourceUtil</literal> helper class:
      </para>
<programlisting language="java"><![CDATA[Resource res = ResourceUtil.getResource("module://samplemodule/txt/test.txt");]]></programlisting>
    </section>
    <section xml:id="advanced.dyninclude.dynamic">
      <title>Dynamic search</title>
      <para>
        Resources included from modules can be overridden by providing an alternative version in the project itself or in the common folder. Resources included from the common folder can be overridden by a project specific version as well.
      </para>
      <para>
        Therefor you have to place the overriding file under the same relative path in your project/application or the common directory and set the <literal>search</literal> attribute of the according Pustefix tag to <literal>dynamic</literal>.
      </para>
        <programlisting language="xml"><![CDATA[<pfx:include part="foo" href="txt/common.xml" module="samplemodule" search="dynamic"/>]]></programlisting>
        <programlisting language="xml"><![CDATA[<pfx:image src="img/image.png" module="samplemodule" search="dynamic"/>]]></programlisting>
      <para>
        Setting <literal>search</literal> to <literal>dynamic</literal> the resource will be searched at different pre-defined locations in the following order:
      </para>
      <itemizedlist>
        <listitem>In the project's folder: <literal>projects/myproject/path/to/resource</literal></listitem>
        <listitem>In the common folder: <literal>projects/common/path/to/resource</literal></listitem>
        <listitem>In all overriding modules (see next section): <literal>PUSTEFIX-INF/path/to/resource</literal></listitem>
        <listitem>In the specified module: <literal>PUSTEFIX-INF/path/to/resource</literal></listitem>
      </itemizedlist>
      <para>
        If you omit the <literal>module</literal> attribute, the resource will be only searched in the project's and the common folder.
      </para>
      <note>
        If you're dynamically searching for an include part and a file is found in the fallback chain, but doesn't contain the requested part, the search will move along to the next level. In contrast, themes aren't taken into account, i.e. the first file containing the searched part will be returned, regardless of how specific the contained themes are.
      </note>
      <programlisting language="xml"><![CDATA[<pfx:image themed-path="img" themed-img="image.png" module="samplemodule" search="dynamic"/>]]></programlisting>       
      <para>
        If you're dynamically including a themed image, the search iterates over the theme list on each fallback level, e.g. the theme fallback list "<literal>foo bar default</literal>" will result in the following search:
      </para>
      <screen>projects/myproject/img/foo/image.png
projects/myproject/img/bar/image.png
projects/myproject/img/default/image.png
projects/common/img/foo/image.png
projects/common/img/bar/image.png
projects/common/img/default/image.png
...
      </screen>
      <note>
        If you're dynamically searching for a themed image and a matching file is found, the returned image will be the one with the most specific theme on the current fallback level, images matching more specific themes down in the fallback chain aren't taken into account.  
      </note>
    </section>
    <section xml:id="advanced.dyninclude.override">
      <title>Overriding module resources</title>
      <para>
        Resources from modules can be overridden by other modules. Therefor a module can declare, which resources from which module it wants to override. This declaration is done within its module descriptor (see <xref linkend="modulessupport"/>).
      </para>
<programlisting language="xml"><![CDATA[<module-descriptor 
     xmlns="http://www.pustefix-framework.org/2008/namespace/module-descriptor"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.pustefix-framework.org/2008/namespace/module-descriptor
                         http://www.pustefix-framework.org/2008/namespace/module-descriptor.xsd">

  <module-name>module-B</module-name>

  <override-modules>
    <module name="module-A">
      <resource path="txt/common.xml"/>
    </module>
  </override-modules>

</module-descriptor>
]]></programlisting>
      <para>
        In this example <literal>module-B</literal> overrides a resource of <literal>module-A</literal>. This means that <literal>module-B</literal> is inserted into the fallback chain for the resource right after the <literal>common</literal> folder and right before <literal>module-A</literal>.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:include part="foo" href="txt/common.xml" module="module-A" search="dynamic"/>]]></programlisting>
      <para>
        Trying to dynamically include part <literal>foo</literal> from <literal>txt/common.xml</literal> and <literal>module-A</literal> will result in the following fallback chain:
      </para>
      <screen>projects/myproject/txt/common.xml
projects/common/txt/common.xml
module://module-B/txt/common.xml
module://module-A/txt/common.xml</screen>
      <para>
        An overriding module itself can be overridden by another module. Consider the following descriptor for <literal>sample-module-C</literal>:
      </para>
<programlisting language="xml"><![CDATA[<module-descriptor 
     xmlns="http://www.pustefix-framework.org/2008/namespace/module-descriptor"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.pustefix-framework.org/2008/namespace/module-descriptor
                         http://www.pustefix-framework.org/2008/namespace/module-descriptor.xsd">

  <module-name>module-C</module-name>

  <override-modules>
    <module name="module-B">
      <resource path="txt/common.xml"/>
    </module>
  </override-modules>

</module-descriptor>
]]></programlisting>
    <para>
      This will result in the following new fallback chain:
    </para>
      <screen>projects/myproject/txt/common.xml
projects/common/txt/common.xml
module://module-C/txt/common.xml
module://module-B/txt/common.xml
module://module-A/txt/common.xml</screen>
    <para>
      Now we add another module, called <literal>module-A-ext</literal>, which is also overriding <literal>module-A</literal>:
    </para>
<programlisting language="xml"><![CDATA[<module-descriptor 
     xmlns="http://www.pustefix-framework.org/2008/namespace/module-descriptor"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.pustefix-framework.org/2008/namespace/module-descriptor
                         http://www.pustefix-framework.org/2008/namespace/module-descriptor.xsd">

  <module-name>module-A-ext</module-name>

  <override-modules>
    <module name="module-A">
      <resource path="txt/common.xml"/>
    </module>
  </override-modules>

</module-descriptor>
]]></programlisting>
    <para>
      The new fallback chain looks as follows:
    </para>
      <screen>projects/myproject/txt/common.xml
projects/common/txt/common.xml
module://module-C/txt/common.xml
module://module-B/txt/common.xml
module://module-A-ext/txt/common.xml
module://module-A/txt/common.xml</screen>   
     <para>
       Module <literal>module-A-ext</literal> is inserted right before <literal>module-A</literal>. This is done because the override mechanism processes the modules in alphabetic order to ensure predictable behaviour, i.e. it iterates over all modules overriding the current module resource, adding the overriding module on top of the module fallback list, and then recursively processes this module the same way. So changing the module name to <literal>module-D</literal> would have been resulted in placing the module right before <literal>module-C</literal>.
     </para>

 </section>
  </section>
  <section xml:id="advanced.rolebasedauth">
    <title>Authentication and authorization</title>
    <para>
      Pustefix provides a role-based authorization mechanism. You can define arbitrary <literal>roles</literal>, 
      declare logical operations/combinations on this roles using <literal>authconstraints</literal>, 
      and assign these authconstraints to <literal>pagerequests</literal>.
    </para>
    <section xml:id="advanced.rolebasedauth.roles">
      <title>Managing Roles</title>
      <para>
        A <literal>role</literal> is defined using an according XML element with a unique 
        <literal>name</literal> attribute value. Setting the <literal>initial</literal> 
        attribute to <literal>true</literal> the <literal>role</literal> will be automatically 
        set on context initialization.
      </para>
      <programlisting language="xml"><![CDATA[<role name="MYROLE" initial="true"/>]]></programlisting>
      <para>
        <literal>Authconstraints</literal> can combine various authorization conditions, 
        supported conditions are: <literal>hasrole</literal>, <literal>and</literal>, 
        <literal>or</literal> and <literal>not</literal>, represented by according XML elements. 
        Using the <literal>authpage</literal> attribute you can define the page, which should be 
        called on authorization failure. Using the <literal>default</literal> attribute you can 
        set one toplevel <literal>authconstraint</literal> to be the default one for 
        all <literal>pagerequests</literal> having no <literal>authconstraint</literal> asssigned.
      </para>
      <tip version="0.13.24">
        <para>
          In addition to the <literal>authpage</literal>-attribute one can define more fine-grained, 
          conditional navigation-cases via the new <literal>navigateTo</literal>-child-element to <literal>authconstraint</literal>.
        </para>
      </tip>
      <programlisting language="xml"><![CDATA[<authconstraint id="MYCONSTRAINT" authpage="login" default="true">
  <or>
    <hasrole name="MYROLE"/>
    <hasrole name="OTHERROLE"/>
  </or>
  <!-- navigate to page guests, if constraints above fail, but user still has the "GUEST"-role -->
  <navigateTo page="guests">
    <hasrole name="GUEST"/>
  </navigateTo>
</authconstraint>]]></programlisting>
      <para>
        <literal>Pagerequests</literal> can either define new <literal>authconstraints</literal> as 
        child elements or can reference existing toplevel <literal>authconstraints</literal> by 
        their <literal>id</literal>.
      </para>
      <programlisting language="xml"><![CDATA[<pagerequest name="mypage">
  <authconstraint ref="MYCONSTRAINT"/>
  ...
</pagerequest>

<pagerequest name="mypage">
  <authconstraint authpage="login">
    <hasrole name="MYROLE"/>
  </authconstraint>
  ...
</pagerequest>]]></programlisting>
      <para>
        You can programmatically set/query roles using the <literal>de.schlund.pfixcore.auth.Authentication</literal>
        object, which can be retrieved from the <literal>Context</literal> calling its <literal>getAuthentication()</literal>
        method.
      </para>
      <programlisting language="java"><![CDATA[public interface Authentication {
    public boolean hasRole(String roleName);
    public boolean addRole(String roleName);
    public boolean revokeRole(String roleName);
    
    public Role[] getRoles();    
}]]></programlisting>
      <para>
        You can add a new role using <literal>addRole()</literal>, revoke exisiting
        roles using <literal>revokeRole()</literal> or check for a role using 
        <literal>hasRole()</literal>. Using <literal>getRoles()</literal> you get an array 
        of all currently set roles.  If a default role is defined, this role will be initially set.
      </para>
      <para>
        You can also query the current roles from within your XML/XSLT code using the
        XPath extension function <literal>pfx:hasRole(rolename)</literal>
      </para>
      <programlisting language="xml"><![CDATA[<ixsl:if test="pfx:hasRole('MYROLE')">
  ...
</ixsl:if>]]></programlisting>
      <para>
        If you try to access a page for which the authconstraint isn't fulfilled, you're forwarded
        to the according login page. The login page has to be a regular page, e.g. containing a login form.
        Login forms require the <literal>type</literal> attribute set to <literal>auth</literal>.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:forminput type="auth">
  ...
</pfx:forminput>]]></programlisting>
      <para>
        The framework automatically inserts an <literal>authentication</literal> element into
        the login page's DOM tree. This element contains the state of the <literal>authenticated</literal>
        flag, the <literal>targetpage</literal> which should be accessed, the current <literal>roles</literal>
        and the <literal>authorizationfailure</literal> containing the violated
        <literal>authconstraint</literal>.
      </para>
      <programlisting language="xml"><![CDATA[<formresult>
  <authentication authenticated="true" targetpage="mypage">
    <roles>
      <role name="SOMEROLE"/>
    </roles>
    <authorizationfailure authorization="pageaccess" target="mypage">
      <authconstraint>
        <hasrole name="MYROLE"/>
      </authconstraint>
    </authorizationfailure>
  </authentication>
  ...
</formresult>]]></programlisting>
      <para>
        You can use this information to decide which information to display on the login page.
      </para>
         
      <example xml:id="rolebasedauth_example">
        <title>Configuring roles</title>
        <para>
          The following example defines three <literal>roles</literal>. The <literal>role</literal> 
          <literal>ANONYMOUS</literal> is configured as <literal>initial</literal> <literal>role</literal>,
          i.e. every session/context has this <literal>role</literal> automatically set from the beginning.
        </para>
        <para>
          There are two top-level <literal>authconstraints</literal>. The <literal>authconstraint</literal> 
          <literal>AC_DEFAULT</literal> is declared as <literal>default</literal>, i.e. pages, having no explicitly set 
          <literal>authconstraint</literal>, will get this one. The <literal>authconstraint's authpage</literal> 
          is set to <literal>login</literal> and it has a simple condition saying that it requires the <literal>role</literal> 
          <literal>ANONYMOUS</literal>.
        </para>
        <para>
          The <literal>authconstraint</literal> <literal>AC_KNOWN</literal> declares that
          it requires the <literal>USER</literal> or the <literal>ADMIN</literal> <literal>role</literal>. This
          <literal>authconstraint</literal> is referenced by the <literal>pagerequest</literal> <literal>userpage</literal>, using
          an empty <literal>authconstraint</literal> element having a <literal>ref</literal> attribute containing the
          <literal>authconstraint's</literal> id.
        </para>
        <para>
          The <literal>pagerequest</literal> <literal>adminpage</literal> contains an anonymous
          <literal>authconstraint</literal> element, which defines the <literal>role</literal> 
          <literal>ADMIN</literal> as requirement.
        </para>
        <programlisting language="xml"><![CDATA[<contextxmlserver>

  <role name="ANONYMOUS" initial="true"/>
  <role name="USER"/>
  <role name="ADMIN"/>
  
  <authconstraint id="AC_DEFAULT" authpage="login" default="true">
    <hasrole name="ANONYMOUS"/>
  </authconstraint>
  
  <authconstraint id="AC_KNOWN" authpage="login">
    <or>
      <hasrole name="USER"/>
      <hasrole name="ADMIN"/>
    </or>
  </authconstraint>
  
  <pagerequest name="home">
    ...
  </pagerequest>
  
  <pagerequest name="login">
    <input>
      ...
    </input>
  </pagerequest>

  <pagerequest name="adminpage">
    <authconstraint authpage="login">
      <hasrole name="ADMIN"/>
    </authconstraint>
    ...
  </pagerequest>
  
  <pagerequest name="userpage">
    <authconstraint ref="AC_KNOWN"/>
    ...
  </pagerequest>
  ...
</contextxmlserver>]]></programlisting>
      </example>
    </section>

    <section xml:id="rolebasedauth_customconditions">
      <title>Custom conditions</title>
      <para>
        You can extend the authentication mechanism by providing custom conditions (additionally to the predefined conditions: <literal>hasrole</literal>, <literal>and</literal>, <literal>or</literal>, <literal>not</literal>). Therefore you just have to implement the <literal>Condition</literal> interface and register your implementation class in the context configuration file. Then your custom condition can be used within authconstraints, just as the builtin conditions and arbitrarily mixed with them.
      </para>
      <para>
<programlisting language="java"><![CDATA[
public interface Condition {
    public boolean evaluate(Context context);
}
]]></programlisting>
      </para>
      <para>
        You have to implement the <literal>evaluate</literal> method, which returns if the condition is fulfilled. Therefore the evaluation logic can access the Context. Implementations shouldn't change the data model, perform fast and hold only immutable state (or be stateless).
      </para>
      <para>
        The following example shows a condition which retrieves a <literal>ContextResource</literal> for a customer and checks if its debit exceeds a configured limit. The limit is automatically set to a value configured as property in the condition's configuration.
      </para>
      <programlisting language="java"><![CDATA[package example;

import de.schlund.pfixcore.auth.Condition;
import de.schlund.pfixcore.workflow.Context;
import example.ContextCustomer;

public class PremiumCustomerCondition implements Condition {
    
    private float limit;

    public boolean evaluate(Context context) {
        ContextCustomer contextCustomer=context.getContextResourceManager().getResource(ContextCustomer.class);
        return contextCustomer.getTotalDebit() >= limit;
    }
    
    public void setLimit(float limit) {
        this.limit = limit;
    }
    
}
]]></programlisting>
      <para>
        Let's look how this condition is registered and used in the context configuration:
      </para>
      <programlisting language="xml"><![CDATA[<condition id="isPremiumCustomer" class="example.PremiumCustomerCondition">
  <property name="limit" value="100000"/>
</condition>
  
<authconstraint id="..." authpage="...">
  <and>
    <hasrole name="..."/>
    <condition ref="isPremiumCustomer"/>
  </and>
</authconstraint>]]></programlisting>
      <para>
        Conditions are registered using top-level <literal>condition</literal> elements. They require an <literal>id</literal> and a <literal>class</literal> attribute. Authconstraints can reference conditions using <literal>condition</literal> elements with an according <literal>ref</literal> attribute.
      </para>
      <para>
        Conditions can be checked from within XML/XSL using the <literal>pfx:condition</literal> function, e.g.:
      </para>    
      <programlisting language="xml"><![CDATA[<ixsl:if test="pfx:condition('isPremiumCustomer')">
  ...
</ixsl:if>]]></programlisting>
    </section>

    <section xml:id="rolebasedauth_customroleprovider">
      <title>Custom RoleProvider</title>
      <para>
        Roles by default are configured within the context configuration.
        As an alternative approach you're able to plug-in your own RoleProvider
        implementation. Thus you can provide roles programmatically or from
        another source.
      </para>
      <para>
      	You just have to implement the RoleProvider interface and register the implementation
      	class in the context configuration.
      </para>
      <programlisting language="java"><![CDATA[public interface RoleProvider {
    public Role getRole(String roleName) throws RoleNotFoundException;
    public List<Role> getRoles();
}]]></programlisting>
      <para>
        The <literal>getRole</literal> method returns a <literal>Role</literal> object by name. 
        The <literal>getRoles</literal> method returns a list of all available roles.
      </para>
      <programlisting language="java"><![CDATA[public interface Role {
    public String getName();
    public boolean isInitial();
}]]></programlisting>
      <para>
        <literal>Role</literal> objects can either be created by implementing the 
        <literal>Role</literal> interface or by using the default implementation
        <literal>de.schlund.pfixcore.auth.RoleImpl</literal>. Role implementations
        have to return a unique name and if they should be initially set.
      </para>
      <para>
        The following example shows a simple <literal>RoleProvider</literal> implementation,
        which holds the roles in a programmatically filled map.  
      </para>
      <programlisting language="java"><![CDATA[public class MyRoleProvider implements RoleProvider {
    private Map<String, Role> roles;

    public MyRoleProvider() {
        roles = new HashMap<String, Role>();
        Role role = new RoleImpl("ADMIN", false);
        roles.put(role.getName(), role);
    	...
    }

    public Role getRole(String roleName) throws RoleNotFoundException {
        Role role = roles.get(roleName);
        if(role == null) throw new RoleNotFoundException(roleName);
        return role;
    }

    public List<Role> getRoles() {
        return new ArrayList<Role>(roles.values());
    }
}]]></programlisting>
      <para>
        The <literal>RoleProvider</literal> implementation is registered using the
       	context configuration top-level <literal>roleprovider</literal> element with
       	a <literal>class</literal> attribute. You can optionally configure properties,
       	which will be automatically injected into the RoleProvider instance using
       	according setter methods (Spring bean-style setter injection).
      </para>     
      <programlisting language="xml"><![CDATA[<roleprovider class="example.MyRoleProvider">
  <property name="..." value="..."/>
</roleprovider>]]></programlisting>
    <para>
      You should be aware that the current mechanism doesn't support
      dynamic RoleProviders. The provided roles have to be constant, i.e. they're read
      at application startup time and aren't updated at a later time.
    </para>
  </section>

  </section>

  <section xml:id="advanced.ajax">
    <title>AJAX services</title>
	<para>
	  Pustefix provides AJAX-support via SOAP webservices and JSON RPC-style services. Autogenerated
      stubs and dynamic proxies make it easy to implement new services without any knowledge of the protocol
      details, among other things the protocol can be switched without changing the Javascript or Java code,
      additionally a service can work with both protocols at the same time.
    </para>
    <para>
      Implementing a service can be done in two ways: Either you can export an arbitrary Spring bean as a
      webservice or you have to create a special service class which derives from an abstract framework class.
      The first way is recommended, because your service can be a POJO without any framework dependencies.
    </para>
    <itemizedlist>
    <listitem>
      A <emphasis>managed service</emphasis> can be an arbitrary POJO that's managed by the Spring container. 
      Such a Spring bean can be exported as webservice within the Spring configuration file using a special namespace
      (see Configuration section below). 
    </listitem>
    <listitem>
      An <emphasis>unmanaged service</emphasis> consists of a Java interface, which defines all remotely available service methods, and the
      service implementation, implementing this interface and extending the abstract service base class
      <literal>org.pustefixframework.webservices.AbstractService</literal>. Thus the implementation class
      inherits the method <literal>getContextResourceManager()</literal>, which can be used to access
      <literal>ContextResources</literal>. The service has to be declared explicitly in the project's
      central webservice configuration file <filename>projectdir/conf/webservice.conf.xml</filename> (see Configuration section below).
    </listitem>
    </itemizedlist>
    <note>
      <para>
        If you want to use SOAP as service protocol, you have to note that the SOAP runtime used by Pustefix (Sun's JAXWS implementation)
        requires that service classes are annotated with the <literal>javax.jws.WebService</literal> annotation. 
      </para>
    </note>
    <para>
      The Pustefix build process automatically generates Javascript SOAP stubs for all declared services (if the
      SOAP protocol is enabled). It also generates the deployment descriptors needed by Axis, the SOAP/webservices
      library used in Pustefix. Optionally it can create WSDL descriptions for all webservices. The JSON protocol support
      needs no build time processing, cause the stubs can either be dynamic proxies or generated at runtime by the server.
    </para>
    <para>
      Using the services on the client-side is quite easy too. You just have to include the necessary Javascript libraries
      provided by Pustefix and instantiate a service proxy object via Javascript. The service proxy object delegates your
      local method calls to the server, which invokes the according methods on your service implementation and returns the result.
      The remote invocation works completely transparent for the client, just as a local method call.
    </para>
    <para>
      The SOAP proxy is an autogenerated Javascript stub, which uses Pustefix's home-brewed Javascript SOAP implementation
      (as long as the native browser support for SOAP isn't sufficient). JSON provides two different proxy models: a dynamic
      proxy which is set up dynamically at runtime (during its instantiation the service's method list is requested from the
      server and according Javascript methods are created) and a stub which is generated at runtime by the server.
    </para>
    <para>
      The client-server communication is done using the XmlHttpRequest object (supported by most modern browsers). Thus
      service requests can be done either synchronous or asynchronous (passing a callback function as parameter instead of
      getting the result directly from the service method). There's also a fallback mechanism (via hidden iframes) for
      older browsers that do not know a XmlHttpRequest object.
	</para>
    <section xml:id="advanced.ajax.config">
      <title>Service configuration</title>
      <para>
        Spring-managed services are configured as part of the Spring configuration. You can export an arbitrary bean as webservice
        using the <literal>webservice</literal> element (from the <literal>http://pustefixframework.org/schema/webservices</literal> 
        namespace). Therefor you have to reference it using the <literal>ref</literal> attribute and set a unique 
	<literal>servicename</literal>.
      </para>
      <programlisting language="xml"><![CDATA[
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:ws="http://pustefixframework.org/schema/webservices"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
            http://pustefixframework.org/schema/webservices http://pustefixframework.org/schema/webservices/pustefix-webservices.xsd">

  <bean id="MyBeanId" class="mypackage.MyBean" scope="session">
    <aop:scoped-proxy/>
  </bean>
  
  <ws:webservice
    id="Webservice_MyBean" 
    servicename="MyBean" 
    interface="MyBeanServiceInterface"
    ref="MyBeanId" 
  />

  <!-- configuration with optional settings --> 
  <ws:webservice
    id="Another_Webservice"
    servicename="MyService"
    interface="MySeviceInterface"
    ref="AnotherBean"
    protocol="ANY"
    authconstraint="MyConstraint"
    synchronize="false"
    whitelist="mypackage.MyClass otherpackage.*"
  />

</beans>
      ]]></programlisting>
      <para>
        You can optionally set an <literal>interface</literal> which defines the methods which should be exported (by default all
        public methods are exported, if you're using SOAP/JAXWS you can also exclude methods using the <literal>@WebMethod(exclude=true)</literal>
        annotation). Using the <literal>protocol</literal> attribute you can set the webservice protocol (default is <literal>JSONWS</literal>,
        other options are <literal>SOAP</literal> or <literal>ANY</literal>).
      </para>
      <para>
        If you're using class hinting, all permitted classes have to be listed as value of the <literal>whitelist</literal> attribute. You can either directly
        list the full class names (space or comma separated), or you can use regular expressions.
     </para>
      <para>
        The webservice configuration file <filename>PROJECTNAME/conf/webservices.conf.xml</filename> contains global settings
	for the runtime system, default settings for webservices, and optionally webservice-specific settings.
        If you're using Spring-managed services only, you can ignore the webservice-specific settings in this file as they're
        done as part of the Spring configuration. The global and default settings are applied to the managed services too.
      </para>
      <programlisting language="xml"><![CDATA[<webservice-config schemaLocation="http://pustefix.sourceforge.net/wsconfig200401 ../../core/schema/wsconfig200401.xsd"
  xmlns="http://pustefix.sourceforge.net/wsconfig200401"
  xmlns:xsi="xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <!--
    The webservice-global section contains general configuration options, which are applied to
    all webservices. Some of the options can be overridden individually for single webservices.
  -->
  <webservice-global>

    <!--
      Set if WSDL should be generated for SOAP-enabled webservices and where to store it (absolute path within
      the project's webapp directory)
      
      [Optional - Default: enabled="true" repository="/wsdl"]
    -->
    <wsdlsupport enabled="true" repository="/wsdl"/>

    <!--
      Set if Javascript stubs should be generated and where to store it (absolute path within the
      project's webapp directory - only for SOAP). The jsnamespace attribute controls what namespace
      prefix the generated Javascript should use (COMPAT: WS_, COMPAT_UNIQUE: WS_ for SOAP JWS_ for JSON,
      JAVA_NAME: full Java class name, other values are used as namespace themselves, dot-separated
      namespaces are supported too, code to setup the according JS context objects gets auto-generated)
      
      [Optional - Default: enabled="true" repository="/wsscript" jsnamespace="COMPAT"]
    -->
    <stubgeneration enabled="true" repository="/wsscript" jsnamespace="COMPAT"/>

    <!--
      Set which service protocol should be used. You can set a certain protocol (SOAP|JSONWS) or allow all
      protocols (ANY). If you choose to use JSONWS only, you should set the type to JSONWS to accelerate
      the build process, otherwise the SOAP stubs will be generated unnecessarily.
      
      [Optional - Default: type="JSONWS"]
    -->
    <protocol type="ANY"/>

    <!--
      Set which SOAP encoding style should be used. The best supported style is rpc/encoded.
      The server-side also supports other styles like rpc/literal and document/literal, but the client-side
      support for these styles is rudimentary.
      
      [Optional - Default: style="rpc" use="encoded"]
    -->
    <encoding style="rpc" use="encoded"/>

    <!--
      Set if the JSON representation of serialized Java beans should be augmented with
      type meta information (classhinting).
      
      [Optional - Default: classhinting="false"]
    -->
    <json classhinting="true"/>

    <!--
      Set if webservice requests need to have a valid HTTP/Pustefix-Session (servlet) or they should
      work without one too (none).
      
      [Optional - Default: type="servlet"]
    -->
    <session type="servlet"/>

    <!--
      Set the service object's scope. Scope application means that the service object is created only
      once and shared between all sessions, session, that it's created once per session, request, that
      it's created newly for each request.
      
      [Optional - Default: type="application"]
    -->
    <scope type="application"/>

    <!--
      Set if only https requests should be allowed.
      
      [Optional - Default: force="false"]
    -->
    <ssl force="true"/>

    <!--
      Configure if service requests should be synchronized on the Pustefix Context (default is true).
      [Optional - Default: synchronize="true"]
    -->
    <context synchronize="true"/>


    <!--
      There are some options which should be configured differently in development and production mode.
      Therefor you can use the following choose/when elements (which are optional, you can just leave them out).
    -->
    <choose>
      <when test="$mode = 'prod'">
        <!--
          Set if admin tool should be available (see Development Tools).
          
          [Optional - Default: enabled="false"]
        -->
        <admin enabled="false"/>

        <!--
          Set if monitor tool should be available (see Development Tools).
          
          [Optional - Default: enabled="false"]
        -->
        <monitoring enabled="false"/>

        <!--
          Set if extensive logging should be enabled (i.e. logging of all request/response messages in
          pustefix-webservice.log).
          
          [Optional - Default: enabled="false"]
        -->
        <logging enabled="false"/>

        <!--
          Set a FaultHandler, which will process exceptions before they are sent to the client
          (see Exception Handling).
          
          [Optional - Default: none]
        -->
        <faulthandler class="de.schlund.pfixcore.webservice.fault.EmailNotifyingHandler">
          <param name="recipients" value="errors@domain.de"/>
          <param name="sender" value="pfxerror@domain.de"/>
          <param name="smtphost" value="localhost"/>
        </faulthandler>
      </when>
      <otherwise>
        <admin enabled="true"/>
        <monitoring enabled="true" scope="session" historysize="10"/>
        <logging enabled="true"/>
        <faulthandler class="de.schlund.pfixcore.webservice.fault.LoggingHandler"/>
      </otherwise>
    </choose>
  </webservice-global>

  <!--
    Each service has to define name, interface and implementation. All other options are
    optional and inherited from the global section respectively. Some global options
    can be overridden here (stubgeneration, protocol, encoding, json, session, scope,
    ssl, context, faulthandler).
  -->

  <webservice name="Counter">
  
    <!--
      Set the service interface. [Mandatory]
    -->
    <interface name="de.schlund.pfixcore.example.webservices.Counter"/>

    <!--
      Set the service implementation class. [Mandatory]
    -->
    <implementation name="de.schlund.pfixcore.example.webservices.CounterImpl"/>

    <!--
      List which classes are permitted to be deserialized using class hinting
    -->
    <whitelist>mypackage.MyClass otherpackage.*</whitelist>
  </webservice>
  <webservice name="...">...</webservice>...
</webservice-config>]]></programlisting>
    </section>
    <section xml:id="advanced.ajax.exception">
      <title>Exception handling</title>
      <para>
        Pustefix provides a special exception handling mechanism for AJAX services. You can register predefined or
        custom FaultHandlers, which are automatically called before an exception is sent to the client. Thus you
        can filter exceptions, change them or do some logging or notification stuff.
      </para>
      <para>
        There are three predefined FaultHandlers:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <literal>de.schlund.pfixcore.webservice.fault.LoggingHandler</literal>: as its name denotes, it just logs all Exceptions
            via log4j (location can be configured within the general log4j configuration)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>de.schlund.pfixcore.webservice.fault.EmailNotifyingHandler</literal>: this handler sends Email notifications (recipients, sender and smtphost can be configured as parameters, see the Configuration section)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>de.schlund.pfixcore.webservice.fault.ExceptionProcessorAdapter</literal>: this handler implements a direct connection to the general Pustefix exception processing mechanism via ExceptionProcessors (and only makes sense if the configured ExceptionProcessor only consumes exceptions, but doesn't produce any output, like a HTML error page)
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        You are free to implement your own FaultHandler and register it with your services in the webservice configuration file.
        You just have to extend the abstract base class <literal>de.schlund.pfixcore.webservice.fault.FaultHandler</literal> and
        implement the abstract methods <literal>init()</literal> and <literal>handleFault(Fault)</literal>. The Fault object
        methods <literal>getThrowable()</literal> and <literal>setThrowable</literal> can be used to get the thrown exception and
        to change or replace it.
      </para>
      <para>
        You also can derive from one of the predefined handlers. E.g. you can extend the EmailNotifyingHandler by overriding the
        two methods public boolean isInternalServerError(Fault fault) and public boolean isNotificationError(Fault fault) to
        customize if error details should be hidden from the client and if a notification mail should be sent for certain exceptions.
      </para>
    </section>
    <section xml:id="advanced.ajax.tools">
      <title>Development tools</title>
      <para>
        Pustefix provides some tools, which can help you during the development process. It provides an admin and monitoring
        webinterface. The admin tool lists all registered services with their service methods. The monitoring tool shows a history
        of the last requests including the request and response messages.
      </para>
      <para>
        You can access these tools by including the special tag <literal>&lt;pfx:webserviceconsole/&gt;</literal> (see <xref linkend="xslt.consoles"/>)
        into your Pustefix page and enabling them in the global webservice configuration (as shown in the Configuration section:
        the admin and monitoring elements within the choose/when elements).
      </para>
      <para>
        By the way, if any unexplainable problems occur, you're recommended to take a look into the logfile pustefix-webservice.log,
        where (if log4j log level is set to DEBUG) among other things the request and response messages are logged too.
      </para>
    </section>      
    <section xml:id="advanced.ajax.callback">
      <title>Callback mechanisms</title>
      <para>
        Doing asynchronous webservice calls, you can choose between two different webservice callback mechanisms.
      </para>
      <section xml:id="advanced.ajax.callback.function">
        <title>Callback functions</title>
        <para>
          You can pass a function reference as last argument of the service method call (or last but one, if you want
          to set a request ID too). After receiving the server's response your function will be automatically called,
          passing the result (if no exception occurred), the request ID (if set) and an Error object (if exception occurred).
        </para>
        <programlisting><![CDATA[var service=new WS_Service();
var callback=function(result,requestid,exception) {
   if(exception) {
      ...
   } else {
      ...
   }
}
var requestid="...";
service.serviceMethod(arg0, arg1, ... , callback); //asynchronous with callback
service.serviceMethod(arg0, arg1, ... , callback, requestid); //asynchronous with callback and requestid]]></programlisting>
      </section>
      <section xml:id="advanced.ajax.callback.object">
        <title>Callback objects</title>
        <para>
          You can instantiate the webservice stub with an object reference as argument of the constructor function.
          Your object has to provide methods of the same name as the service methods which are automatically called
          back by the stub (you don't have to pass a callback object or function to the serviceMethod).
        </para>
        <programlisting><![CDATA[var object={
   serviceMethod: function(result,requestid,exception) {
      if(exception) {
         ...
      } else {
         ...
      }
   }
};
var service=new WS_Service(object); //instantiate service with callback object 
//optionally you can pass the scope object within 
var requestid="...";
service.serviceMethod(arg0, arg1, ...); //asynchronous
service.serviceMethod(arg0, arg1, ... , requestid); //asynchronous with requestid
]]></programlisting>
      <para>
         If you're using JSON stubs, you can optionally pass a scope object as second constructor argument.
         Thus this scope is used as the "this" context argument instead of the object 
	 itself when the object's callback method is called. <emphasis>[Since: 0.13.1]</emphasis>
      </para>
      <programlisting><![CDATA[
        var service = new WS_Service(object, scope);
]]></programlisting>
      </section>
    </section>
    <section xml:id="advanced.ajax.typemapping">
      <title>Type mapping</title>
      <para>
        Supported Java types are:
      </para>
      <itemizedlist>
        <listitem><simpara>Primitive Java types (boolean, byte, short, int, long, float, double)</simpara></listitem>
        <listitem><simpara>Object wrappers for primitive types (Boolean, Byte, Short, Integer, Long, Float, Double from java.lang)</simpara></listitem>
        <listitem><simpara>String type (java.lang.String)</simpara></listitem>
        <listitem><simpara>Date types (java.util.Calendar, java.util.Date)</simpara></listitem>
        <listitem><simpara>Java beans (nested arbitrarily)</simpara></listitem>
        <listitem><simpara>Arrays of all other supported types (except for java.util.Date with SOAP), including multidimensional arrays</simpara></listitem>
      </itemizedlist>
      <para>
        Primitive, wrapper, String and Date types are mapped to their according Javascript counterpart
        (Number, Boolean, String, Date). Java beans are mapped to general Javascript objects with the according properties
        (there's no representation/simulation of the Java bean's type hierarchy, using JSON you optionally can enable
        classhinting, which provides every object instance with a special property - javaClass - containing the full Java class name).
      </para>
      <para>
        The Java bean mapping mechanism supports both, so-called simple properties (having according getter and setter methods as
        defined in the Java Bean Specification) and public members (without access methods).
      </para>
      <para>
        Additional Java types supported by JSON services:
      </para>
      <itemizedlist>
        <listitem><simpara>Primitive and object wrapper type for characters (char and java.lang.Character)</simpara></listitem>
        <listitem><simpara>Arbitrary Lists (Java -> JSON), parameterized Lists with type parameter of instantiable type (JSON -> Java)</simpara></listitem>
        <listitem><simpara>Arbitrary Maps with keys of type java.lang.String (Java -> JSON), parameterized Maps with key type parameter of type java.lang.String and value type parameter of instantiable type (JSON -> Java)</simpara></listitem>
      </itemizedlist>
      <para>
        Because of the restrictions of the JSON format, especially the absence of type information and the usage of
        builtin Javascript types (arrays for Lists, objects for Maps), the support for Lists and Maps itself is restricted:
        deserializing Lists to Java requires a parameterized type parameter and this type has to be instantiable
        (or be a parameterized List or Map itself), the same with Map values, Map keys have to be java.lang.String instances.
      </para>
      <section>
        <title>Custom bean mapping via Java annotations</title>
        <para>
          The JSON bean (de-)serialization mechanism supports customizable bean property mappings via Java annotations.
          You can exclude individual properties from (de-)serialization by marking the according getter with an <literal>@Exclude</literal>
          annotation or you can exclude all properties by marking the bean class with an <literal>@ExcludeByDefault</literal>
          annotation and include individual properties with @Include annotations at their getters (marking public members is
          supported too).
        </para>
        <para>
          The following examples show the different annotations in action. Both class definitions give access to the foo and
          baz property and restrict access to the bar property. The first class definition includes all properties by default
          (which is the default behaviour without a type annotation) and excludes the bar property, while the second excludes
          all properties by default and includes the foo and baz properties:
        </para>
        <programlisting><![CDATA[public class A {

    int foo;
    int bar;
    int baz;

    public int getFoo() {return foo;}
    public void setFoo(int foo) {this.foo=foo;}

    @Exclude
    public int getBar() {return bar;}
    public void setBar(int bar) {this.bar=bar;}

    public int getBaz() {return baz;}
    public void setBaz(int baz) {this.baz=baz;}

}]]></programlisting>
        <programlisting><![CDATA[@ExcludeByDefault
public class A {

    int foo;
    int bar;
    int baz;

    @Include
    public int getFoo() {return foo;}
    public void setFoo(int foo) {this.foo=foo;}

    public int getBar() {return bar;}
    public void setBar(int bar) {this.bar=bar;}

    @Include
    public int getBaz() {return baz;}
    public void setBaz(int baz) {this.baz=baz;}                                                                                                           }

}]]></programlisting>
        <para>
          All annotations only take effect in the declaring class and aren't inherited. Thus, if you derive your bean
          class, the type annotation of your base class has no effect, so declaring new properties in your class will
          include them by default. Properties included or excluded in your base class will be included/excluded in your
          inherited class too, if you don't redeclare or override this properties. The following example demonstrates this behaviour:
        </para>
        <programlisting><![CDATA[public class A {

    int foo;
    int bar;
    int baz;

    public int getFoo() {return foo;}
    public void setFoo(int foo) {this.foo=foo;}

    @Exclude
    public int getBar() {return bar;}
    public void setBar(int bar) {this.bar=bar;}

    public int getBaz() {return baz;}
    public void setBaz(int baz) {this.baz=baz;}
}

@ExcludeByDefault
public class B extends A {

    int hey;
    int ho;

    @Include
    public int getHey() {return hey;}
    public void setHey(int hey) {this.hey=hey;}

    public int getHo() {return ho;}
    public void setHo(int ho) {this.ho=ho;}

    @Override
    public int getBaz() {return super.getBaz();}

}]]></programlisting>
        <para>
          Using the @Alias annotation you can control the name used for (de-)serialization (i.e. the name used as
          JSON property name). The following example shows how to add aliases to a public member and a property getter.
        </para>
        <programlisting><![CDATA[public class A {

    @Alias("mybaz")
    public int baz;
    int foo;

    @Alias("myfoo")
    public int getFoo() {return foo;}
    public void setFoo(int foo) {this.foo=foo;}

}]]></programlisting>
        <para>
          If you don't like Java annotations or you want to overwrite existing annotations, you can also customize
          your beans using a XML configuration file. The file has to be named beanmetadata.xml and has to be placed
          in the project configuration directory or in a META-INF directory that's part of the classpath.
        </para>
        <programlisting language="xml"><![CDATA[<bean-metadata xsi:schemaLocation="http://pustefix.sourceforge.net/bean-metadata http://pustefix.sourceforge.net/beanmetadata.xsd">
  <bean class="de.schlund.pfixcore.webservice.beans.A">
    <property name="foo" alias="myfoo"/>
    <property name="bar" exclude="true"/>
  </bean>
  <bean class="de.schlund.pfixcore.webservice.beans.B" exclude-by-default="true">
    <property name="hey"/>
  </bean>
</bean-metadata>]]></programlisting>
       <para>
         The format is very simple: Create a bean element referencing the class you want to annotate. Add property
         elements referencing the properties you want to annotate. All Java annotations have an according XML attribute
         counterpart you can add to these elements.      
       </para>
       </section>
    </section>
  </section>

  <section xml:id="advanced.object2xml">
    <title>Object-to-XML mapping</title>
	<para>
	  Pustefix provides a lightweight object serialization mechanism, which can be used to 
	  serialize arbitrary objects into the result DOM without having to do any DOM operations by 
	  yourself. The XML binding is customizable via Java annotations within the bean classes.
	</para>
	<para>
	  The framework supports arbitrary <literal>Beans</literal>, <literal>Arrays</literal>, 
	  <literal>Collections</literal>, <literal>Maps</literal>, <literal>Numbers</literal> (including
	  the primitive types and their object wrapper types), <literal>Strings</literal>, 
	  and <literal>Date/Calendar</literal>. To support other types or to serialize
	  to a custom format, it's possible to write your own serializers and annotations (to attach
	  them to the according bean properties). 
	</para>
	<para>
	  The serialization of beans can be customized using the generic Pustefix bean annotations,
	  which are known from the JSON serialization framework. You can exclude individual properties 
	  from serialization by marking the according getter with an <literal>@Exclude</literal> 
	  annotation or you can exclude all properties by marking the bean class with an 
	  <literal>@ExcludeByDefault</literal> annotation and include individual properties with
	  <literal>@Include</literal> annotations at their getters (marking public members is supported 
	  too). Using the <literal>@Alias</literal> annotation you can control 
	  the name used as the resulting attribute or element name.
	</para>
	<para>
	  The serialization to the result tree is done by calling one of the static <literal>addObject</literal>
	  methods of the <literal>ResultDocument</literal> class. The <literal>element</literal> 
	  argument is the parent DOM element at which the serialized XML will be appended, the optional <literal>name</literal>
	  argument can be used to create an additional child element for the serialized XML. The
	  <literal>object</literal> argument is the object, which should be serialized.
	</para>
    <programlisting language="java"><![CDATA[public class ResultDocument {
    ...
    public static Element addObject(Element element, Object object) {...}
    public static Element addObject(Element element, String name, Object object) {...}
}]]></programlisting>
	
	<section xml:id="advanced.object2xml.serializationprocess">
      <title>Serialization process</title>
      <para>
	    The default serialization process tries to produce relatively compact XML. Thus it favours
	    attributes over elements and serializes so-called simple types, which can be represented
	    as strings, into attributes where it's possible and makes sense, e.g. for bean properties.
	  </para>
	  <para>
	    Let's look at an example, which shows the serialization of a simple bean using 
	    bean and serializer annotations to customize the serialization behaviour:
	  </para>
	  <programlisting language="java"><![CDATA[...
	  
public class Account {
  
    private long accountNo;
    private float debit;
    ...
  
    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }
  
    @Alias("balance")
    public float getDebit() {
        return debit;
    }
  
    public void setDebit(float debit) {
        this.debit = debit;
    }
  
    public Currency getCurrency() {
        return currency;
    }
  
    public void setCurrency(Currency currency) {
        this.currency = currency;
    }
  
    @DateSerializer("yyyy-MM-dd HH:mm:ss")
    public Calendar getOpeningDate() {
        return openingDate;
    }
  
    public void setOpeningDate(Calendar openingDate) {
        this.openingDate = openingDate;
    }
  
    @Exclude
    public String getComment() {
        return comment;
    }
  
    public void setComment(String comment) {
        this.comment = comment;
    }
}]]></programlisting>
      <para>
  	    Here you see how the bean's serialized to the <literal>ResultDocument</literal> within 
  	    a <literal>ContextResource</literal>:
  	  </para>
      <programlisting language="java"><![CDATA[...
        
public class ContextAccountImpl implements ContextAccount {

    private Account account;
    ...

    public void insertStatus(ResultDocument resdoc, Element elem) throws Exception {
        ResultDocument.addObject(elem,"account",account);
    }    
}]]></programlisting>
      <para>
        The resulting DOM fragment looks like this:
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199439160721">
  ...
  <data>
    <account accountNo="2000123" currency="EUR" balance="332.54" openingDate="2003-11-04 09:15:38"/>
  </data>
  ...
</formresult>]]></programlisting>
      <para>
        The <literal>data</literal> element is the ContextResource's root node as configured
        in the configuration file. Calling <literal>addObject</literal> with the additional
        <literal>account</literal> argument, the serialized bean isn't added directly to the
        data element, but an additional element is used. The bean's properties are serialized
        as attributes of this element.
      </para>
      <para>
        The <literal>debit</literal> property is renamed to <literal>balance</literal> using
        the <literal>@Alias</literal> annotation. The <literal>comment</literal> property is
        excluded using the <literal>@Exclude</literal> annotation. The <literal>openingDate</literal>
        property is serialized using the built-in <literal>DateSerializer</literal>, which can
        be customized using the <literal>@DateSerializer</literal> annotation. Thus you can
        provide your own date format pattern (must be a pattern supported by
        <literal>java.text.SimpleDateFormat</literal>).
      </para>
      <para>
        Only simple type properties, i.e. properties which can be serialized to string values, can
        be represented as attributes. If the <literal>Account</literal> bean would have an additional
        property <literal>customer</literal> of a bean type, e.g. a <literal>Customer</literal> class, 
        this property would be serialized as a child element:  
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199439160721">
  ...
  <data>
    <account accountNo="2000123" balance="EUR" debit="332.54" openingDate="2003-11-04 09:15:38">
      <customer customerId="100000" firstName="Mike" lastName="Foo"/>
    </account>
  </data>
  ...
</formresult>]]></programlisting>
      <para>
        <literal>Collections</literal> and <literal>Arrays</literal> are represented using
        an element for each entry. The element name is derived from the the simple name
        of the entry's class (without package name and starting lowercase):
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199439160721">
  ...
  <data>
    <account accountNo="2000000" currency="EUR" balance="3124.49" openingDate="2003-10-23 08:05:10"/>
    <account accountNo="2000123" currency="EUR" balance="332.54" openingDate="2003-11-04 09:15:38"/>
    <account accountNo="2001405" currency="EUR" balance="25123.11" openingDate="2005-01-13 10:10:10"/>
  </data>
  ...
</formresult>]]></programlisting>
      <para>
        The element name can be changed using the <literal>@ClassNameAlias</literal> annotation, e.g.
        to rename the <literal>account</literal> element to <literal>bankaccount</literal>:
      </para>
      <programlisting language="java"><![CDATA[@ClassNameAlias("bankaccount")
public class Account {
    ...
}]]></programlisting>
      <para>
        <literal>Maps</literal> are represented using an <literal>entry</literal> element for each
        map entry. Key and value are represented by child elements (whereas the element names are
        derived from the class names):
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199439160721">
  ...
  <data>
    <entry>
      <long>2000000</long>
      <account accountNo="2000000" currency="EUR" debit="3124.49" openingDate="2003-10-23 08:05:34"/>
    </entry>
    <entry>
      <key>2001405</key>
      <account accountNo="2001405" currency="EUR" debit="25123.11" openingDate="2005-01-13 10:10:34"/>
    </entry>
    <entry>
      <key>2000123</key>
      <account accountNo="2000123" currency="EUR" debit="332.54" openingDate="2003-11-04 09:15:34"/>
    </entry>
  </data>
  ...
</formresult>]]></programlisting>
      <tip>
        <title>Changing the tag name for map entries</title>
        <para>
          The tag name, that is used for the entries in the map can be changed using the
          <literal>@MapSerializer</literal> (see <xref linkend="advanced.object2xml.advanced.object2xml.builtinserializers.map"/>).
        </para>
      </tip>
      <para>
        Circular object references are handled by adding a <literal>xpathref</literal> attribute to
        the according element. Its value is an absolute XPath expression referencing the according
        object's element:
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199702214819">
  ...
  <data>
    <account accountNo="2000123">
      <customer customerId="100000">
        <accounts>
          <account accountNo="2000000">
            <customer xpathref="/formresult/data[1]/account[1]/customer[1]"/>
          </account>
          <account xpathref="/formresult/data[1]/account[1]"/>
          <account accountNo="2001405">
            <customer xpathref="/formresult/data[1]/account[1]/customer[1]"/>
          </account>
        </accounts>
      </customer>
    </account>
  </data>
  ...
</formresult>]]></programlisting>
      <para>
        In this example the <literal>Account</literal> bean has a reference to a <literal>Customer</literal>
        bean, which itself has a reference to all of its <literal>Accounts</literal>. You can see that all
        beans, which were already serialized (as ancestors in the tree) contain an according back-reference.
      </para>
    </section>

    <section xml:id="advanced.object2xml.builtinserializers">
      <title>Built-in serializers</title>  
      <para>
        Pustefix already provides several XML serializers for common serialization tasks.
      </para>
      <section xml:id="advanced.object2xml.builtinserializers.simple">
        <title>Simple serializers</title>  
        <para>
          Simple serializers serialize scalar values (like strings, numbers or booleans). They
          are added as a new attribute on the current tag.
        </para>

        <section xml:id="advanced.object2xml.advanced.object2xml.builtinserializers.simple.date">
          <title>@DateSerializer</title>
          <para>
            The <literal>@DateSerializer</literal> is used to select the date format when serializing
            <literal>Date</literal> or <literal>Calendar</literal> objects.
          </para>
        </section>
      </section>
      
      <section xml:id="advanced.object2xml.builtinserializers.complex">
        <title>Complex serializers</title>  
        <para>
          Complex serializers are used to serialize complex data structures. These always
          result in new tags that are being added to the document.
        </para>

        <section xml:id="advanced.object2xml.advanced.object2xml.builtinserializers.complex.forceelement">
          <title>@ForceElementSerializer</title>
          <para>
            The <literal>@ForceElementSerializer</literal> will create an XML tag for primitive
            values instead of writing the value to an XML attribute.
          </para>
          <para>
            It can be combined with any simple type serializer (see <xref linkend="advanced.object2xml.builtinserializers.simple"/>.
          </para>
        </section>
        
        <section xml:id="advanced.object2xml.advanced.object2xml.builtinserializers.cdata">
          <title>@CDataSerializer</title>
          <para>
            The <literal>@CDataSerializer</literal> will create a CData section in the resulting 
            XML document.
          </para>
        </section>

        <section xml:id="advanced.object2xml.advanced.object2xml.builtinserializers.map">
          <title>@MapSerializer</title>
          <para>
            The <literal>@MapSerializer</literal> is used to serialize instances of <literal>java.util.Map</literal>.
          </para>
        </section>
        
        <section xml:id="advanced.object2xml.advanced.object2xml.builtinserializers.complex.xmlfragment">
          <title>@XMLFragmentSerializer</title>
          <para>
            Strings that contain XML code can be inserted as XML fragment the the resulting document by using
            the <literal>@XMLFragmentSerializer</literal>:
          </para>
          <programlisting language="java"><![CDATA[public class FragmentBean {
      
    private String myFragment = "<foo><bar baz=\"true\"/>character data</foo>";

    @XMLFragmentSerializer
    public String getMyFragment() {
        return myFragment;
    }
}]]></programlisting>
          <para>
            The XML, that is returned by the <literal>getMyFragment</literal> method is not treated
            as a simple string, but as an XML fragment and thus, the content is not escaped, when
            inserted in the document:
          </para>
          <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<result>
  <myFragment>
    <foo><bar baz="true"/>character data</foo>
  </myFragment>
</result>]]></programlisting>
        </section>
      </section>
    </section>
    
    <section xml:id="advanced.object2xml.customserializers">
      <title>Custom serializers</title>
      
      <para>
        If you don't like the default serialization mechanism or you use unsupported types, you can
        write your own serializers. There are two types of serializers: <literal>SimpleTypeSerializers</literal>, 
        which can produce <literal>String</literal> values (e.g. for primitive types), 
        and <literal>ComplexTypeSerializers</literal>, which can produce structured XML data
        (e.g. for bean types). 
      </para>
      <para>
        Implementing your own serializer just requires to implement the <literal>SimpleTypeSerializer</literal>
        or <literal>ComplexTypeSerializer</literal> interface and create a custom annotation to be able
        to attach your serializer to a bean property.
      </para>
      <para>
        Let's look at an example of a <literal>SimpleTypeSerializer</literal>: 
        a custom <literal>String</literal> serializer, which allows to configure if 
        <literal>Strings</literal> should be ouput lower- or uppercase. Here's the implementation:
      </para>
      <programlisting language="java"><![CDATA[...
import de.schlund.pfixcore.oxm.impl.AnnotationAware;
import de.schlund.pfixcore.oxm.impl.SimpleTypeSerializer;
import de.schlund.pfixcore.oxm.impl.annotation.StringSerializer;
...

public class StringTypeSerializer implements SimpleTypeSerializer, AnnotationAware {

    private boolean doLowerCase;

    public void setAnnotation(Annotation annotation) {
        StringSerializer s=(StringSerializer)annotation;
        doLowerCase=s.value();
    }

    public String serialize(Object obj, SerializationContext context) throws SerializationException {
        if(obj instanceof String) {
          String str=(String)obj;
          if(doLowerCase) str=str.toLowerCase();
          else str=str.toUpperCase();
          return str;
        } 
        throw new SerializationException("Illegal type: "+obj.getClass().getName());
    }
}]]></programlisting>
      <para>
        The serializer implements the <literal>SimpleTypeSerializer</literal> interface.
        Its <literal>serialize</literal> method checks if the passed object is of type <literal>String</literal>
        and calls <literal>toLowerCase</literal> or <literal>toUpperCase</literal> before returning
        the new <literal>String</literal>. The <literal>doLowerCase</literal> property controls which method is used.
        This property is set within the <literal>setAnnotation</literal> method. The method is defined
        in the <literal>AnnotationAware</literal> interface. This method is called by the framework
        after the serializer is instantiated and passes the annotation set at the according bean
        property. So you can access the configured values and configure your serializer.
        Let's look at the according annotation definition:
      </para>
      <programlisting language="java"><![CDATA[...
        
@SimpleTypeSerializerClass(StringTypeSerializer.class)
@Target({ElementType.METHOD,ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface StringSerializer {
    boolean value();
}]]></programlisting>
      <para>
        You have to annotate the custom annotation with a <literal>SimpleTypeSerializerClass</literal>
        annotation with the serializer class as value, make the annotation available to
        methods and fields using the <literal>@Target</literal> annotation and make it visible
        at runtime using the <literal>@Retention</literal> annotation. The rest of the annotation
        definition can be done according to your needs. In the example we just define a boolean
        property indicating if the <literal>String</literal> should be converted to lower- or uppercase. Here you
        see how the annotation is applied to serialize a customer's lastname as uppercase:
      </para>
      <programlisting language="java"><![CDATA[public class Customer {
    ...
    @StringSerializer(false)
    public String getLastName() {...}
}]]></programlisting>
      <para>
        Let's look at an example of a <literal>ComplexTypeSerializer</literal>. We want to customize
        the serialization of a <literal>Customer</literal> bean: the <literal>firstName</literal> and
        <literal>lastName</literal> properties should be output together within a <literal>name</literal>
        element:
      </para>
      <programlisting language="java"><![CDATA[public class Customer {
    ...
    public long getCustomerId() {...}
    public String getFirsstName() {...}
    public String getLastName() {...}
    public List<Account> getAccounts() {...}
    ...
}]]></programlisting>
      <para>
        The serializer just implements <literal>ComplexTypeSerializer</literal>. We don't need to
        implement <literal>AnnotationAware</literal> because our annotation will have no parameter
        we may want to read:
      </para>
      <programlisting language="java"><![CDATA[public class CustomerTypeSerializer implements ComplexTypeSerializer {

    public void serialize(Object obj, SerializationContext context, XMLWriter writer) throws SerializationException {
        if(obj instanceof Customer) {
            Customer customer=(Customer)obj;
            writer.writeStartElement("name");
            writer.writeCharacters(customer.getFirstName()+" "+customer.getLastName());
            writer.writeEndElement("name");
            context.serialize(customer.getAccounts(),writer);
        } else {
            throw new SerializationException("Illegal type: "+obj.getClass().getName());
        }
    }
}]]></programlisting>
      <para>
        The <literal>serialize</literal> method gets a <literal>XMLWriter</literal> object, which
        is used to write the <literal>name</literal> element. Then the passed <literal>SerializationContext</literal>
        is used to serialize the customer's accounts using the default serialization mechanism.
      </para>
      <para>
        Finally we implement a custom annotation:
      </para>
      <programlisting language="java"><![CDATA[@ComplexTypeSerializerClass(de.schlund.pfixcore.example.bank.oxm.CustomerTypeSerializer.class)
@Target({ElementType.METHOD,ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomerSerializer {}]]></programlisting>
      <para>
        Here we apply the annotation to the <literal>Account</literal> bean's 
        <literal>customer</literal> property:
      </para>
      <programlisting language="java"><![CDATA[public class Account {
    ...
    @CustomerSerializer
    public Customer getCustomer() {...}
    ...
}]]></programlisting>
      <para>
        Here's an excerpt of the resulting XML:
      </para>
      <programlisting language="xml"><![CDATA[<formresult serial="1199705488403">
  ...
  <data>
    <account accountNo="2000000" balance="3124.49" currency="EUR" openingDate="2003-10-23 08:05:22">
      <customer>
        <name>Mike Foo</name>
        <account accountNo="..."/>
        <account accountNo="..."/>
        ...
      </customer>
    </account>
  </data>
  ...
</formresult>]]></programlisting>
    </section>
    <section xml:id="advanced.object2xml.jaxb">
      <title>Using JAXB serialization</title>
      <para>As an alternative to the builtin XML marshalling you can use JAXB. Pustefix checks if the class definition of an object is annotated with the JAXB annotation 
            <literal>javax.xml.bind.annotation.XmlRootElement</literal> and, if so, hands over the serialization to JAXB.
      </para>
	  <programlisting language="java"><![CDATA[...
	 
@XmlRootElement 
public class Account {
  
    private long accountNo;
  
    @XmlAttribute
    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    ...

}]]></programlisting>
    </section>
  </section>
  
  <section xml:id="advanced.iwrapperannotations">
    <title>Annotation-based IWrapper creation</title>
    <para>
      The annotation-based IWrapper creation provides an alternative to the usual,
      XML configuration based, IWrapper creation. Using this approach you create IWrappers
      from standard Java Beans by adding the necessary configuration data in the form
      of annotations.
    </para>
    <para>
      The IWrappers are automatically created during the build process using the Sun JVM's <literal>apt</literal>
      tool and a custom <literal>AnnotationProcessor</literal> which analyzes the Java bean's
      source code and generates the according IWrapper sources.
    </para>
    <para>
      You're making a bean to a template for an <literal>IWrapper</literal> by adding an 
      <literal>@IWrapper</literal> annotation to its class declaration. By default every 
      bean property that is of a so-called builtin type, i.e. has a pre-defined 
      <literal>IWrapperParamCaster</literal> implementation, will be automatically added
      as an IWrapper parameter.
    </para>
    <para>
      Builtin types are <literal>boolean, byte, double, float, int, long,
      java.lang.Boolean, java.lang.Byte, java.lang.Double, java.lang.Float, java.lang.Integer, 
      java.lang.Long, java.lang.String, java.util.Date</literal> and <literal>Arrays</literal>
      with components of these types.
    </para>
    <para>
      Bean properties of an unknown type are either ignored or require a <literal>@Caster</literal>
      annotation specifying an appropriate caster. Bean properties can be annotated at their
      getter methods or at the field itself, if it's public. If a property of a builtin type should
      be skipped you can mark the according property with a <literal>@Transient</literal> annotation.
    </para>
    <para>
      Bean based IWrappers can be used to create new beans or fill existing beans with
      the IWrapper's state. Therefore the <literal>IWrapperToBean</literal> class provides
      the two static methods <literal>&lt;T&gt; T createBean(IWrapper wrapper, Class&lt;T&gt; beanClass)</literal>
      and <literal>populateBean(IWrapper wrapper, Object obj)</literal>.
    </para>
    <section xml:id="advanced.iwrapperannotations.reference">
      <title>IWrapper annotations</title>
      <para>
        Every IWrapper configuration element known from the XML configuration has an annotation
        counterpart. Besides there are some special annotations like <literal>@IWrapper</literal>
        and <literal>@Transient</literal>. In the following we'll give a short overview of
        all avaible annotations:
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target(ElementType.TYPE)
        @Retention(RetentionPolicy.RUNTIME)
        public @interface IWrapper {
          String name() default "";
          Class<? extends IHandler> ihandler() default IHandler.class;
          String beanRef() default "";
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@IWrapper</literal> annotation is used to mark a class as template for
        an IWrapper. The <literal>name</literal> attribute denotes the class name of the
        generated IWrapper class (without package). By default the bean name with the
        suffix <literal>Wrapper</literal> is used (and the same package). The <literal>ihandler</literal>
        attribute denotes the <literal>IHandler</literal> implementation class. Alternatively you can
        use the <literal>beanRef</literal> attribute to reference a Spring managed IHandler bean by name.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Param {
          String name() default "";
          boolean mandatory() default true;
          boolean trim() default true;
          String missingscode() default "";
          String[] defaults() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Param(name="MyValue",mandatory=false)
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Param</literal> annotation is used to mark a bean property as parameter
        and configure its <literal>name</literal> and all the other options known from the
        IWrapper XML configuration. This annotation is optional, leaving it out, the property name
        is used as name and the other attributes are set to their default values.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Caster {
          Class<? extends IWrapperParamCaster> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Caster(type=SomeClassCaster.class)
          public SomeClass getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Caster</literal> annotation denotes the caster implementation class.
        The nested <literal>properties</literal> attribute can be used to set properties via
        <literal>@Property</literal> annotations. That's the same as the <literal>cparam</literal>
        elements in the XML configuration (the params/properties are set using according methods
        prefixed with <literal>put_</literal>).
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Property {
          String name();
          String value();
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Property</literal> annotation is used as nested annotation within
        the <literal>properties</literal> array attribute of various annotations. It consists
        of simple <literal>name/value</literal> pairs. 
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface PreCheck {
          Class<? extends IWrapperParamPreCheck> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @PreCheck(
            type=de.schlund.pfixcore.generator.prechecks.RegexpCheck.class,
            properties={
              @Property(name="regexp",value="/^(M|L|XL)$/")
            }
          )
          public String getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@PreCheck</literal> annotation denotes the precheck implementation class
        with optional properties/parameters.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface PostCheck {
          Class<? extends IWrapperParamPostCheck> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @PostCheck(
            type=de.schlund.pfixcore.generator.postchecks.IntegerRange.class,
            properties={
              @Property(name="range",value="0:2")
            }
          )
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@PostCheck</literal> annotation denotes the postcheck implementation class
        with optional properties/parameters.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Transient {}
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Transient
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Transient</literal> annotation can be used to avoid that a bean property
        of a builtin type is made to an IWrapper parameter.
      </para>
    
    </section>
    
  </section>

  <section xml:id="advanced.scriptedflows">
    <title>Scripted workflows</title>
    <para>
      Scripted flows are script files written in XML that can be used to control a
      user session. The script file has the following form:
    </para>
    <programlisting language="xml"><![CDATA[<scriptedflow version="1.0"
  xmlns="http://pustefix.oss.schlund.de/scriptedflow200602">
  <!--
    The instructions are placed here.
  -->
  </scriptedflow>]]></programlisting>
    <section>
      <title>Parameters and Variables</title>
      <para>
        A scripted flow is started by using the special __scriptedflow=[FLOWNAME] parameter
        in the query string of a request URI. In this query string additonal parameters
        can be given which are then made available inside the script.
      </para>
      <section>
        <title>Variables</title>
        <para>
          Variables can be used to store character data between steps within a scripted flow.
          A variable is set using the &lt;set-variable name="variablename"&gt;content&lt;/set-variable&gt;
          command. The content may consist of character data as well as the special
          &lt;value-of select="&lt;XPath-Expression&gt;"/&gt; command. Within XPath expressions
          variables can be referenced using $variablename.
        </para>
      </section>
      <section>
        <title>Parameters</title>
        <para>
          Parameters are set when a scripted flow is started. If the query string contains e.g.
          &quot;name=value&quot; the value can be accessed from within XPath expressions using
          the special variable name $__param_name$. Parameters can not be overwritten from
          within the script and never change during the execution.
        </para>
      </section>
      <section>
        <title>Special variables</title>
        <para>
          There is a special variable called $__pagename$ which contains the name of the page
          that would have been sent to the browser, if the last request was done directly by
          the browser. You can use this variable to check on which page you are at the moment.
          This variable cannot be written to by the script.
        </para>
      </section>
    </section>
    <section>
      <title>Statements</title>
      <para>
        Scripted Flows are programmed using assorted statements which are explained here:
      </para>
      <section>
        <title>&lt;interactive-request&gt;</title>
        <para>
          Gives control back to the user. The output page is rendered based on the current
          ResultDocument (which was generated by the last request) and sent to the browser.
          When the browser sends the next request (e.g. by sending a form or clicking on a
          link) it is processed as usual but instead of returning the resulting document
          directly to the browser the active scripted flow is continued right at the location
          it was suspended, using the new ResultDocument as the base for further processing.
        </para>
        <programlisting language="xml"><![CDATA[<interactive-request>
  <param name="thename">static text combined with <value-of select="$thevar"/> calculated text (if needed)</param>
  <param name="otherparam">other text</param>
</interactive-request>]]></programlisting>
        <para>
          This statement can take an arbitrary number of param tags as children. These tags
          can be used to provide values to pre-fill html form input elements.
        </para>
      </section>
      <section>
        <title>&lt;virtual-request&gt;</title>
        <para>
          Triggers a virtual request which is processed by the context like a user request.
          This statement can have an optional attribute page which specifies the name of the
          page the request should be sent to. If omitted, the current page (as defined by the
          Context) is used. This statement can take an arbitrary number of param tags below
          itself. These tags can be used to provide arguments to the request (e.g. to simulate
          submitted form data). The tag follows the scheme:
        </para>
        <programlisting language="xml"><![CDATA[<virtual-request page="thepage" dointeractive="false|true|reuse">
  <param name="thename">static text combined with <value-of select="$thevar"/> calculated text (if needed)</param>
  <param name="otherparam">other text</param>
</virtual-request>]]></programlisting>
        <para>
          The <literal>dointeractive</literal> attribute is used in case the virtual request
          returns an error. If set to <literal>"true"</literal> or <literal>"reuse"</literal>,
          the system will automatically fall back to do an interactive request (the
          default is <literal>"false"</literal> which will just go on with the scripted flow
          ignoring any errors). All errors will be cleared from the document used in the
          interactive request. The difference between <literal>"true"</literal> and
          <literal>"reuse"</literal> is that in the latter case, the param tags given to the
          virtual request will be reused in the automatic interactive request, providing for
          pre-filled input fields.
        </para>
        <para>
          Please note that the <literal>__sendingdata</literal> or <literal>__sendingauthdata</literal>
          parameter will not be added automatically but has to be added by the script developer,
          if needed. The ResultDocument returned by this request is used as the basis for
          further processing (e.g. XPath testing).
        </para>
      </section>
      <section>
        <title>&lt;set-variable&gt;</title>
        <para>
          Sets the value of a variable. As the param tag within the virtual-request tag this
          tag can contain text data combined with the value-of tag. See Parameters &amp; Variables
          for details on how to use variables.
        </para>
      </section>
      <section>
        <title>&lt;if&gt;</title>
        <para>
          Allows conditional execution of a code block. Based on a XPath expression which
          is given using the test attribute the VM decides whether to execute the statements
          given below the <literal>&lt;if&gt;</literal> tag or not. The XPath expression can
          test for variables and parameters as well as querying the ResultDocument returned
          by the last request.
        </para>
      </section>
      <section>
        <title>&lt;choose&gt;</title>
        <para>
          This is the multi-branch equivalent to <literal>&lt;if&gt;</literal>. The form is
        </para>
        <programlisting language="xml"><![CDATA[<choose>
  <when test="...">
    <!-- ... -->
  </when>
  <when test="...">
    <!-- ... -->
  </when>
  <otherwise>
    <!-- ... -->
  </otherwise>
</choose>]]></programlisting>
        <para>
          The <literal>&lt;otherwise&gt;</literal> branch is optional and only executed if
          none of the <literal>&lt;when&gt;</literal> conditions is met. Only the first
          <literal>&lt;when&gt;</literal> branch whose condition is met is executed,
          branches following this branch are not evaluated regardless of their condition.
        </para>
      </section>
      <section>
        <title>&lt;while&gt;</title>
        <para>
          Loops as long as condition is true. Like the <literal>&lt;if&gt;</literal> statement
          this one takes a test attribute specifying a XPath expression. When the condition is
          true, the code block below this tag is executed, otherwise the next statement after
          the <literal>&lt;while&gt;</literal> statement is executed. After executing the block
          the condition is rechecked, so the block is executed repeatedly until the condition
          becomes false.
        </para>
      </section>
      <section>
        <title>&lt;break&gt;</title>
        <para>
          Jumps out of a <literal>&lt;while&gt;</literal> loop. This statement is allowed
          anywhere below a <literal>&lt;while&gt;</literal> statement. It can be used to quit
          the loop immediately and to go on with the next statement after the loop.
        </para>
      </section>
      <section>
        <title>&lt;exit&gt;</title>
        <para>
          Quits the current scripted flow, returning the current ResultDocument to the browser.
        </para>
      </section>
    </section>
  </section>

  <section xml:id="advanced.scripting">
    <title>Scripting Langauge support</title>
    <para>
      Consider these questions:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>Do you miss fast-prototyping in Pustefix?</simpara>
      </listitem>
      <listitem>
        <simpara>Do you think dynamic programming languages (sometimes called scripting languages) can do more than just interpreting one liners or providing a new form of poetry?</simpara>
      </listitem>
    </itemizedlist>
    <para>
      If you answered any of the questions above with yes ... Then this is for you!
    </para>
    <para>
      This feature brings scripting support to IHandlers and States. It's possible to develop
      any of them in any Bean Scripting Framework supported language, by providing a script
      file's location inside any IWrapper definition file or inside a pagerequest's definition.
      Script files can be located in either the application's docroot or the classpath.
    </para>
    <section>
      <title>IHandler</title>
      <para>
        Instead of providing a class name inside an IWrapper's IHander definition like this:
      </para>
      <programlisting language="xml"><![CDATA[<ihandler class="de.schlund.pfixcore.example.TShirtHandler"/>]]></programlisting>
      <para>
        you can define that a file containing dynamic language code should be used as an
        IHandler. It's done like this:
      </para>
      <programlisting language="xml"><![CDATA[<ihandler class="script:sample1/script/ScriptingTShirt.js"/>]]></programlisting>
      <para>
        ... that's it! (see below under "Path Definitions" on details about difference between
        scripts under docroot and scripts placed in classpath).
      </para>
      <para>
        Simply create a file containing the dynamic language code inside the docroot or the classpath.
      </para>
    </section>
    <section>
      <title>State</title>
      <para>
        If you want to script a State, then simply use the above definition format inside a
        pagerequest's state definition, like in the following example:
      </para>
      <programlisting language="xml"><![CDATA[<pagerequest name="scriptingstate">
  <state class="script:sample1/script/ScriptingState?.bsh"/>
</pagerequest>]]></programlisting>
    </section>
    <section>
      <title>Implementation Details</title>
      <para>
        The following rules have to be considered, when scripting IHandlers and States alike.
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            You must define all methods of the respective interfaces
            (<literal>de.schlund.pfixcore.generator.IHandler</literal> and/or
            <literal>de.schlund.pfixcore.workflow.State</literal>)
            as functions inside your scripts.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            The functions inside your scripts have to return the correct type, if they
            return values at all. Note that for example en empty String is a valid boolean
            expression in Javascript.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            The file suffix must be one that's recognized by BSF. The listing of current
            supported language mappings of BSF helps you find the correct suffix for your
            used scripting lanuage. Basically they're the common suffixes like js for
            javascript, bsh for Beanshell and py for python.
          </simpara>
        </listitem>
      </itemizedlist>
      <section>
        <title>State</title>
        <para>
          Because the StateFactory caches and reuses State-instances across sessions and
          requests, you should be aware that script-wide global variables inside your
          scripts will be available to all requests and session.
        </para>
        <para>
          This is basically the same behaviour as for States implemented in Java.
        </para>
      </section>
      <section>
        <title>Path Definitions</title>
        <para>
          There are two alternatives for defining the location of your script file.
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              If you prepend a <literal>/</literal> (slash character) to the location,
              the script file is searched for in the classpath of your application.
              No magic (or great effort) is applied when searching for the script file.
              Instead simply <literal>ScriptingIHandler.getClass().getResourceAsStream()</literal>
              is called to get the source of the script file.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              If the script: String is not followed by a slash, the string is assumed to be a
              file's location relative to the docroot of the running pustefix application.
              This usually means everything downwards from the projects-folder.
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Libraries</title>
        <para>
          Of course the Java platform can't interpret every arbitrary on it's own.
          Special Language libraries must be available to the application in order to execute
          script code in the respective languages.
        </para>
        <para>
          Pfixcore comes with the Mozilla's Javascript implementation and the Beanshell
          distribution, so you can write IHandlers and States in Javascript or Beanshell
          without any further requirements.
        </para>
        <para>
          For other languages, like groovy, python or ruby, you'll need their respective
          implementations for the Java platform. The BSF site holds information about where
          to find these implementations.
        </para>
      </section>
    </section>
  </section>

  <section xml:id="advanced.eventbus">
    <title>The Pustefix EventBus</title>
    <para>
      Pustefix provides a simple Spring/annotation-based event mechanism following the publish-subscribe principle.
    </para>
    <para>
      The event system is enabled by adding two bean definitions to the Spring configuration. A <literal>BeanPostProcessor</literal> for
      automatic registration of event subscribers (based on method annotations) and an <literal>EventBus</literal> responsible for 
      publishing events to their subscribers.
    </para>
<programlisting language="xml"><![CDATA[
  <bean id="eventPostProcessor" class="org.pustefixframework.eventbus.EventSubscriberBeanPostProcessor"/>
  <bean id="eventBus" class="org.pustefixframework.eventbus.EventBus"/>
]]></programlisting>
    <para>
      A Spring bean can subcribe to an event by adding the <literal>@Subscribe</literal> method annotation. The method signature requires
      a single parameter of the event's type (subtypes or interfaces are supported too).
    </para>
<programlisting language="java"><![CDATA[
import org.pustefixframework.eventbus.Subscribe;

public class MySubscriberBean {

    @Subscribe
    public void listen(MyEvent event) {
        //process event 
    }

}
]]></programlisting>
    <para>
      An event can be published by calling the <literal>publish</literal> method at the <literal>EventBus</literal>,
      The passed event object can be of an arbitrary type. The <literal>EventBus</literal> will immediately publish the
      event to all registered listeners, i.e. to all listeners which are registered for the event type, a subtype or
      one of its implemented interfaces.
    </para>
<programlisting language="java"><![CDATA[
import org.pustefixframework.eventbus.EventBus;

public class MyPublisherBean {
    
    @Autowired
    EventBus eventBus;
    
    public void doSomething() {
        //do something
        eventBus.publish(new MyEvent());
    }
    
}
]]></programlisting>
  </section>

  <section xml:id="advanced.editor">
    <title>The Pustefix Editor</title>
    <para>
      This has to be re-written from scratch. The old wiki did not contain any
      useful information.
    </para>
  </section>

</chapter>
