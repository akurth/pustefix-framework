<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:pfx="http://www.schlund.de/pustefix/core"
		xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
                xmlns:cus="http://www.schlund.de/pustefix/customize">
  
  <xsl:namespace-alias stylesheet-prefix="ixsl" result-prefix="xsl"/>
  <xsl:output method="xml" encoding="ISO-8859-1" indent="yes"/>

  <xsl:key name="xinp_text" match="pfx:xinp[@type='text']" use="'text'"/>
  <xsl:key name="xinp_area" match="pfx:xinp[@type='area']" use="'area'"/>
  <xsl:key name="xinp_hidden" match="pfx:xinp[@type='hidden']" use="'hidden'"/>
  <xsl:key name="xinp_password" match="pfx:xinp[@type='password']" use="'password'"/>

  <xsl:template name="pfx:get_position">
    <xsl:param name="set"/>
    <xsl:param name="cnode"/>
    <xsl:param name="count"/>
    <xsl:choose>
      <xsl:when test="count($set) > 0">
        <xsl:choose>
          <xsl:when test="generate-id($set[position() = 1]) = generate-id($cnode)">
            <xsl:value-of select="$count"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="pfx:get_position">
              <xsl:with-param name="set" select="$set[position() > 1]"/>
              <xsl:with-param name="cnode" select="$cnode"/>
              <xsl:with-param name="count" select="$count + 1"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>-1</xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template match="pfx:label" name="pfx:label">
    <xsl:param name="name" select="@name"/>
    <xsl:param name="content">
      <xsl:apply-templates/>
    </xsl:param>
    <ixsl:choose>
      <ixsl:when test="/formresult/formerrors/error[@name='{$name}']">
        <xsl:call-template name="pfx:include">
          <xsl:with-param name="href">common/txt/general.xml</xsl:with-param>
          <xsl:with-param name="part">error_icon</xsl:with-param>
        </xsl:call-template>
        <xsl:if test="not(@type = 'hidden')">
          <span class="core_label_error"><xsl:apply-templates/></span>
        </xsl:if>
      </ixsl:when>
      <xsl:if test="not(@type = 'hidden')">
        <ixsl:otherwise>
          <xsl:apply-templates/>
        </ixsl:otherwise>
      </xsl:if>
    </ixsl:choose>
    <cus:documentation>
      <description>pfx:label is used for the description of input fields.
        These descriptions will normally also be used in the &lt;pfx:errorbox&gt;.
        If the user submits a wrong input, an icon indicating an error will be
        displayed in front of the label text.</description>
      <param required="1">
        <name>name</name>
        <description>Must be the same name as the name of the corresponding input field</description>
        <values>
          <string/>
        </values>
      </param>
      <param required="0">
        <name>type</name>
        <values>
          <oneof>
            <option default="true">visible</option>
            <option>hidden</option>
          </oneof>
        </values>
        <description>Label is hidden (it will not be displayed in the page, only the error icon is shown in case of an error)</description>
      </param>
      <example>
        <input>
          <xmlcode><pfx:label name="shirt.Color">Color-No.</pfx:label></xmlcode>
        </input>
        <output>
          Displayed as <xmlcode width="80">Color-No.:</xmlcode> when no error happened;<br/><br/>
          if and error has been detected it's displayed as
          <xmlcode>[Displayed Error icon]<span class="core_errorlabel_text">Color-No.</span></xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:paramref">
    <cus:documentation>
      <description>Used internally</description>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:errorbox">
    <xsl:param name="paramref" select="./pfx:paramref"></xsl:param>
    <ixsl:if test="/formresult/formerrors/node()">
      <table class="core_errorbox_table">
        <xsl:if test="@width"><xsl:copy-of select="@width"/></xsl:if>
	<xsl:choose>
	  <xsl:when test="not($paramref)">
	    <xsl:for-each select="//pfx:label">
	      <xsl:variable name="name"  select="./@name"/>
	      <xsl:variable name="label" select="./node()"/>
	      <ixsl:if test="/formresult/formerrors/error[@name='{$name}']">
		<tr>
		  <td nowrap="nowrap" class="core_errorlabel_td" valign="top">
		    <span class="core_errorlabel_text"><xsl:apply-templates select="$label"/></span>
		  </td>
		  <td class="core_errortext_td">
		    <span class="core_errortext">
		      <ixsl:apply-templates select="/formresult/formerrors/error[@name='{$name}']"/>
		    </span>
		  </td>
		</tr>
	      </ixsl:if>
	    </xsl:for-each>
	  </xsl:when>
	  <xsl:otherwise>
            <xsl:for-each select="$paramref">
              <xsl:variable name="labelname"><xsl:value-of select="./@name"/></xsl:variable>
              <xsl:variable name="label" select="//pfx:label[@name = $labelname]"/>
              <ixsl:if test="/formresult/formerrors/error[@name='{$labelname}']">
                <tr>
                  <td nowrap="nowrap" class="core_errorlabel_td" valign="top">
                    <span class="core_errorlabel_text"><xsl:apply-templates select="$label[position() = 1]/node()"/></span>
                  </td>
                  <td class="core_errortext_td">
                    <span class="core_errortext">
                      <ixsl:apply-templates select="/formresult/formerrors/error[@name='{$labelname}']"/>
                    </span>
                  </td>
                </tr>
              </ixsl:if>
            </xsl:for-each>
	  </xsl:otherwise>
	</xsl:choose>
      </table>
    </ixsl:if>
    <cus:documentation>
      <description>Creates an errorbox,
        that displays all (or a subset of the) errors that happened on
        form submit. You are encouraged to overwrite this template with
        your own definition.  Usually the errorbox shows errors
        for each field on the page. If you want do show only special fields, you'll
        have to specify each field by &lt;pfx:paramref name="FIELDNAME"/&gt;</description>
      <param required="0">
        <name>width</name>
        <description>Width of the Errorbox</description>
        <values>
          <html default="auto"/>
        </values>
      </param>
      <example>
        <input>
          <xmlcode><pfx:errorbox width="200"/></xmlcode>
        </input>
        <output>The errormessages will be generated autmatically.
          <xmlcode>
            <table class="core_errorbox_table" width="500">
              <tr>
                <td nowrap="nowrap" class="core_errorlabel_td" valign="top">
                  <span class="core_errorlabel_text">Are you really older than 18 year ?</span>
                </td>
                <td class="core_errortext_td">
                  <span class="core_errortext"><error name="info.Adult">Please tell me if you're old enough.</error></span>
                </td>
              </tr>
            </table>
          </xmlcode>
        </output>
      </example>
    </cus:documentation> 
  </xsl:template>

  <xsl:template match="pfx:checkactive">
    <xsl:variable name="prefix"><xsl:value-of select="@prefix"/></xsl:variable>
    <xsl:variable name="pg"><xsl:value-of select="@page"/></xsl:variable>
    <xsl:choose>
      <xsl:when test="not($pg = '') and not($prefix = '')">
        <b>[Error: You can't give both attributes "prefix" and "page" to &lt;pfx:checkactive&gt;]</b>
      </xsl:when>
      <xsl:when test="not($prefix = '')">
        <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true']/interface[@prefix = '{$prefix}' and @active = 'true']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:when test="not($pg = '')">
        <ixsl:if test="/formresult/navigation//page[@name = '{$pg}' and @visible = '1']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:otherwise>
        <b>[Error: You need to specify exactly one of the attributes "prefix" or "page" for &lt;pfx:checkactive&gt;]</b>
      </xsl:otherwise>
    </xsl:choose>
    <cus:documentation>
      <description>Two cases: if the prefix-argument is given, it
        checks if the corresponding Handler is active and if this is
        true, everything under &lt;pfx:active&lt; will be displayed. If the
        page argument is given, it checks if the named page is
        visible instead. If this is true, it everything will be displayed, too</description>
      <param required="0">
        <name>prefix</name>
        <description>The prefix of the observed Handler, according to the configuration file</description>
        <values>
          <string/>
        </values>
      </param>
      <param required="0">
        <name>page</name>
        <values>
          <string/>
        </values>
        <description>The name of the observed page</description>
      </param>
      <example>
        <input>
          <xmlcode>
            <pfx:checkactive prefix="shirt">
              T-Shirt Handler is active
            </pfx:checkactive>
            <pfx:checknotactive prefix="shirt">
              T-Shirt Handler is not active
            </pfx:checknotactive></xmlcode>
        </input>
        <output>If the shirt-handler is active
          <xmlcode width="150">T-Shirt is active</xmlcode>will be displayed
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:checknotactive">
    <xsl:variable name="prefix"><xsl:value-of select="@prefix"/></xsl:variable>
    <xsl:variable name="pg"><xsl:value-of select="@page"/></xsl:variable>
    <xsl:choose>
      <xsl:when test="not($pg = '') and not($prefix = '')">
        <b>[Error: You can't give both attributes "prefix" and "page" to &lt;pfx:checknotactive&gt;]</b>
      </xsl:when>
      <xsl:when test="not($prefix = '')">
        <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true']/interface[@prefix = '{$prefix}' and @active = 'false']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:when test="not($pg = '')">
        <ixsl:if test="/formresult/navigation//page[@name = '{$pg}' and @visible = '0']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:otherwise>
        <b>[Error: You need to specify exactly one of the attributes "prefix" or "page" for &lt;pfx:checknotactive&gt;]</b>
      </xsl:otherwise>
    </xsl:choose>
    <cus:documentation>
      <description>Two cases: if the prefix-argument is given, it
        checks if the corresponding Handler is active and if this is
        true, everything under &lt;pfx:active&lt; will be displayed. If the
        page argument is given, it checks if the named page is
        visible instead. If this is true, it everything will be displayed, too</description>
      <param required="1">
        <name>prefix</name>
        <values>
          <string/>
        </values>
        <description>The prefix of the observed Handler, according to the configuration file</description>
      </param>
      <param required="0">
        <name>page</name>
        <values>
          <string/>
        </values>
        <description>The name of the observed page</description>
      </param>
      <example>
        <input>
          <xmlcode>
            <pfx:checkactive prefix="shirt">
              T-Shirt Handler is active
            </pfx:checkactive>
            <pfx:checknotactive prefix="shirt">
              T-Shirt Handler is not active
            </pfx:checknotactive></xmlcode>
        </input>
        <output>If the shirt-handler is not active
          <xmlcode width="150">T-Shirt is not active</xmlcode>will be displayed
        </output>
      </example>
    </cus:documentation>  
  </xsl:template> 

  <xsl:template match="pfx:groupdisplayonly">
    <xsl:variable name="group"><xsl:value-of select="@name"/></xsl:variable>
    <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true' and @name = '{$group}']">
      <xsl:apply-templates/>
    </ixsl:if>
    <cus:documentation>
     <description>Content will only be displayed when /formresult/iwrappergropus/group/@current = true</description>
      <param required="0">
        <name>name</name>
        <values>
          <string/>
        </values>
        <description></description>
      </param>
      <example>
        <input>
          <xmlcode>
            <pfx:groupdisplayonly name="01-Shirt">
              Foo
            </pfx:groupdisplayonly>
          </xmlcode>
        </input>
        <output>
          <xmlcode width="50">Foo</xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template> 
  
  <xsl:template match="pfx:flatdisplayonly">
    <ixsl:if test="/formresult/iwrappergroups[not(@groupdisplay = 'true')]">
      <xsl:apply-templates/>
    </ixsl:if>
    <cus:documentation>
      <description>Content will only be displayed when groupdisplay = false</description>
    </cus:documentation>  
  </xsl:template> 

  <xsl:template match="pfx:forminput">
    <xsl:variable name="send-to-page" select="@send-to-page"/>
    <xsl:variable name="theframe">
      <xsl:choose>
        <xsl:when test="@frame">
          <xsl:value-of select="./@frame"/>
        </xsl:when>
        <xsl:when test="@target">
          <xsl:choose>
            <xsl:when test="@target = '_parent'">
              <xsl:choose>
                <xsl:when test="ancestor::pfx:frame[position()=2]">
                  <xsl:value-of select="ancestor::pfx:frame[position()=2]"/>
                </xsl:when>
                <xsl:otherwise>_top</xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="./@target"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="ancestor-or-self::pfx:frame[position()=1]/@name">
            <xsl:value-of select="ancestor-or-self::pfx:frame[position()=1]/@name"/>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="sendingdata">
      <xsl:choose>
        <xsl:when test="@type = 'auth'">__sendingauthdata</xsl:when>
        <xsl:otherwise>__sendingdata</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="thehandler">
      <xsl:choose>
        <xsl:when test="$send-to-page">
          <xsl:value-of select="$navitree//page[@name=$send-to-page]/@handler"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$navitree//page[@name=$page]/@handler"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <form method="post">
      <xsl:copy-of select="./@*[name()!='send-to-page' and name()!='send-to-pageflow']"/>
      <ixsl:attribute name="action">
        <xsl:choose>
          <xsl:when test="$send-to-page">
            <xsl:value-of select="concat($thehandler, '/', $send-to-page)"/>;<ixsl:value-of select="$__sessid"/><xsl:if test="not($theframe = '')"></xsl:if>?__frame=<xsl:value-of select="$theframe"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($thehandler, '/', $page)"/>;<ixsl:value-of select="$__sessid"/><xsl:if test="not($theframe = '')"></xsl:if>?__frame=<xsl:value-of select="$theframe"/>
          </xsl:otherwise>
        </xsl:choose>
      </ixsl:attribute>
      <ixsl:if test="not($pageflow = '')">
        <input type="hidden" name="__lf">
          <ixsl:attribute name="value"><ixsl:value-of select="$pageflow"/></ixsl:attribute>
        </input>
      </ixsl:if>
      <input type="hidden" name="{$sendingdata}" value="1"/>
      <xsl:if test="@send-to-pageflow">
        <input type="hidden" name="__pageflow" value="{@send-to-pageflow}"/>
      </xsl:if>
      <ixsl:if test="/formresult/iwrappergroups/@currentindex">
        <input type="hidden">
          <xsl:attribute name="name">__currentindex[<xsl:value-of select="$page"/>]</xsl:attribute>
          <ixsl:attribute name="value"><ixsl:value-of select="/formresult/iwrappergroups/@currentindex"/></ixsl:attribute>
        </input>
      </ixsl:if>
      <ixsl:for-each select="/formresult/formhiddenvals/hidden">
        <input type="hidden">
          <ixsl:attribute name="name"><ixsl:value-of select="./@name"/></ixsl:attribute>
          <ixsl:attribute name="value"><ixsl:value-of select="./text()"/></ixsl:attribute>
        </input>
      </ixsl:for-each>
      <xsl:apply-templates/>
    </form>
    <cus:documentation>
      <description>Similar to the html tag &lt;form&gt;
        action/method are not required. You'll have to put it around all
        fields that belong to a formular.
      </description>
      <param required="0">
        <name>send-to-page</name>
        <values><string/></values>
        <description>
          Name of the page that should handle the submitted form values.
          Default is to send the request to the current page.
        </description>
      </param>
      <param required="0">
        <name>send-to-pageflow</name>
        <values><string/></values>
        <description>
          Name of the page flow that should be selected when the request is submitted.
          Default is to not select a special page flow.
        </description>
      </param>
      <param required="0">
        <name>type</name>
        <values>
          <oneof>
            <option default="true"></option>
            <option>auth</option>
          </oneof>
        </values>
        <description>Setting type to 'auth' will submit the values to authentification handlers</description>
      </param>
    </cus:documentation>  
  </xsl:template>

  <xsl:template name="generate_coded_input">
    <xsl:variable name="current" select="generate-id(.)"/>
    <xsl:if test="@jumptopage">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__jumptopage</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@jumptopage"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@jumptopageflow">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__jumptopageflow</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@jumptopageflow"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@forcestop">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__forcestop</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@forcestop"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@pageflow">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__pageflow</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@pageflow"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:for-each select="./pfx:argument">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:<xsl:value-of select="@name"/></ixsl:attribute>
      <ixsl:attribute name="value"><xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>
    <xsl:for-each select="./pfx:anchor">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__anchor</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@frame"/>|<xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>    
    <xsl:for-each select="./pfx:command">
      <input type="hidden"><ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__CMD[<xsl:choose>
      <xsl:when test="@page">
        <xsl:value-of select="@page"/>
      </xsl:when>
      <xsl:when test="ancestor::pfx:forminput[position() = 1 and @send-to-page != '']">
        <xsl:value-of select="ancestor::pfx:forminput[position() = 1]/@send-to-page"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$page"/>
      </xsl:otherwise>
    </xsl:choose>]:<xsl:value-of select="@name"/></ixsl:attribute><ixsl:attribute name="value"><xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='image']" name="pfx:xinp_image">
    <xsl:param name="src" select="@src"/>
    <xsl:param name="alt" select="@alt"/>
    <xsl:param name="exclude-attributes"/>
    <xsl:variable name="always-exclude-attributes" select="'src|alt|type|name|jumptopage|jumptopageflow|forcestop|pageflow'"/>
    <ixsl:variable><xsl:attribute name="name">genname_<xsl:value-of select="generate-id(.)"/></xsl:attribute><xsl:value-of select="generate-id(.)"/><ixsl:value-of select="generate-id(.)"/></ixsl:variable>
    <input type="image" src="{$src}" alt="{$alt}"> 
      <xsl:copy-of select="@*[not(contains(concat('|',$always-exclude-attributes,'|',$exclude-attributes,'|') , concat('|',name(),'|')))]"/>
      <xsl:call-template name="pfx:image_geom_impl">
        <xsl:with-param name="src" select="$src"/>
      </xsl:call-template>
      <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <xsl:call-template name="generate_coded_input"/>
    <cus:documentation>
      <description>Use an image as a submit button. If you want to change the size, set the params width/height
      </description>
      <param required="1">
        <name>src</name>
        <values><path/></values>
        <description>URI of image to embed</description>
      </param>
      <param required="1">
        <name>alt</name>
        <values><string/></values>
        <description>Alternate text for user agents that cannot display images</description>
      </param>
      <param required="0">
        <name>exclude-attributes</name>
        <values><string/></values>
        <description>String of attribute-names _not_ to copy from context-node</description>
      </param>
      <param required="0">
        <name>jumptopage</name>
        <values><string/></values>
        <description>The page to jump to after the state returns control to context. This is a way to select the next page instead of
        having the context decide it by running a pageflow.
        </description>
      </param>
      <param required="0">
        <name>jumptopageflow</name>
        <values><string/></values>
        <description>
          The pageflow to use when for the next page as selected by the jumptopage attribute. If jumptopage is not given, this attribute has no effect. 
        </description>
      </param>
      <param required="0">
        <name>forcestop</name>
        <values><oneof><option>true</option><option>false</option></oneof></values>
        <description>
          <ul>
            <li>"true": No pageflow will be started, the application will stay on the target page unconditionally.</li>
            <li>"false" or attribute not given: The application will decide if a pageflow process is to be started or not.
            This depends on the State or ContextRessource or other classes that may prohibit the pageflow run. Normally you will leave it that way.</li>
          </ul>
        </description>
      </param>
      <children>
        <name>pfx:argument</name>
      </children>
      <children>
        <name>pfx:command</name>
      </children>
      <children>
        <name>pfx:anchor</name>
      </children>
      <example>
        <input>
          <xmlcode><pfx:xinp type="image" src="/sample1/img/test.gif" /></xmlcode>
        </input>
        <output>
          <xmlcode><input border="0" src="/sample1/img/test.gif" type="image" width="120" height="82"/></xmlcode>
        </output>
      </example>
    </cus:documentation>
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='submit']">
    <xsl:param name="exclude-attributes"/>
    <xsl:variable name="always-exclude-attributes" select="'type|name|jumptopage|jumptopageflow|forcestop|pageflow'"/>
    <ixsl:variable><xsl:attribute name="name">genname_<xsl:value-of select="generate-id(.)"/></xsl:attribute><xsl:value-of select="generate-id(.)"/><ixsl:value-of select="generate-id(.)"/></ixsl:variable>
    <input type="submit">
      <xsl:copy-of select="@*[not(contains(concat('|',$always-exclude-attributes,'|',$exclude-attributes,'|') , concat('|',name(),'|')))]"/>
      <!-- <xsl:copy-of select="./@*[name()!='name']"/> -->
      <xsl:choose>
        <xsl:when test="not(@value)">
          <xsl:attribute name="value">
            <xsl:apply-templates/>
          </xsl:attribute>
          <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
          <xsl:apply-templates/>
        </xsl:otherwise>
      </xsl:choose>
    </input>
    <xsl:call-template name="generate_coded_input"/>
    <cus:documentation>
      <description>Creates a submit button. A submit button sends all the fields in the corresponding form.</description>
      <param required="0">
        <name>jumptopage</name>
        <values><string/></values>
        <description>The page to jump to after the state returns control to context. This is a way to select the next page instead of
        having the context decide it by running a pageflow.
        </description>
      </param>
      <param required="0">
        <name>jumptopageflow</name>
        <values><string/></values>
        <description>
          The pageflow to use when for the next page as selected by the jumptopage attribute. If jumptopage is not given, this attribute has no effect. 
        </description>
      </param>
      <param required="0">
        <name>forcestop</name>
        <values><oneof><option>true</option><option>false</option></oneof></values>
        <description>
          <ul>
            <li>"true": No pageflow will be started, the application will stay on the target page unconditionally.</li>
            <li>"false" or attribute not given: The application will decide if a pageflow process is to be started or not.
            This depends on the State or ContextRessource or other classes that may prohibit the pageflow run. Normally you will leave it that way.</li>
          </ul>
        </description>
      </param>
      <children>
        <name>pfx:argument</name>
        <description>Use pfx:argument, if you need Parameters in your href(see pfx:argument)</description>        
      </children>
      <children>
        <name>pfx:command</name>
      </children>
      <children>
        <name>pfx:anchor</name>
      </children>
      <example>
        <input>
          <xmlcode><pfx:xinp type="submit" value="Go!"/></xmlcode>
        </input>
        <output>
          <xmlcode><input type="submit" value="Go!"/></xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='hidden']">
    <input type="hidden">
      <xsl:copy-of select="@name"/>
      <xsl:variable name="thename" select="@name"/>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position = 'auto'">
            <xsl:call-template name="pfx:get_position">
              <xsl:with-param name="set" select="key('xinp_hidden','hidden')[@name = $thename]"/>
              <xsl:with-param name="cnode" select="."/>
              <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
          </xsl:when>
          <xsl:when test="@position">
            <xsl:value-of select="@position"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <ixsl:attribute name="value">
        <ixsl:value-of select="/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}]"/>
      </ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <param required="0">
        <name>position</name>
        <values><oneof><option>auto</option><option>1,2,3..</option></oneof></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree, or the string "auto" which automatically let's the n-th
        occurance of the input parameter on the UI choose the n-th occurance of the value in the output tree</description>
      </param>
      <description>Creates a html hidden field.</description>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='select']">
    <xsl:variable name="name" select="string(@name)"/>
    <select name="{$name}">
      <xsl:copy-of select="@*[name()!='type']"/>
      <xsl:if test="@multiple"><xsl:attribute name="multiple">multiple</xsl:attribute></xsl:if>
      <xsl:apply-templates/>
    </select>
    <cus:documentation>
      <description>creates a select box form element. The options are given via a list of &lt;pfx:option&gt;
        child elements.</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the box</description>
      </param>
      <children>
        <name>pfx:option</name>
        <description>option tag like in a html</description>        
      </children>
      <children>
        <name>pfx:dynoptions</name>
        <description>render option tags given via the result tree</description>        
      </children>
      <example>
        <input>
          <xmlcode>
            <pfx:xinp type="select" name="foo">
              <pfx:option>baz</pfx:option>
              <pfx:option>baz_neu</pfx:option>
              <pfx:dynoptions optionspath="/formresult/foo"/>
              <pfx:option>baz_old</pfx:option>    
            </pfx:xinp>
          </xmlcode>
        </input>
        <output>
          <xmlcode>
            <select name="foo">
              <option>baz</option>
              <option>baz_neu</option>
              <option>BAR</option>
              <option>BAZ</option>
              <option>baz_old</option>
            </select>
          </xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:option">
    <xsl:param name="name" select="ancestor::pfx:xinp[@type='select']/@name"/>
    <xsl:variable name="value">
      <xsl:choose>
        <xsl:when test="@value">
          <xsl:value-of select="@value"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="./node()"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <option>
      <xsl:copy-of select="@*[name()!= 'default']"/>
      <xsl:choose>
        <xsl:when test="@default = 'true'">
          <ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text()='{$value}' or not(/formresult/formvalues/param[@name='{$name}'])">
            <ixsl:attribute name="selected">selected</ixsl:attribute>
          </ixsl:if>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text()='{$value}'">
            <ixsl:attribute name="selected">selected</ixsl:attribute>
          </ixsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates select="./node()"/>
    </option>
    <cus:documentation>
      <description>Creates an "option" formelement.</description>
      <param required="0">
        <name>name</name>
        <values><string/></values>
        <description>name attribute of the option</description>
      </param>
      <param required="0">
        <name>value</name>
        <values><string/></values>
        <description>value attribute of the option tag.</description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <oneof><option>true</option><option>false</option></oneof>
        </values>
        <description>if set to true, the option is selected by default if no
        other value is given by the business logic</description>
      </param>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:dynoptions">
    <xsl:param name="name" select="ancestor::pfx:xinp[@type='select']/@name"/>
    <ixsl:for-each select="{@optionpath}/option">
      <ixsl:variable name="value">
        <ixsl:choose>
          <ixsl:when test="@value">
            <ixsl:value-of select="@value"/>
          </ixsl:when>
          <ixsl:otherwise>
            <ixsl:apply-templates select="./node()"/>
          </ixsl:otherwise>
        </ixsl:choose>
      </ixsl:variable>
      <option>
        <ixsl:copy-of select="./@*[name()!= 'default']"/>
        <ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text() = $value or
          (@default = 'true' and not(/formresult/formvalues/param[@name='{$name}']))">
          <ixsl:attribute name="selected">selected</ixsl:attribute>
        </ixsl:if>
        <ixsl:apply-templates select="./node()"/>
      </option>
    </ixsl:for-each>
    <cus:documentation>
      <description>Creates one or more "option" form elements. The options are taken from the result tree,
      where they need to be given below the element designated by the "optionpath" attribute</description>
      <param required="1">
        <name>optionpath</name> 
        <values><xpath/></values>
        <description>The path to
        the node in the result tree, under which the "option" elements
        are that should be inserted</description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <oneof><option>true</option><option>false</option></oneof>
        </values>
        <description>if set to true, the option is selected by default if no
        other value is given by the business logic</description>
      </param>
    </cus:documentation>
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='radio']">
    <input type="radio">
      <xsl:copy-of select="@*[name()!='type' and name()!='default']"/>
      <xsl:choose>
        <xsl:when test="@default = 'true'">
          <ixsl:if test="/formresult/formvalues/param[@name='{@name}']/text()='{@value}' or not(/formresult/formvalues/param[@name='{@name}'])">
            <ixsl:attribute name="checked">checked</ixsl:attribute>
          </ixsl:if>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:if test="/formresult/formvalues/param[@name='{@name}']/text()='{@value}'">
            <ixsl:attribute name="checked">checked</ixsl:attribute>
          </ixsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>Creates a html radio button. Every radio button in a group has the same name.
        The attribute "value" should be different for each radio button.
        All attributes except "type" and "default" will be copied to the resulting html element.
      </description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the radiobutton</description>
      </param>
      <example>
        <input>
          <xmlcode>
            <pfx:forminput>
              <pfx:xinp type="radio" name="feldname" value="wert1">My Text to 1</pfx:xinp><br/>
              <pfx:xinp type="radio" name="feldname" value="wert2">Title  2</pfx:xinp><br/>
              <pfx:xinp type="radio" name="feldname" value="wert3">Something Point 3</pfx:xinp><br/>
            </pfx:forminput>
          </xmlcode>
        </input>
        <output>
          <xmlcode>
            <form method="post" action="baz">
              <input type="radio" name="feldname" value="wert1"/>My Text to 1<br/>
              <input type="radio" name="feldname" value="wert2"/>Title  2<br/>
              <input type="radio" name="feldname" value="wert3"/>Something Point 3<br/>
            </form>
          </xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='check']">
    <input type="checkbox">
      <xsl:copy-of select="@*[name()!='type' and name()!='default']"/>
      <xsl:choose>
        <xsl:when test="@default = 'true'">
          <ixsl:if test="/formresult/formvalues/param[@name='{@name}']/text()='{@value}' or not(/formresult/formvalues/param[@name='{@name}'])">
            <ixsl:attribute name="checked">checked</ixsl:attribute>
          </ixsl:if>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:if test="/formresult/formvalues/param[@name='{@name}']/text()='{@value}'">
            <ixsl:attribute name="checked">checked</ixsl:attribute>
          </ixsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>
        Creates a check box form element. All attributes given except "type" and "default" will be copied to the final html tag.
      </description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>Name of the check box</description>
      </param>
      <param required="1">
        <name>type</name>
        <values>
          <oneof><option>check</option></oneof>
        </values>
        <description></description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <oneof><option>true</option><option>false</option></oneof>
        </values>
        <description>if set to true, the checkbox is checked by default if no
        other value is mandated by the business logic</description>
      </param>
    </cus:documentation>    
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='text']">
    <input type="text" size="40" maxlength="200">
      <xsl:copy-of select="@*[name()!='type' and name()!='default' and name()!='position']"/>
      <xsl:variable name="thename" select="@name"/>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position = 'auto'">
            <xsl:call-template name="pfx:get_position">
              <xsl:with-param name="set" select="key('xinp_text','text')[@name = $thename]"/>
              <xsl:with-param name="cnode" select="."/>
              <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
          </xsl:when>
          <xsl:when test="@position">
            <xsl:value-of select="@position"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="@default">
          <ixsl:attribute name="value">
            <ixsl:choose>
              <ixsl:when test="not(/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}])"><xsl:value-of select="@default"/></ixsl:when>
              <ixsl:otherwise><ixsl:value-of select="/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}]"/></ixsl:otherwise>
            </ixsl:choose>
          </ixsl:attribute>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:attribute name="value"><ixsl:value-of select="/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}]"/></ixsl:attribute>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>
      Creates a text input field. All attributes given will be copied to the final html tag.</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the input-field</description>
      </param>
      <param required="0">
        <name>maxlength</name>
        <values><int default="200"/></values>
        <description>maxlength of the inputfield (chars)</description>
      </param>
      <param required="0">
        <name>size</name>
        <values><int default="40"/></values>
        <description>size of the inputfield</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>text</option></oneof></values>
        <description></description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <string/>
        </values>
        <description>if set to any value, the text field is set this value by default if no
        other value is given by the business logic</description>
      </param>
      <param required="0">
        <name>position</name>
        <values><oneof><option>auto</option><option>1,2,3..</option></oneof></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree, or the string "auto" which automatically let's the n-th
        occurance of the input parameter on the UI choose the n-th occurance of the value in the output tree</description>
      </param>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='password']">
    <input type="password" size="40" maxlength="200">
      <xsl:copy-of select="@*[name()!='type']"/>
      <xsl:variable name="thename" select="@name"/>
      <ixsl:attribute name="value">
        <ixsl:value-of select="/formresult/formvalues/param[@name='{$thename}'][position() = 1]"/>
      </ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>Creates a password input field. The text in this field will be displayed like this: ********</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the input-field</description>
      </param>
      <param required="0">
        <name>maxlength</name>
        <values><int default="200"/></values>
        <description>maxlength of the inputfield (chars)</description>
      </param>
      <param required="0">
        <name>size</name>
        <values><int default="40"/></values>
        <description>size of the inputfield</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>password</option></oneof></values>
        <description></description>
      </param>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='area']">
    <textarea cols="38" rows="20">
      <xsl:copy-of select="@*[name()!='type' and name()!='position']"/>
      <xsl:variable name="thename" select="@name"/>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position = 'auto'">
            <xsl:call-template name="pfx:get_position">
              <xsl:with-param name="set" select="key('xinp_area','area')[@name = $thename]"/>
              <xsl:with-param name="cnode" select="."/>
              <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
          </xsl:when>
          <xsl:when test="@position">
            <xsl:value-of select="@position"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <ixsl:choose>
        <ixsl:when test="not(/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}])"><xsl:apply-templates/></ixsl:when>
        <ixsl:otherwise><ixsl:value-of select="/formresult/formvalues/param[@name='{$thename}'][position() = {$pos}]"/></ixsl:otherwise>
      </ixsl:choose>
    </textarea>
    <cus:documentation>
      <description>Creates a html-textarea. All attributes will be copied to the resulting
      &lt;textarea&gt; html tag</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>Name of the textarea</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>area</option></oneof></values>
        <description></description>
      </param>
      <param required="0">
        <name>cols</name>
        <values><int default="38"/></values>
        <description>number of cols</description>
      </param>
      <param required="0">
        <name>rows</name>
        <values><int default="20"/></values>
        <description>number of rows</description>
      </param>
      <param required="0">
        <name>position</name>
        <values><oneof><option>auto</option><option>1,2,3..</option></oneof></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree, or the string "auto" which automatically let's the n-th
        occurance of the input parameter on the UI choose the n-th occurance of the value in the output tree</description>
      </param>
      <example>
        <input>
          <xmlcode><pfx:xinp type="area" name="foo"/></xmlcode>
        </input>
        <output>
          <xmlcode><textarea cols="38" rows="20" name="foo"/></xmlcode>
        </output>
      </example>
    </cus:documentation>   
  </xsl:template>

  







  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:xoutp">
    <ixsl:value-of select="/formresult/formvalues/param[@name='{@name}']"/>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>  
  </xsl:template>
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:xoutperror">
    <ixsl:apply-templates select="/formresult/formerrors/error[@name='{@name}']"/>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>

  <!-- DEPRECATED -->
  <xsl:template name="renderoptions">
    <xsl:param name="options"/>
    <xsl:param name="name"/>
    <xsl:for-each select="$options">
      <xsl:variable name="value">
	<xsl:choose>
	  <xsl:when test="@value">
	    <xsl:value-of select="@value"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:apply-templates select="./node()"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:variable>
      <option>
	<xsl:copy-of select="@*[name()!= 'position']"/>
	<ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text()='{$value}'">
	  <ixsl:attribute name="selected">selected</ixsl:attribute>
	</ixsl:if>
	<xsl:apply-templates select="./node()"/>
      </option>
    </xsl:for-each>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:xinp[@type='dynselect']">
    <xsl:variable name="name" select="string(@name)"/>
    <select name="{$name}">
      <xsl:copy-of select="@*[name()!='type' and name()!='optionpath']"/>
      <xsl:if test="@multiple"><xsl:attribute name="multiple">multiple</xsl:attribute></xsl:if>
      <xsl:call-template name="renderoptions">
	<xsl:with-param name="options" select=".//pfx:option[not(@position = 'end')]"/>
	<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
      </xsl:call-template>
      <ixsl:for-each select="{@optionpath}/option">
        <ixsl:variable name="value">
          <ixsl:choose>
            <ixsl:when test="@value">
              <ixsl:value-of select="@value"/>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:apply-templates select="./node()"/>
            </ixsl:otherwise>
          </ixsl:choose>
        </ixsl:variable>
        <option>
          <ixsl:copy-of select="./@*"/>
          <ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text() = $value">
            <ixsl:attribute name="selected">selected</ixsl:attribute>
          </ixsl:if>
          <ixsl:apply-templates select="./node()"/></option>
      </ixsl:for-each>
      <xsl:call-template name="renderoptions">
	<xsl:with-param name="options" select=".//pfx:option[@position = 'end']"/>
	<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
      </xsl:call-template>
    </select>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>
    
</xsl:stylesheet>

<!--
Local Variables:
mode: xsl
End:
-->
