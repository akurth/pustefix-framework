<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:pfx="http://www.schlund.de/pustefix/core"
		xmlns:ixsl="http://www.w3.org/1999/XSL/TransformOutputAlias"
                xmlns:cus="http://www.schlund.de/pustefix/customize">
  
  <xsl:namespace-alias stylesheet-prefix="ixsl" result-prefix="xsl"/>
  <xsl:output method="xml" encoding="ISO-8859-1" indent="yes"/>

  <xsl:template match="pfx:checkactive">
    <xsl:variable name="prefix"><xsl:value-of select="@prefix"/></xsl:variable>
    <xsl:variable name="pg"><xsl:value-of select="@page"/></xsl:variable>
    <xsl:choose>
      <xsl:when test="not($pg = '') and not($prefix = '')">
        <b>[Error: You can't give both attributes "prefix" and "page" to &lt;pfx:checkactive&gt;]</b>
      </xsl:when>
      <xsl:when test="not($prefix = '')">
        <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true']/interface[@prefix = '{$prefix}' and @active = 'true']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:when test="not($pg = '')">
        <ixsl:if test="/formresult/navigation//page[@name = '{$pg}' and @visible = '1']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:otherwise>
        <b>[Error: You need to specify exactly one of the attributes "prefix" or "page" for &lt;pfx:checkactive&gt;]</b>
      </xsl:otherwise>
    </xsl:choose>
    <cus:documentation>
      <description>If the prefix attribute is given, it
        checks if the corresponding Handler is active and if this is
        true, the content will be displayed. If the
        page attribute is given, it checks if the named page is
        visible instead. If this is true, the content will be displayed.</description>
      <param required="1">
        <name>prefix</name>
        <values>
          <string/>
        </values>
        <description>The prefix of the observed Handler, according to the configuration file</description>
      </param>
      <param required="0">
        <name>page</name>
        <values>
          <string/>
        </values>
        <description>The name of the observed page</description>
      </param>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:checknotactive">
    <xsl:variable name="prefix"><xsl:value-of select="@prefix"/></xsl:variable>
    <xsl:variable name="pg"><xsl:value-of select="@page"/></xsl:variable>
    <xsl:choose>
      <xsl:when test="not($pg = '') and not($prefix = '')">
        <b>[Error: You can't give both attributes "prefix" and "page" to &lt;pfx:checknotactive&gt;]</b>
      </xsl:when>
      <xsl:when test="not($prefix = '')">
        <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true']/interface[@prefix = '{$prefix}' and @active = 'false']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:when test="not($pg = '')">
        <ixsl:if test="/formresult/navigation//page[@name = '{$pg}' and @visible = '0']">
          <xsl:apply-templates/>
        </ixsl:if>
      </xsl:when>
      <xsl:otherwise>
        <b>[Error: You need to specify exactly one of the attributes "prefix" or "page" for &lt;pfx:checknotactive&gt;]</b>
      </xsl:otherwise>
    </xsl:choose>
    <cus:documentation>
      <description>If the prefix attribute is given, it
        checks if the corresponding Handler is NOT active and if this is
        true, the content will be displayed. If the
        page attribute is given, it checks if the named page is
        NOT visible instead. If this is true, the content will be displayed.</description>
      <param required="1">
        <name>prefix</name>
        <values>
          <string/>
        </values>
        <description>The prefix of the observed Handler, according to the configuration file</description>
      </param>
      <param required="0">
        <name>page</name>
        <values>
          <string/>
        </values>
        <description>The name of the observed page</description>
      </param>
    </cus:documentation>  
  </xsl:template> 

  <xsl:template match="pfx:error"/>
  <xsl:template match="pfx:normal"/>
  
  <xsl:template match="pfx:checkerror">
    <xsl:variable name="err_class">
      <xsl:choose>
        <xsl:when test="@errorclass">
          <xsl:value-of select="@errorclass"/>
        </xsl:when>
        <xsl:otherwise>core_label_error</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="norm_class">
      <xsl:choose>
        <xsl:when test="@normalclass">
          <xsl:value-of select="@normalclass"/>
        </xsl:when>
        <xsl:otherwise>core_label_normal</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <ixsl:if test="1 = 1"> <!-- make sure to have a local scope --> 
      <ixsl:variable name="realname">
        <xsl:choose>
          <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
          <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
        </xsl:choose>
      </ixsl:variable>
      <ixsl:variable name="generror">
        <xsl:choose>
          <xsl:when test="@generror"><xsl:value-of select="@generror"/></xsl:when>
          <xsl:otherwise>pfixcore.GEN_ERROR</xsl:otherwise>
        </xsl:choose>
      </ixsl:variable>
      <ixsl:choose>
        <ixsl:when test="(string($realname) = '' and /formresult/formerrors/error) or
                         (string($realname) != '' and /formresult/formerrors/error[@name=string($realname)])">
          <xsl:choose>
            <xsl:when test="$err_class != 'NONE'">
              <span class="{$err_class}"><xsl:apply-templates/>
              <xsl:apply-templates select="./pfx:error/node()"/></span>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates/>
              <xsl:apply-templates select="./pfx:error/node()"/>
            </xsl:otherwise>
          </xsl:choose>
        </ixsl:when>
        <ixsl:otherwise>
          <xsl:choose>
            <xsl:when test="$norm_class != 'NONE'">
              <span class="{$norm_class}"><xsl:apply-templates/>
              <xsl:apply-templates select="./pfx:normal/node()"/></span>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates/>
              <xsl:apply-templates select="./pfx:normal/node()"/>
            </xsl:otherwise>
          </xsl:choose>
        </ixsl:otherwise>
      </ixsl:choose>
    </ixsl:if>
  </xsl:template>

  <xsl:template match="pfx:scode">
    <!-- $realname, $generror are defined in parent pfx:checkerror -->
    <ixsl:choose>
      <ixsl:when test="string($realname) = ''">
        <ixsl:call-template name="pfx:include">
          <ixsl:with-param name="href">common/dyntxt/statusmessages.xml</ixsl:with-param>
          <ixsl:with-param name="part"><ixsl:value-of select="$generror"/></ixsl:with-param>
        </ixsl:call-template>
      </ixsl:when>
      <ixsl:otherwise>
        <ixsl:apply-templates select="/formresult/formerrors/error[@name=string($realname)]"/>
      </ixsl:otherwise>
    </ixsl:choose>
  </xsl:template>
  
  <xsl:template match="pfx:forminput">
    <xsl:variable name="send-to-page" select="@send-to-page"/>
    <xsl:variable name="theframe">
      <xsl:choose>
        <xsl:when test="@frame">
          <xsl:value-of select="./@frame"/>
        </xsl:when>
        <xsl:when test="@target">
          <xsl:choose>
            <xsl:when test="@target = '_parent'">
              <xsl:choose>
                <xsl:when test="ancestor::pfx:frame[position()=2]">
                  <xsl:value-of select="ancestor::pfx:frame[position()=2]"/>
                </xsl:when>
                <xsl:otherwise>_top</xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="./@target"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="ancestor-or-self::pfx:frame[position()=1]/@name">
            <xsl:value-of select="ancestor-or-self::pfx:frame[position()=1]/@name"/>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="sendingdata">
      <xsl:choose>
        <xsl:when test="@type = 'auth'">__sendingauthdata</xsl:when>
        <xsl:otherwise>__sendingdata</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="thehandler">
      <xsl:choose>
        <xsl:when test="$send-to-page">
          <xsl:value-of select="$navitree//page[@name=$send-to-page]/@handler"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$navitree//page[@name=$page]/@handler"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <form method="post">
      <xsl:copy-of select="./@*[name()!='send-to-page' and name()!='send-to-pageflow']"/>
      <ixsl:attribute name="action">
        <xsl:choose>
          <xsl:when test="$send-to-page">
            <xsl:value-of select="concat($thehandler, '/', $send-to-page)"/>;<ixsl:value-of select="$__sessid"/><xsl:if test="not($theframe = '')"></xsl:if>?__frame=<xsl:value-of select="$theframe"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($thehandler, '/', $page)"/>;<ixsl:value-of select="$__sessid"/><xsl:if test="not($theframe = '')"></xsl:if>?__frame=<xsl:value-of select="$theframe"/>
          </xsl:otherwise>
        </xsl:choose>
      </ixsl:attribute>
      <ixsl:if test="not($pageflow = '')">
        <input type="hidden" name="__lf">
          <ixsl:attribute name="value"><ixsl:value-of select="$pageflow"/></ixsl:attribute>
        </input>
      </ixsl:if>
      <input type="hidden" name="{$sendingdata}" value="1"/>
      <xsl:if test="@send-to-pageflow">
        <input type="hidden" name="__pageflow" value="{@send-to-pageflow}"/>
      </xsl:if>
      <ixsl:if test="/formresult/iwrappergroups/@currentindex">
        <input type="hidden">
          <xsl:attribute name="name">__currentindex[<xsl:value-of select="$page"/>]</xsl:attribute>
          <ixsl:attribute name="value"><ixsl:value-of select="/formresult/iwrappergroups/@currentindex"/></ixsl:attribute>
        </input>
      </ixsl:if>
      <ixsl:for-each select="/formresult/formhiddenvals/hidden">
        <input type="hidden">
          <ixsl:attribute name="name"><ixsl:value-of select="./@name"/></ixsl:attribute>
          <ixsl:attribute name="value"><ixsl:value-of select="./text()"/></ixsl:attribute>
        </input>
      </ixsl:for-each>
      <xsl:apply-templates/>
    </form>
    <cus:documentation>
      <description>Similar to the html tag &lt;form&gt;
        action/method are not required. You'll have to put it around all
        fields that belong to a formular.
      </description>
      <param required="0">
        <name>send-to-page</name>
        <values><string/></values>
        <description>
          Name of the page that should handle the submitted form values.
          Default is to send the request to the current page.
        </description>
      </param>
      <param required="0">
        <name>send-to-pageflow</name>
        <values><string/></values>
        <description>
          Name of the page flow that should be selected when the request is submitted.
          Default is to not select a special page flow.
        </description>
      </param>
      <param required="0">
        <name>type</name>
        <values>
          <oneof>
            <option default="true"></option>
            <option>auth</option>
          </oneof>
        </values>
        <description>Setting type to 'auth' will submit the values to authentification handlers</description>
      </param>
    </cus:documentation>  
  </xsl:template>

  <xsl:template name="generate_coded_input">
    <xsl:variable name="current" select="generate-id(.)"/>
    <xsl:if test="@jumptopage">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__jumptopage</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@jumptopage"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@jumptopageflow">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__jumptopageflow</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@jumptopageflow"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@forcestop">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__forcestop</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@forcestop"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:if test="@pageflow">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__pageflow</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@pageflow"/></ixsl:attribute></input>
    </xsl:if>
    <xsl:for-each select="./pfx:argument">
      <xsl:call-template name="pfx:formwarn">
        <xsl:with-param name="type">unknown</xsl:with-param>
        <xsl:with-param name="data" select="current()"/>
      </xsl:call-template>
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:<xsl:value-of select="@name"/></ixsl:attribute>
      <ixsl:attribute name="value"><xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>
    <xsl:for-each select="./pfx:anchor">
      <input type="hidden">
        <ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__anchor</ixsl:attribute>
      <ixsl:attribute name="value"><xsl:value-of select="@frame"/>|<xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>    
    <xsl:for-each select="./pfx:command">
      <input type="hidden"><ixsl:attribute name="name">__SYNT:<ixsl:value-of select="$genname_{$current}"/>:__CMD[<xsl:choose>
      <xsl:when test="@page">
        <xsl:value-of select="@page"/>
      </xsl:when>
      <xsl:when test="ancestor::pfx:forminput[position() = 1 and @send-to-page != '']">
        <xsl:value-of select="ancestor::pfx:forminput[position() = 1]/@send-to-page"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$page"/>
      </xsl:otherwise>
    </xsl:choose>]:<xsl:value-of select="@name"/></ixsl:attribute><ixsl:attribute name="value"><xsl:apply-templates select="./node()"/></ixsl:attribute></input>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='image']" name="pfx:xinp_image">
    <xsl:param name="src" select="@src"/>
    <xsl:param name="themed-path" select="@themed-path"/>
    <xsl:param name="themed-img"  select="@themed-img"/>
    <xsl:param name="alt" select="@alt"/>
    <xsl:param name="exclude-attributes"/>
    <xsl:variable name="always-exclude-attributes" select="'src|themed-path|themed-img|alt|type|name|jumptopage|jumptopageflow|forcestop|pageflow'"/>
    <xsl:variable name="realsrc">
      <xsl:call-template name="pfx:image_register_src">
        <xsl:with-param name="src" select="$src"/>
        <xsl:with-param name="themed-path" select="$themed-path"/>
        <xsl:with-param name="themed-img" select="$themed-img"/>
      </xsl:call-template>
    </xsl:variable>
    <ixsl:variable><xsl:attribute name="name">genname_<xsl:value-of select="generate-id(.)"/></xsl:attribute><xsl:value-of select="generate-id(.)"/><ixsl:value-of select="generate-id(.)"/></ixsl:variable>
    <input type="image" src="/{$realsrc}" alt="{$alt}"> 
      <xsl:copy-of select="@*[not(contains(concat('|',$always-exclude-attributes,'|',$exclude-attributes,'|') , concat('|',name(),'|')))]"/>
      <xsl:call-template name="pfx:image_geom_impl">
        <xsl:with-param name="src" select="$realsrc"/>
      </xsl:call-template>
      <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <xsl:call-template name="generate_coded_input"/>
    <cus:documentation>
      <description>Use an image as a submit button. If you want to change the size, set the params width/height
      </description>
      <param required="1">
        <name>src</name>
        <values><path/></values>
        <description>URI of image to embed</description>
      </param>
      <param required="1">
        <name>alt</name>
        <values><string/></values>
        <description>Alternate text for user agents that cannot display images</description>
      </param>
      <param required="0">
        <name>exclude-attributes</name>
        <values><string/></values>
        <description>String of attribute-names _not_ to copy from context-node</description>
      </param>
      <param required="0">
        <name>jumptopage</name>
        <values><string/></values>
        <description>The page to jump to after the state returns control to context. This is a way to select the next page instead of
        having the context decide it by running a pageflow.
        </description>
      </param>
      <param required="0">
        <name>jumptopageflow</name>
        <values><string/></values>
        <description>
          The pageflow to use when for the next page as selected by the jumptopage attribute. If jumptopage is not given, this attribute has no effect. 
        </description>
      </param>
      <param required="0">
        <name>forcestop</name>
        <values><oneof><option>true</option><option>step</option><option>false</option></oneof></values>
        <description>
          <ul>
            <li>"true": No pageflow will be started, the application will stay on the target page unconditionally.</li>
            <li>"false" or attribute not given: The application will decide if a pageflow process is to be started or not.
            This depends on the State or ContextRessource or other classes that may prohibit the pageflow run. Normally you will leave it that way.</li>
          </ul>
        </description>
      </param>
      <children>
        <name>pfx:argument</name>
      </children>
      <children>
        <name>pfx:command</name>
      </children>
      <children>
        <name>pfx:anchor</name>
      </children>
      <example>
        <input>
          <xmlcode><pfx:xinp type="image" src="/sample1/img/test.gif" /></xmlcode>
        </input>
        <output>
          <xmlcode><input border="0" src="/sample1/img/test.gif" type="image" width="120" height="82"/></xmlcode>
        </output>
      </example>
    </cus:documentation>
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='submit']">
    <xsl:param name="exclude-attributes"/>
    <xsl:variable name="always-exclude-attributes" select="'type|name|jumptopage|jumptopageflow|forcestop|pageflow'"/>
    <ixsl:variable><xsl:attribute name="name">genname_<xsl:value-of select="generate-id(.)"/></xsl:attribute><xsl:value-of select="generate-id(.)"/><ixsl:value-of select="generate-id(.)"/></ixsl:variable>
    <input type="submit">
      <xsl:copy-of select="@*[not(contains(concat('|',$always-exclude-attributes,'|',$exclude-attributes,'|') , concat('|',name(),'|')))]"/>
      <!-- <xsl:copy-of select="./@*[name()!='name']"/> -->
      <xsl:choose>
        <xsl:when test="not(@value)">
          <xsl:attribute name="value">
            <xsl:apply-templates/>
          </xsl:attribute>
          <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
        </xsl:when>
        <xsl:otherwise>
          <ixsl:attribute name="name">__SBMT:<ixsl:value-of select="$genname_{generate-id(.)}"/>:</ixsl:attribute>
          <xsl:apply-templates/>
        </xsl:otherwise>
      </xsl:choose>
    </input>
    <xsl:call-template name="generate_coded_input"/>
    <cus:documentation>
      <description>Creates a submit button. A submit button sends all the fields in the corresponding form.</description>
      <param required="0">
        <name>jumptopage</name>
        <values><string/></values>
        <description>The page to jump to after the state returns control to context. This is a way to select the next page instead of
        having the context decide it by running a pageflow.
        </description>
      </param>
      <param required="0">
        <name>jumptopageflow</name>
        <values><string/></values>
        <description>
          The pageflow to use when for the next page as selected by the jumptopage attribute. If jumptopage is not given, this attribute has no effect. 
        </description>
      </param>
      <param required="0">
        <name>forcestop</name>
        <values><oneof><option>true</option><option>step</option><option>false</option></oneof></values>
        <description>
          <ul>
            <li>"true": No pageflow will be started, the application will stay on the target page unconditionally.</li>
            <li>"false" or attribute not given: The application will decide if a pageflow process is to be started or not.
            This depends on the State or ContextRessource or other classes that may prohibit the pageflow run. Normally you will leave it that way.</li>
          </ul>
        </description>
      </param>
      <children>
        <name>pfx:argument</name>
        <description>Use pfx:argument, if you need Parameters in your href(see pfx:argument)</description>        
      </children>
      <children>
        <name>pfx:command</name>
      </children>
      <children>
        <name>pfx:anchor</name>
      </children>
      <example>
        <input>
          <xmlcode><pfx:xinp type="submit" value="Go!"/></xmlcode>
        </input>
        <output>
          <xmlcode><input type="submit" value="Go!"/></xmlcode>
        </output>
      </example>
    </cus:documentation>
  </xsl:template>

  <xsl:template match="pfx:value"/>
  <xsl:template match="pfx:name"/>
  <xsl:template match="pfx:default"/>
 
  <xsl:template match="pfx:xinp[@type='hidden']">
    <input type="hidden">
      <xsl:variable name="thename" select="@name"/>
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
        <xsl:otherwise><xsl:value-of select="$thename"/></xsl:otherwise>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="$realname"/></ixsl:attribute>
      <ixsl:variable name="realdefault"><xsl:choose>
        <xsl:when test="@default"><xsl:value-of select="@default"/></xsl:when>
        <xsl:when test="./pfx:default"><xsl:apply-templates select="./pfx:default/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position"><xsl:value-of select="@position"/></xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <ixsl:attribute name="value">
        <ixsl:choose>
          <ixsl:when test="not(/formresult/formvalues/param[@name=string($realname)][position() = {$pos}])"><ixsl:value-of select="$realdefault"/></ixsl:when>
          <ixsl:otherwise><ixsl:value-of select="/formresult/formvalues/param[@name=string($realname)][position() = {$pos}]"/></ixsl:otherwise>
        </ixsl:choose>
      </ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <param required="0">
        <name>position</name>
        <values><int default="1"/></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree.</description>
      </param>
      <description>Creates a html hidden field.</description>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='select']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <select>
      <xsl:copy-of select="@*[name()!='type' and name()!='name']"/>
      <xsl:if test="@multiple"><xsl:attribute name="multiple">multiple</xsl:attribute></xsl:if>
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <xsl:apply-templates/>
    </select>
    <cus:documentation>
      <description>creates a select box form element. The options are given via a list of
      &lt;pfx:option&gt; or &lt;pfx:dynoptions&gt; child elements.</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the box</description>
      </param>
      <children>
        <name>pfx:option</name>
        <description>option tag</description>        
      </children>
      <children>
        <name>pfx:dynoptions</name>
        <description>option tags given via the result tree</description>        
      </children>
      <example>
        <input>
          <xmlcode>
            <pfx:xinp type="select" name="foo">
              <pfx:option>baz</pfx:option>
              <pfx:option>baz_neu</pfx:option>
              <pfx:dynoptions optionspath="/formresult/foo"/>
              <pfx:option>baz_old</pfx:option>    
            </pfx:xinp>
          </xmlcode>
        </input>
        <output>
          <xmlcode>
            <select name="foo">
              <option>baz</option>
              <option>baz_neu</option>
              <option>BAR</option>
              <option>BAZ</option>
              <option>baz_old</option>
            </select>
          </xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:option">
    <!-- $realname will be set in the parent select -->
    <option>
      <xsl:copy-of select="@*[name()!= 'default' and name()!= 'value']"/>
      <ixsl:variable name="realvalue"><xsl:choose>
        <xsl:when test="@value"><xsl:value-of select="@value"/></xsl:when>
        <xsl:when test="./pfx:value"><xsl:apply-templates select="./pfx:value/node()"/></xsl:when>
        <xsl:otherwise><xsl:apply-templates select="./node()[name() != 'ixsl:attribute']"/></xsl:otherwise>
      </xsl:choose></ixsl:variable>
      <ixsl:variable name="realdefault"><xsl:choose>
        <xsl:when test="@default"><xsl:value-of select="@default"/></xsl:when>
        <xsl:when test="./pfx:default"><xsl:apply-templates select="./pfx:default/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="value"><ixsl:value-of select="string($realvalue)"/></ixsl:attribute>
      <ixsl:if test="/formresult/formvalues/param[@name=string($realname)]/text()=string($realvalue) or
                     ($realdefault = 'true' and not(/formresult/formvalues/param[@name=string($realname)]))">
        <ixsl:attribute name="selected">selected</ixsl:attribute>
      </ixsl:if>
      <xsl:apply-templates select="./node()"/>
    </option>
    <cus:documentation>
      <description>Creates an "option" formelement.</description>
      <param required="0">
        <name>name</name>
        <values><string/></values>
        <description>name attribute of the option</description>
      </param>
      <param required="0">
        <name>value</name>
        <values><string/></values>
        <description>value attribute of the option tag.</description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <oneof><option>true</option><option>false</option></oneof>
        </values>
        <description>if set to true, the option is selected by default if no
        other value is given by the business logic</description>
      </param>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='radio']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <input type="radio">
      <xsl:copy-of select="@*[name()!='type' and name()!='default' and name()!='value' and name()!='name']"/>
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <ixsl:variable name="realvalue"><xsl:choose>
        <xsl:when test="@value"><xsl:value-of select="@value"/></xsl:when>
        <xsl:when test="./pfx:value"><xsl:apply-templates select="./pfx:value/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="value"><ixsl:value-of select="string($realvalue)"/></ixsl:attribute>
      <ixsl:variable name="realdefault"><xsl:choose>
        <xsl:when test="@default"><xsl:value-of select="@default"/></xsl:when>
        <xsl:when test="./pfx:default"><xsl:apply-templates select="./pfx:default/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:if test="/formresult/formvalues/param[@name=string($realname)]/text()=string($realvalue) or
                     (string(realdefault) = 'true' and not(/formresult/formvalues/param[@name=string($realname)]))">
        <ixsl:attribute name="checked">checked</ixsl:attribute>
      </ixsl:if>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>Creates a html radio button. Every radio button in a group has the same name.
        The attribute "value" should be different for each radio button.
        All attributes except "type" and "default" will be copied to the resulting html element.
      </description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the radiobutton</description>
      </param>
      <children>
        <name>pfx:value</name>
        <description>the value of the radio button (instead of using the value attribute)</description>
      </children>
      <example>
        <input>
          <xmlcode>
            <pfx:forminput>
              <pfx:xinp type="radio" name="feldname" value="wert1">My Text to 1</pfx:xinp><br/>
              <pfx:xinp type="radio" name="feldname" value="wert2">Title  2</pfx:xinp><br/>
              <pfx:xinp type="radio" name="feldname" value="wert3">Something Point 3</pfx:xinp><br/>
            </pfx:forminput>
          </xmlcode>
        </input>
        <output>
          <xmlcode>
            <form method="post" action="baz">
              <input type="radio" name="feldname" value="wert1"/>My Text to 1<br/>
              <input type="radio" name="feldname" value="wert2"/>Title  2<br/>
              <input type="radio" name="feldname" value="wert3"/>Something Point 3<br/>
            </form>
          </xmlcode>
        </output>
      </example>
    </cus:documentation>  
  </xsl:template>

  <xsl:template match="pfx:xinp[@type='check']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <input type="checkbox">
      <xsl:copy-of select="@*[name()!='type' and name()!='default' and name()!='value' and name()!='name']"/>
      <ixsl:variable name="realname">
        <xsl:choose>
          <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
          <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
        </xsl:choose>
      </ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <ixsl:variable name="realvalue"><xsl:choose>
        <xsl:when test="@value"><xsl:value-of select="@value"/></xsl:when>
        <xsl:when test="./pfx:value"><xsl:apply-templates select="./pfx:value/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="value"><ixsl:value-of select="string($realvalue)"/></ixsl:attribute>
      <ixsl:variable name="realdefault"><xsl:choose>
        <xsl:when test="@default"><xsl:value-of select="@default"/></xsl:when>
        <xsl:when test="./pfx:default"><xsl:apply-templates select="./pfx:default/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:if test="/formresult/formvalues/param[@name=string($realname)]/text()=string($realvalue) or
                     (string(realdefault) = 'true' and not(/formresult/formvalues/param[@name=string($realname)]))">
        <ixsl:attribute name="checked">checked</ixsl:attribute>
      </ixsl:if>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>
        Creates a check box form element. All attributes given except "type" and "default" will be copied to the final html tag.
      </description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>Name of the check box</description>
      </param>
      <param required="1">
        <name>type</name>
        <values>
          <oneof><option>check</option></oneof>
        </values>
        <description></description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <oneof><option>true</option><option>false</option></oneof>
        </values>
        <description>if set to true, the checkbox is checked by default if no
        other value is mandated by the business logic</description>
      </param>
    </cus:documentation>    
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='text']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <input type="text" size="40" maxlength="200">
      <xsl:copy-of select="@*[name()!='type' and name()!='default' and name()!='position' and name()!='name']"/>
      <ixsl:variable name="realname">
        <xsl:choose>
          <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
          <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
        </xsl:choose>
      </ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <ixsl:variable name="realdefault">
        <xsl:choose>
          <xsl:when test="@default"><xsl:value-of select="@default"/></xsl:when>
          <xsl:when test="./pfx:default"><xsl:apply-templates select="./pfx:default/node()"/></xsl:when>
        </xsl:choose>
      </ixsl:variable>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position">
            <xsl:value-of select="@position"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <ixsl:attribute name="value">
        <ixsl:choose>
          <ixsl:when test="not(/formresult/formvalues/param[@name=string($realname)][position() = {$pos}])"><ixsl:value-of select="$realdefault"/></ixsl:when>
          <ixsl:otherwise><ixsl:value-of select="/formresult/formvalues/param[@name=string($realname)][position() = {$pos}]"/></ixsl:otherwise>
        </ixsl:choose>
      </ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>
      Creates a text input field. All attributes given will be copied to the final html tag.</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the input-field</description>
      </param>
      <param required="0">
        <name>maxlength</name>
        <values><int default="200"/></values>
        <description>maxlength of the inputfield (chars)</description>
      </param>
      <param required="0">
        <name>size</name>
        <values><int default="40"/></values>
        <description>size of the inputfield</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>text</option></oneof></values>
        <description></description>
      </param>
      <param required="0">
        <name>default</name>
        <values>
          <string/>
        </values>
        <description>if set to any value, the text field is set this value by default if no
        other value is given by the business logic</description>
      </param>
      <param required="0">
        <name>position</name>
        <values><int default="1"/></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree.</description>
      </param>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='password']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <input type="password" size="40" maxlength="200">
      <xsl:copy-of select="@*[name()!='type' and name()!='name']"/>
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <ixsl:attribute name="value">
        <ixsl:value-of select="/formresult/formvalues/param[@name=string($realname)][position() = 1]"/>
      </ixsl:attribute>
      <xsl:apply-templates/>
    </input>
    <cus:documentation>
      <description>Creates a password input field. The text in this field will be displayed like this: ********</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>name of the password input field</description>
      </param>
      <param required="0">
        <name>maxlength</name>
        <values><int default="200"/></values>
        <description>maxlength of the inputfield (chars)</description>
      </param>
      <param required="0">
        <name>size</name>
        <values><int default="40"/></values>
        <description>size of the inputfield</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>password</option></oneof></values>
        <description></description>
      </param>
    </cus:documentation>
  </xsl:template>
  
  <xsl:template match="pfx:xinp[@type='area']">
    <xsl:call-template name="pfx:formwarn">
      <xsl:with-param name="type">unknown</xsl:with-param>
      <xsl:with-param name="data" select="current()"/>
    </xsl:call-template>
    <textarea cols="38" rows="20">
      <xsl:copy-of select="@*[name()!='type' and name()!='position' and name()!='name']"/>
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="@name"><xsl:value-of select="@name"/></xsl:when>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:attribute name="name"><ixsl:value-of select="string($realname)"/></ixsl:attribute>
      <xsl:variable name="pos">
        <xsl:choose>
          <xsl:when test="@position"><xsl:value-of select="@position"/></xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <ixsl:choose>
        <ixsl:when test="not(/formresult/formvalues/param[@name=string($realname)][position() = {$pos}])"><xsl:apply-templates/></ixsl:when>
        <ixsl:otherwise><ixsl:value-of select="/formresult/formvalues/param[@name=string($realname)][position() = {$pos}]"/></ixsl:otherwise>
      </ixsl:choose>
    </textarea>
    <cus:documentation>
      <description>Creates a html-textarea. All attributes will be copied to the resulting
      &lt;textarea&gt; html tag</description>
      <param required="1">
        <name>name</name>
        <values><string/></values>
        <description>Name of the textarea</description>
      </param>
      <param required="1">
        <name>type</name>
        <values><oneof><option>area</option></oneof></values>
        <description></description>
      </param>
      <param required="0">
        <name>cols</name>
        <values><int default="38"/></values>
        <description>number of cols</description>
      </param>
      <param required="0">
        <name>rows</name>
        <values><int default="20"/></values>
        <description>number of rows</description>
      </param>
      <param required="0">
        <name>position</name>
        <values><int default="1"/></values>
        <description>This is needed for parameters that are defined as multiple, i.e. that one named
        parameter can occur multiple times. The position attribute let's you specifiy which
        occurance of a value in the output tree should be used to prefill the input field. Default
        is to always use the first occurance, other values are integer values to specify the n-th
        ocurance in the output tree.</description>
      </param>
      <example>
        <input>
          <xmlcode><pfx:xinp type="area" name="foo"/></xmlcode>
        </input>
        <output>
          <xmlcode><textarea cols="38" rows="20" name="foo"/></xmlcode>
        </output>
      </example>
    </cus:documentation>   
  </xsl:template>


  <!-- not really deprecated, but pfx:checkerror is more fexible. On the other hand, this is shorter -->
  <!-- to write in many common cases. -->
  
  <xsl:template match="pfx:label" name="pfx:label">
    <xsl:param name="name"><xsl:value-of select="@name"/></xsl:param>
    <ixsl:if test="1 = 1"> <!-- make sure to have a local scope --> 
      <ixsl:variable name="realname"><xsl:choose>
        <xsl:when test="$name"><xsl:value-of select="$name"/></xsl:when>
        <xsl:when test="./pfx:name"><xsl:apply-templates select="./pfx:name/node()"/></xsl:when>
      </xsl:choose></ixsl:variable>
      <ixsl:choose>
        <ixsl:when test="/formresult/formerrors/error[@name=string($realname)]">
          <xsl:if test="@showimage != 'false'">
            <xsl:call-template name="pfx:include">
              <xsl:with-param name="href">common/txt/general.xml</xsl:with-param>
              <xsl:with-param name="part">error_icon</xsl:with-param>
            </xsl:call-template>
          </xsl:if>
          <xsl:if test="not(@type = 'hidden')">
            <span class="core_label_error"><xsl:apply-templates/></span>
          </xsl:if>
        </ixsl:when>
        <xsl:if test="not(@type = 'hidden')">
          <ixsl:otherwise>
            <xsl:apply-templates/>
          </ixsl:otherwise>
        </xsl:if>
      </ixsl:choose>
    </ixsl:if>
  </xsl:template>


  <!-- ****************** Helper templates ******************************* -->

  <xsl:template name="pfx:formwarn">
    <xsl:param name="type"/>
    <xsl:param name="data"/>
    <xsl:variable name="style_err">position: absolute; color: #000000; background-color: #eeaaaa; border: solid 1px #aa8888; font-family: sans-serif; font-size:9px; font-weight: normal;</xsl:variable>
    <xsl:variable name="theform" select="ancestor::pfx:forminput[position()=1]"/>
    <xsl:if test="$prohibitEdit = 'no' and not($theform/@send-to-page)">
      <xsl:choose>
        <xsl:when test="$type = 'unknown'">
          <ixsl:if test="/formresult/iwrapperinfo">
            <xsl:variable name="fullname" select="$data/@name"/>
            <xsl:if test="contains($fullname, '.')">
              <xsl:variable name="prefix" select="substring-before($fullname, '.')"/>
              <xsl:variable name="tmp" select="substring-after($fullname, '.')"/>
              <xsl:variable name="name">
                <xsl:choose>
                  <xsl:when test="contains($tmp, '.')"><xsl:value-of select="substring-before($tmp, '.')"/></xsl:when>
                  <xsl:otherwise><xsl:value-of select="$tmp"/></xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:variable name="index" select="substring-after($tmp, '.')"/>
              <ixsl:choose>
                <!-- don't check wrappers that are marked as not to check...-->
                <ixsl:when test="/formresult/iwrapperinfo/wrapper[@prefix = '{$prefix}']/@docheck = 'false'"/>
                <ixsl:when test="not(/formresult/iwrapperinfo/wrapper[@prefix = '{$prefix}'])">
                  <div style="{$style_err}" onclick="this.style.display='none'">
                    Warning: Unknown wrapper <b><xsl:value-of select="$prefix"/></b>
                  </div>
                </ixsl:when>
                <ixsl:when test="not(/formresult/iwrapperinfo/wrapper[@prefix = '{$prefix}']/param[@name = '{$name}'])">
                  <div style="{$style_err}" onclick="this.style.display='none'">
                    Warning: Unknown parameter <b><xsl:value-of select="$name"/></b> in wrapper <b><xsl:value-of select="$prefix"/></b>
                  </div>
                </ixsl:when>
                <xsl:choose>
                  <xsl:when test="$index">
                    <ixsl:when test="not(/formresult/iwrapperinfo/wrapper[@prefix = '{$prefix}']/param[@name = '{$name}' and @occurance = 'indexed'])">
                      <div style="{$style_err}" onclick="this.style.display='none'">
                        Warning: No indexed parameter <b><xsl:value-of select="$name"/></b> in wrapper <b><xsl:value-of select="$prefix"/></b>
                      </div>
                    </ixsl:when>
                  </xsl:when>
                  <xsl:otherwise>
                    <ixsl:when test="not(/formresult/iwrapperinfo/wrapper[@prefix = '{$prefix}']/param[@name = '{$name}' and @occurance != 'indexed'])">
                      <div style="{$style_err}" onclick="this.style.display='none'">
                        Warning: Parameter <b><xsl:value-of select="$name"/></b> in wrapper <b><xsl:value-of select="$prefix"/> must be indexed</b>
                      </div>
                    </ixsl:when>
                  </xsl:otherwise>
                </xsl:choose>
              </ixsl:choose>
            </xsl:if>
          </ixsl:if>
        </xsl:when>
        <xsl:otherwise>
          <div style="{$style}" onclick="this.style.display='none'">
            <xsl:apply-templates/>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>


  <!-- ************************************************************************************************************* -->
  <!-- ****************************   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE ************************************** -->
  <!-- ************************************************************************************************************* -->
  <!-- All the following templates are DEPRECATED and may be removed any time in the future without -->
  <!-- further warning. Please don't use them in new code -->


  <!-- DEPRECATED -->
  <xsl:template match="pfx:dynoptions">
    <!-- $realname will be set in the parent select -->
    <ixsl:for-each select="{@optionpath}/option">
      <ixsl:variable name="realvalue">
        <ixsl:choose>
          <ixsl:when test="@value">
            <ixsl:value-of select="@value"/>
          </ixsl:when>
          <ixsl:otherwise>
            <ixsl:apply-templates select="./node()"/>
          </ixsl:otherwise>
        </ixsl:choose>
      </ixsl:variable>
      <option>
        <ixsl:copy-of select="./@*[name()!= 'default']"/>
        <ixsl:if test="/formresult/formvalues/param[@name=string($realname)]/text() = string($realvalue) or
          (@default = 'true' and not(/formresult/formvalues/param[@name=string($realname)]))">
          <ixsl:attribute name="selected">selected</ixsl:attribute>
        </ixsl:if>
        <ixsl:apply-templates select="./node()"/>
      </option>
    </ixsl:for-each>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>

  <!-- DEPRECATED -->
  <xsl:template match="pfx:xoutp">
    <ixsl:value-of select="/formresult/formvalues/param[@name='{@name}']"/>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>  
  </xsl:template>
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:xoutperror">
    <ixsl:apply-templates select="/formresult/formerrors/error[@name='{@name}']"/>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>

  <!-- DEPRECATED -->
  <xsl:template name="renderoptions">
    <xsl:param name="options"/>
    <xsl:param name="name"/>
    <xsl:for-each select="$options">
      <xsl:variable name="value">
	<xsl:choose>
	  <xsl:when test="@value">
	    <xsl:value-of select="@value"/>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:apply-templates select="./node()"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:variable>
      <option>
	<xsl:copy-of select="@*[name()!= 'position']"/>
	<ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text()='{$value}'">
	  <ixsl:attribute name="selected">selected</ixsl:attribute>
	</ixsl:if>
	<xsl:apply-templates select="./node()"/>
      </option>
    </xsl:for-each>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:xinp[@type='dynselect']">
    <xsl:variable name="name" select="string(@name)"/>
    <select name="{$name}">
      <xsl:copy-of select="@*[name()!='type' and name()!='optionpath']"/>
      <xsl:if test="@multiple"><xsl:attribute name="multiple">multiple</xsl:attribute></xsl:if>
      <xsl:call-template name="renderoptions">
	<xsl:with-param name="options" select=".//pfx:option[not(@position = 'end')]"/>
	<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
      </xsl:call-template>
      <ixsl:for-each select="{@optionpath}/option">
        <ixsl:variable name="value">
          <ixsl:choose>
            <ixsl:when test="@value">
              <ixsl:value-of select="@value"/>
            </ixsl:when>
            <ixsl:otherwise>
              <ixsl:apply-templates select="./node()"/>
            </ixsl:otherwise>
          </ixsl:choose>
        </ixsl:variable>
        <option>
          <ixsl:copy-of select="./@*"/>
          <ixsl:if test="/formresult/formvalues/param[@name='{$name}']/text() = $value">
            <ixsl:attribute name="selected">selected</ixsl:attribute>
          </ixsl:if>
          <ixsl:apply-templates select="./node()"/></option>
      </ixsl:for-each>
      <xsl:call-template name="renderoptions">
	<xsl:with-param name="options" select=".//pfx:option[@position = 'end']"/>
	<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
      </xsl:call-template>
    </select>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation>
  </xsl:template>

  <!-- DEPRECATED -->
  <xsl:template match="pfx:paramref">
    <cus:documentation>
      <description>DEPRECATED, DON'T USE IT</description>
    </cus:documentation>
  </xsl:template>
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:errorbox">
    <xsl:param name="paramref" select="./pfx:paramref"></xsl:param>
    <ixsl:if test="/formresult/formerrors/node()">
      <table class="core_errorbox_table">
        <xsl:if test="@width"><xsl:copy-of select="@width"/></xsl:if>
	<xsl:choose>
	  <xsl:when test="not($paramref)">
	    <xsl:for-each select="//pfx:label">
	      <xsl:variable name="name"  select="./@name"/>
	      <xsl:variable name="label" select="./node()"/>
	      <ixsl:if test="/formresult/formerrors/error[@name='{$name}']">
		<tr>
		  <td nowrap="nowrap" class="core_errorlabel_td" valign="top">
		    <span class="core_errorlabel_text"><xsl:apply-templates select="$label"/></span>
		  </td>
		  <td class="core_errortext_td">
		    <span class="core_errortext">
                      <ixsl:apply-templates select="/formresult/formerrors/error[@name='{$name}']"/>
		    </span>
		  </td>
		</tr>
	      </ixsl:if>
	    </xsl:for-each>
	  </xsl:when>
	  <xsl:otherwise>
            <xsl:for-each select="$paramref">
              <xsl:variable name="labelname"><xsl:value-of select="./@name"/></xsl:variable>
              <xsl:variable name="label" select="//pfx:label[@name = $labelname]"/>
              <ixsl:if test="/formresult/formerrors/error[@name='{$labelname}']">
                <tr>
                  <td nowrap="nowrap" class="core_errorlabel_td" valign="top">
                    <span class="core_errorlabel_text"><xsl:apply-templates select="$label[position() = 1]/node()"/></span>
                  </td>
                  <td class="core_errortext_td">
                    <span class="core_errortext">
                      <ixsl:apply-templates select="/formresult/formerrors/error[@name='{$labelname}']"/>
                    </span>
                  </td>
                </tr>
              </ixsl:if>
            </xsl:for-each>
	  </xsl:otherwise>
	</xsl:choose>
      </table>
    </ixsl:if>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation> 
  </xsl:template>

  <!-- DEPRECATED -->
  <xsl:template match="pfx:groupdisplayonly">
    <xsl:variable name="group"><xsl:value-of select="@name"/></xsl:variable>
    <ixsl:if test="/formresult/iwrappergroups/group[@current = 'true' and @name = '{$group}']">
      <xsl:apply-templates/>
    </ixsl:if>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation> 
  </xsl:template> 
  
  <!-- DEPRECATED -->
  <xsl:template match="pfx:flatdisplayonly">
    <ixsl:if test="/formresult/iwrappergroups[not(@groupdisplay = 'true')]">
      <xsl:apply-templates/>
    </ixsl:if>
    <cus:documentation>
      <description>DEPRECATED. DON'T USE IT.</description>
    </cus:documentation> 
  </xsl:template> 

  
</xsl:stylesheet>

<!--
Local Variables:
mode: xsl
End:
-->
