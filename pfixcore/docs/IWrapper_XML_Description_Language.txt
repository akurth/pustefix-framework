What are IWrappers and IHandlers
================================

IWrappers are objects which aggregate part of the submitted data of a HTTP post or get 
event in a typesafe way and present getter and setter methods to manipulate that data.

IHandler are classes which represent application logic and work on
supplied wrappers to get their data or set default values which should
appear on the html form that is used to supply the data needed by the handler.

Normally, there's a 1:1 correlation between IWrappers and IHandlers,
but it is possible to make this a n:1 relation if the 1 IHandler
knows about all the assoziated n IWrappers.


How to make an xml source for autogenerating IWrappers                         
======================================================

Classes which implement the IWrapper interface are not written by
hand, but are autogenerated from a description written in a special
xml format.

Start with the introduction for a first read, or skip forward to the reference section.

INTRODUCTION
============

Before I explain every detail, let's look at a simple example:

First, here is the simple xml file de.schlund.pfixcore.example.AdultInfo.iwrp:

        <?xml version="1.0" encoding="ISO-8859-1"?>
        <interface>
          <ihandler class="de.schlund.pfixcore.example.AdultInfoHandler"/>
          
          <param name="Adult" type="java.lang.Boolean">
            <caster class="de.schlund.pfixcore.generator.casters.ToBoolean"/>
          </param>
        </interface> 


you can see that the root element is <interface>. There are only two possible child elements for 
<interface>, both of which are shown here: <ihandler> and <param>.

The generated java code looks like this:

        package de.schlund.pfixcore.example;
        import de.schlund.pfixcore.generator.*;
        /**
         * THIS CLASS IS AUTOGENERATED! DO NOT EDIT IN ANY WAY!
         */
        public class AdultInfo extends IWrapperImpl {
        
            public AdultInfo() {
                handler = IHandlerFactory.getInstance().getIHandler("de.schlund.pfixcore.example.AdultInfoHandler");
            }
            
            protected synchronized void registerParamInfos() {
                super.registerParamInfos();
                IWrapperParamInfo      pinfo;
                IWrapperIndexedParam   pindx;
                IWrapperParamCaster    caster;
                IWrapperParamPreCheck  pre;
                IWrapperParamPostCheck post;
            
                // Adult
                pinfo  = new IWrapperParamInfo("Adult", false, null);
                params.put("Adult", pinfo);
                  
                caster = new de.schlund.pfixcore.generator.casters.ToBoolean();
                pinfo.setParamCaster(caster);
            
              
            }
            
            // Adult
            public java.lang.Boolean getAdult() {
                return (java.lang.Boolean) getParamInfoForKey("Adult").getValue();
            }
            
            public void setStringValAdult(String v) {
                getParamInfoForKey("Adult").
                  setStringValue(new String[] {v});
            }
        
            public void addSCodeAdult(de.schlund.util.statuscodes.StatusCode scode) {
                getParamInfoForKey("Adult").addSCode(scode);
                synchronized (errors) {
                    errors.put(getParamInfoForKey("Adult").getName(), getParamInfoForKey("Adult"));
                }
            }
                
        }

As you can see, we only have the simple Constructor, a method called
registerParamInfos() plus some methods that work on all the  parameters 
(one in this case) which are described by this IWrapper. 

All generated IWrappers will have that very same form. As you can see,
the AdultInfo class does not directly implement the IWrapper interface
but does so by inheriting from IWrapperImpl which implements the
interface.

If you look at the interface definition

        public interface IWrapper {
            void                init(String prefix) throws Exception;
            void                load(HttpServletRequest req) throws Exception;
            String              getPrefix();
            IHandler            getIHandler();
            boolean             errorHappened();
            IWrapperParamInfo[] getAllParamInfos();
            IWrapperParamInfo[] getAllParamInfosWithErrors();
        }

you can see that every method of the interface is already implemented
completely by IWrapperImpl. The registerParamInfos() method just
supplies the distinct parameters of every new IWrapper to the
IWrapperImpl class.

The other methods get<FOO>(), setStringVal<FOO>() and addSCode<FOO>
are templates repeated for every parameter <FOO> that's part of the
IWrapper in question (that means, for every <param> tag in the xml
description). They are of course NOT part of the IWrapper interface,
as they change with every new IWRapper that's constructed.

Funny enough, you don't have to bother at all with the methods of the
IWrapper interface, it's only the template methods mentioned above
that are of interest for the application programmer and which will be
used in the application logic.

If we look at the constructor, we see how the <ihandler> tag is used:
the "class" attribute is used to get an instance of this class from
the IHandlerFactory.

That IHandler (which is a singleton!) is the code you have to write on
your own, the code that handles all the application logic. You do this
by writing a class implementing the interface
de.schlund.pfixcore.generator.IHandler.

The IHandler interface is shown here:

        public interface IHandler {
            void    handleSubmittedData(Context context, IWrapper wrapper, ResultDocument resdoc) throws Exception;
            void    insertCurrentStatus(Context context, IWrapper wrapper, ResultDocument resdoc) throws Exception;
            boolean prerequisitesMet(Context context);
            boolean isActive(Context context);
            boolean needsData(Context context);
        }

as you can see, there are two methods that get an IWrapper as a
parameter. This IWrapper is exactly the one that referenced that
ihandler in the first place. In our example you would need to write a
class de.schlund.pfixcore.example.AdultInfoHandler and this class
would be given an instance of an IWrapper of type
de.schlund.pfixcore.example.AdultInfo.

Because of this, and the fact that the relevant methods are not part
of the IWrapper interface, the first thing you do in the two methods
handleSubmittedData(...) and insertCurrentStatus(..) is to cast the
IWrapper to the correct type (AdultInfo in this case):

         AdultInfo info = (AdultInfo) wrapper;

after that, you can use the template methods to get to the data that
is stored typesafe in the IWrapper --- all of this is handled in the
background just by means of the code from IWrapperImpl.

As you can see from the sample code of our AdultInfo IWrapper, we have
a Boolean value "Adult", which can be queried (Boolean getAdult()),
whose String representation can be set (void setStringValAdult(String
v)) and who can be assoziated with an error by the means of attaching
a StatusCode to it (void addSCodeAdult(...)).

The reason that it's not possible to set the typed value, but only the
string representation is that a type may have more than one valid
string representation (e.g. a date). A web form can only show string
representations in it's fields so by means of directly setting the
String value you have complete control over what appears on the web
form.

Generally you will use the getter methods in the handleSubmittedData()
method to get the data, and the (String) setter methods in the
insertCurrentStatus() method to fill in the values to be shown on the
web page.

The exact form of the template methods is determined by the exact form
of the <param> tag. In our example it states that the type is
java.lang.Boolean, so this determines the return type of the getter method.

For every other type except String you need to write a <caster> child
tag that names the class responsible for transforming the String value
coming in from the HTTP request into the desired output type. It is not 
very surprising that we use de.schlund.pfixcore.generator.casters.ToBoolean
in our example.

With this (and all the details explained below) you can build up
complicated, typesafe interfaces between a webform and the application
logic.


REFERENCE 
=========

<interface> mandatory, root node

    Attributes:
    1) extends: optional, when given must name another IWrapper from which
                this class will inherit. By extending, you can only
                broaden an interface or redefine it (including the
                associated IHandler), but not restrict it.

<ihandler> single, mandatory when _not_ extending, optional otherwise. child of <interface>.

    Attributes:
    1) class: mandatory, classname of the IHandler.


<param> optional, multiple.

    Attributes:
    1) name: mandatory, the name of the parameter
    2) type: mandatory, the type of the parameter
    3) frequency: optional, if given and of the value "multiple" it means that 
                  the parameter can occur more than one time in the
                  request, that means it should be treated as an
                  array. Consequently the generated getter method does
                  not return the given TYPE but the TYPE[].  E.g. for
                  a parameter named FOO of type BAR you would have
                                    BAR[] getFOO()
                   The setter changes accordingly:
                              setStringValFOO(String[] val)
    3) occurance: optional, if not given defaults to "mandatory", that means the 
                  parameter must be given in the request. If it is
                  missing, a error will be generated automatically
                  (without ever hitting the IHandler class).
                  Other possible values are:
                  "optional": as the name says, the parameter can be omitted.
                  "indexed": this is a bit more complicated, an index parameter FOO
                             means that the requests transmits a variable number (0...n) of 
                             parameters named FOO.XXX where XXX are n different suffixes (the "index").
                             The generated template methods look a bit different:

                                                BAR getFOO(String index)
                                                java.util.Iterator getKeysFOO()
                                                setStringValFOO(String v, String index)
                                                void addSCodeFOO(StatusCode scode, String index)

                  You can even mix frequency="multiple" with occurance="indexed" !! 
                  (But see the section on the <default> child below!)

    4) missingscode: optional. Only applies when occurance is set to "mandatory". Value is a complete 
                     name of StatusCode which will be used instead of the default error if the (mandatory)
                     parameter is missing when submitting data.


<default> child of <param>; optional, multiple.
     Applies only when occurance is not "indexed".
     This node can be used to give one or many (for array values) default values that should be used
     in case the paramter is not supplied in the request. Using default values makes the destinction between
     occurance="mandatory" and occurance="optional" senseless, as there will always be a value to use.

     Attributes :
     1) value: the value to use as the default for this parameter. 

<caster> child of <param>; mandatory when type of param != java.lang.String; single.

     Attributes:
     1) class: the classname of the Caster instance to use. This class
               casts the HTTP parameter (a string) into the desired
               output type. See de.schlund.pfixcore.generator.IWrapperParamCaster and 
               associated and implementing classes.

<precheck> child of <param>; optional, single.

     Attributes:
     1) class: the classname of the PreChecker instance to use. This class
               is used for checks on the incoming string
               representation before the caster is applied. See
               de.schlund.pfixcore.generator.IWrapperParamPreCheck and
               associated and implementing classes.
           

<postcheck> child of <param>; optional, single. 

     Attributes:
     1) class: the classname of the PostChecker instance to use. This class
               is used for checks on the already casted data.
               (So it is used _after_ the caster is applied). See
               de.schlund.pfixcore.generator.IWrapperParamPostCheck and
               associated and implementing classes.

<cparam> child of <caster>, <precheck> and <postcheck>; optional, multiple. 
     The containing class (a caster, precheck or postcheck) is expected to 
     have a method named put_FOO if a cparam with attribute name="FOO" is given.
     The put_FOO method needs to accept a String parameter whose value will be set
     to the value attribute given in the cparam.

     Attributes:
     1) name: name of a cparam, will be use to construct the
              put_NAME(String VALUE) method that is called.
     2) value: value of a cparam, will be used as the VALUE in the
               put_NAME method that's called.

     You can use these to customize the behaviour of a certain caster,
     pre- or postchecker.
 