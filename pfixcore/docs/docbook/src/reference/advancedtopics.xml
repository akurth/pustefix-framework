<?xml version="1.0"?>
<chapter xml:id="advancedtopics" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0CR7/xsd/docbook.xsd">
  <title>Advanced topics</title>

  <section xml:id="rolebasedauth">
    <title>Role-based authorization</title>
    <para>
      Pustefix provides a role-based authorization mechanism. You can define arbitrary <literal>roles</literal>, 
      declare logical operations/combinations on this roles using <literal>authconstraints</literal>, 
      and assign these authconstraints to <literal>pagerequests</literal>.
    </para>      
    <para>
      A <literal>role</literal> is defined using an according XML element with a unique 
      <literal>name</literal> attribute value. Setting the <literal>initial</literal> 
      attribute to <literal>true</literal> the <literal>role</literal> will be automatically 
      set on context initialization.
    </para>
    <para>
<programlisting language="xml"><![CDATA[
  <role name="MYROLE" initial="true"/>
]]></programlisting>
    </para>
    <para>
      <literal>Authconstraints</literal> can combine various authorization conditions, 
      supported conditions are: <literal>hasrole</literal>, <literal>and</literal>, 
      <literal>or</literal> and <literal>not</literal>, represented by according XML elements. 
      Using the <literal>authpage</literal> attribute you can define the page, which should be 
      called on authorization failure. Using the <literal>default</literal> attribute you can 
      set one toplevel <literal>authconstraint</literal> to be the default one for 
      all <literal>pagerequests</literal> having no <literal>authconstraint</literal> asssigned.
    </para>
<programlisting language="xml"><![CDATA[
  <authconstraint id="MYCONSTRAINT" authpage="login" default="true">
    <or>
      <hasrole name="MYROLE"/>
      <hasrole name="OTHERROLE"/>
    </or>
  </authconstraint>
]]></programlisting>
    <para>
      <literal>Pagerequests</literal> can either define new <literal>authconstraints</literal> as 
      child elements or can reference existing toplevel <literal>authconstraints</literal> by 
      their <literal>id</literal>.
    </para>
    <para>
<programlisting language="xml"><![CDATA[
  <pagerequest name="mypage">
    <authconstraint ref="MYCONSTRAINT"/>
    ...
  </pagerequest>

  <pagerequest name="mypage">
    <authconstraint authpage="login">
      <hasrole name="MYROLE"/>
    </authconstraint>
    ...
  </pagerequest>
]]></programlisting>
    </para>
    <para>
      You can programmatically set/query roles using the <literal>de.schlund.pfixcore.auth.Authentication</literal>
      object, which can be retrieved from the <literal>Context</literal> calling its <literal>getAuthentication()</literal>
      method.
    </para>
    <para>
<programlisting language="java"><![CDATA[
public interface Authentication {
    
    public boolean hasRole(String roleName);
    public boolean addRole(String roleName);
    public boolean revokeRole(String roleName);
    
    public Role[] getRoles();
    
}
]]></programlisting>
    </para>
    <para>
      You can add a new role using <literal>addRole()</literal>, revoke exisiting
      roles using <literal>revokeRole()</literal> or check for a role using 
      <literal>hasRole()</literal>. Using <literal>getRoles()</literal> you get an array 
      of all currently set roles.  If a default role is defined, this role will be initially set.
    </para>
    <para>
      You can also query the current roles from within your XML/XSLT code using the
      XPath extension function <literal>pfx:hasRole(rolename)</literal>
    </para>
    <para>
    <programlisting language="xml"><![CDATA[
      <ixsl:if test="pfx:hasRole('MYROLE')">
         ...
      </ixsl:if>
    ]]></programlisting>
    </para>
    <para>
      If you try to access a page for which the authconstraint isn't fulfilled, you're forwarded
      to the according login page. The login page has to be a regular page, i.e. IWrappers on the
      page are configured the regular way (no <literal>authinterface</literal> elements). 
      Login forms require the <literal>type</literal> attribute set to <literal>roleauth</literal>
      (instead of <literal>auth</literal> in the traditional login forms).
    </para>
    <para>
    <programlisting language="xml"><![CDATA[
    <pfx:forminput type="roleauth">
      ...
    </pfx:forminput>
    ]]></programlisting>
    </para>
    <para>
      The framework automatically inserts an <literal>authentication</literal> element into
      the login page's DOM tree. This element contains the state of the <literal>authenticated</literal>
      flag, the <literal>targetpage</literal> which should be accessed, the current <literal>roles</literal>
      and the <literal>authorizationfailure</literal> containing the violated
      <literal>authconstraint</literal>.
    </para>
    <para>
    <programlisting language="xml"><![CDATA[
    <formresult>
      <authentication authenticated="true" targetpage="mypage">
        <roles>
          <role name="SOMEROLE"/>
        </roles>
        <authorizationfailure authorization="pageaccess" target="mypage">
          <authconstraint>
            <hasrole name="MYROLE"/>
          </authconstraint>
        </authorizationfailure>
      </authentication>
      ...
    </formresult>
    ]]></programlisting>
    </para>

       
    <section xml:id="rolebasedauth_example">
    <title>Example</title>
    <para>
      The following example defines three <literal>roles</literal>. The <literal>role</literal> 
      <literal>ANONYMOUS</literal> is configured as <literal>initial</literal> <literal>role</literal>,
      i.e. every session/context has this <literal>role</literal> automatically set from the beginning.
    </para>
    <para>
      There are two top-level <literal>authconstraints</literal>. The <literal>authconstraint</literal> 
      <literal>AC_DEFAULT</literal> is declared as <literal>default</literal>, i.e. pages, having no explicitly set 
      <literal>authconstraint</literal>, will get this one. The <literal>authconstraint's authpage</literal> 
      is set to <literal>login</literal> and it has a simple condition saying that it requires the <literal>role</literal> 
      <literal>ANONYMOUS</literal>.
    </para>
    <para>
      The <literal>authconstraint</literal> <literal>AC_KNOWN</literal> declares that
      it requires the <literal>USER</literal> or the <literal>ADMIN</literal> <literal>role</literal>. This
      <literal>authconstraint</literal> is referenced by the <literal>pagerequest</literal> <literal>userpage</literal>, using
      an empty <literal>authconstraint</literal> element having a <literal>ref</literal> attribute containing the
      <literal>authconstraint's</literal> id.
    </para>
    <para>
      The <literal>pagerequest</literal> <literal>adminpage</literal> contains an anonymous
      <literal>authconstraint</literal> element, which defines the <literal>role</literal> 
      <literal>ADMIN</literal> as requirement.
    </para>
<para>
<programlisting language="xml"><![CDATA[
<contextxmlserver>
  
  <role name="ANONYMOUS" initial="true"/>
  <role name="USER"/>
  <role name="ADMIN"/>
  
  <authconstraint id="AC_DEFAULT" authpage="login" default="true">
    <hasrole name="ANONYMOUS"/>
  </authconstraint>
  
  <authconstraint id="AC_KNOWN" authpage="login">
    <or>
      <hasrole name="USER"/>
      <hasrole name="ADMIN"/>
    </or>
  </authconstraint>
  
  <pagerequest name="home">
    ...
  </pagerequest>
  
  <pagerequest name="login">
    <input>
      ...
    </input>
  </pagerequest>

  <pagerequest name="adminpage">
    <authconstraint authpage="login">
      <hasrole name="ADMIN"/>
    </authconstraint>
    ...
  </pagerequest>
  
  <pagerequest name="userpage">
    <authconstraint ref="AC_KNOWN"/>
    ...
  </pagerequest>

  ...

</contextxmlserver>
]]></programlisting>
    </para>
   
  </section>

    <section xml:id="rolebasedauth_customconditions">
      <title>Custom conditions</title>
      <para>
        You can extend the authentication mechanism by providing custom conditions (additionally to the predefined conditions: <literal>hasrole</literal>, <literal>and</literal>, <literal>or</literal>, <literal>not</literal>). Therefore you just have to implement the <literal>Condition</literal> interface and register your implementation class in the context configuration file. Then your custom condition can be used within authconstraints, just as the builtin conditions and arbitrarily mixed with them.
      </para>
      <para>
<programlisting language="java"><![CDATA[
public interface Condition {

	public boolean evaluate(Context context);
	
}
]]></programlisting>
      </para>
      <para>
        You have to implement the <literal>evaluate</literal> method, which returns if the condition is fulfilled. Therefore the evaluation logic can access the Context. Implementations shouldn't change the data model, perform fast and hold only immutable state (or be stateless).
      </para>
      <para>
        The following example shows a condition which retrieves a <literal>ContextResource</literal> for a customer and checks if its debit exceeds a configured limit. The limit is automatically set to a value configured as property in the condition's configuration.
      </para>
      <para>
<programlisting language="java"><![CDATA[
package example;

import de.schlund.pfixcore.auth.Condition;
import de.schlund.pfixcore.workflow.Context;
import example.ContextCustomer;

public class PremiumCustomerCondition implements Condition {
    
    private float limit;

    public boolean evaluate(Context context) {
        ContextCustomer contextCustomer=context.getContextResourceManager().getResource(ContextCustomer.class);
        return contextCustomer.getTotalDebit() >= limit;
    }
    
    public void setLimit(float limit) {
        this.limit = limit;
    }
    
}
]]></programlisting>
      </para>
      <para>
        Let's look how this condition is registered and used in the context configuration:
      </para>
      <para>
    <programlisting language="xml"><![CDATA[
    <condition id="isPremiumCustomer" class="example.PremiumCustomerCondition">
      <property name="limit" value="100000"/>
    </condition>
  
    <authconstraint id="..." authpage="...">
      <and>
        <hasrole name="..."/>
        <condition ref="isPremiumCustomer"/>
      </and>
    </authconstraint>
    ]]></programlisting>
      </para>
      <para>
        Conditions are registered using top-level <literal>condition</literal> elements. They require an <literal>id</literal> and a <literal>class</literal> attribute. Authconstraints can reference conditions using <literal>condition</literal> elements with an according <literal>ref</literal> attribute.
      </para>
      <para>
        Conditions can be checked from within XML/XSL using the <literal>pfx:condition</literal> function, e.g.:
      </para>    
      <para>
    <programlisting language="xml"><![CDATA[
    <ixsl:if test="pfx:condition('isPremiumCustomer')">
    ...
    </ixsl:if>
    ]]></programlisting>
    </para>

    </section>

    <section xml:id="rolebasedauth_customroleprovider">
      <title>Custom RoleProvider</title>
      <para>
        Roles by default are configured within the context configuration.
        As an alternative approach you're able to plug-in your own RoleProvider
        implementation. Thus you can provide roles programmatically or from
        another source.
      </para>
      <para>
      	You just have to implement the RoleProvider interface and register the implementation
      	class in the context configuration.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
public interface RoleProvider {

	public Role getRole(String roleName) throws RoleNotFoundException;
	public List<Role> getRoles();
	
}
]]></programlisting>
      </para>
      <para>
        The <literal>getRole</literal> method returns a <literal>Role</literal> object by name. 
        The <literal>getRoles</literal> method returns a list of all available roles.
      </para>
     <para>
      <programlisting language="java"><![CDATA[
public interface Role {

    public String getName();
    public boolean isInitial();
    
}
]]></programlisting>
      </para>
      <para>
        <literal>Role</literal> objects can either be created by implementing the 
        <literal>Role</literal> interface or by using the default implementation
        <literal>de.schlund.pfixcore.auth.RoleImpl</literal>. Role implementations
        have to return a unique name and if they should be initially set.
      </para>
      <para>
        The following example shows a simple <literal>RoleProvider</literal> implementation,
        which holds the roles in a programmatically filled map.  
      </para>
     <para>
      <programlisting language="java"><![CDATA[
public class MyRoleProvider implements RoleProvider {

    private Map<String, Role> roles;

    public MyRoleProvider() {
        roles = new HashMap<String, Role>();
        Role role = new RoleImpl("ADMIN", false);
        roles.put(role.getName(), role);
    	...
    }

    public Role getRole(String roleName) throws RoleNotFoundException {
        Role role = roles.get(roleName);
        if(role == null) throw new RoleNotFoundException(roleName);
        return role;
    }

    public List<Role> getRoles() {
        return new ArrayList<Role>(roles.values());
    }

}
]]></programlisting>
      </para>      
      <para>
        The <literal>RoleProvider</literal> implementation is registered using the
       	context configuration top-level <literal>roleprovider</literal> element with
       	a <literal>class</literal> attribute, e.g.:
      </para>     
      <para>
    <programlisting language="xml"><![CDATA[
    <roleprovider class="example.MyRoleProvider"/>
    ]]></programlisting>
    </para>
    <para>
      You should be aware that the current mechanism doesn't support
      dynamic RoleProviders. The provided roles have to be constant, i.e. they're read
      at application startup time and aren't updated at a later time.
    </para>
    </section>

  </section>

  <section xml:id="object2xml">
    <title>Object-to-XML mapping</title>
	<para>
	  Pustefix provides a lightweight object serialization mechanism, which can be used to 
	  serialize arbitrary objects into the result DOM without having to do any DOM operations by 
	  yourself. The XML binding is customizable via Java annotations within the bean classes.
	</para>
	<para>
	  The framework supports arbitrary <literal>Beans</literal>, <literal>Arrays</literal>, 
	  <literal>Collections</literal>, <literal>Maps</literal>, <literal>Numbers</literal> (including
	  the primitive types and their object wrapper types), <literal>Strings</literal>, 
	  and <literal>Date/Calendar</literal>. To support other types or to serialize
	  to a custom format, it's possible to write your own serializers and annotations (to attach
	  them to the according bean properties). 
	</para>
	<para>
	  The serialization of beans can be customized using the generic Pustefix bean annotations,
	  which are known from the JSON serialization framework. You can exclude individual properties 
	  from serialization by marking the according getter with an <literal>@Exclude</literal> 
	  annotation or you can exclude all properties by marking the bean class with an 
	  <literal>@ExcludeByDefault</literal> annotation and include individual properties with
	  <literal>@Include</literal> annotations at their getters (marking public members is supported 
	  too). Using the <literal>@Alias</literal> annotation you can control 
	  the name used as the resulting attribute or element name.
	</para>
	<para>
	  The serialization to the result tree is done by calling one of the static <literal>addObject</literal>
	  methods of the <literal>ResultDocument</literal> class. The <literal>element</literal> 
	  argument is the parent DOM element at which the serialized XML will be appended, the optional <literal>name</literal>
	  argument can be used to create an additional child element for the serialized XML. The
	  <literal>object</literal> argument is the object, which should be serialized.
	</para>
	<para>
	  <programlisting language="java"><![CDATA[
	   public class ResultDocument {
	     ...
	     public static Element addObject(Element element, Object object) {...}
	     public static Element addObject(Element element, String name, Object object) {...}
	   }
	  ]]></programlisting>
	</para>
	
	<section xml:id="object2xml_serializationprocess">
    <title>Serialization process</title>
	
	<para>
	  The default serialization process tries to produce relatively compact XML. Thus it favours
	  attributes over elements and serializes so-called simple types, which can be represented
	  as strings, into attributes where it's possible and makes sense, e.g. for bean properties.
	</para>
	<para>
	  Let's look at an example, which shows the serialization of a simple bean using 
	  bean and serializer annotations to customize the serialization behaviour:
	</para>
	<para>
	  <programlisting language="java"><![CDATA[
        ...
	  
        public class Account {
  
          private long accountNo;
          private float debit;
          ...
  
          public long getAccountNo() {
            return accountNo;
          }

          public void setAccountNo(long accountNo) {
            this.accountNo = accountNo;
          }

          @Alias("balance")
          public float getDebit() {
            return debit;
          }

          public void setDebit(float debit) {
            this.debit = debit;
          }
  
          public Currency getCurrency() {
            return currency;
          }
  
          public void setCurrency(Currency currency) {
            this.currency = currency;
          }
  
          @DateSerializer("yyyy-MM-dd HH:mm:ss")
          public Calendar getOpeningDate() {
            return openingDate;
          }

          public void setOpeningDate(Calendar openingDate) {
            this.openingDate = openingDate;
          }
  
          @Exclude
          public String getComment() {
            return comment;
          }

          public void setComment(String comment) {
            this.comment = comment;
          }

        }
	  ]]></programlisting>
	</para>
	<para>
	  Here you see how the bean's serialized to the <literal>ResultDocument</literal> within 
	  a <literal>ContextResource</literal>:
	</para>
	<para>
	  <programlisting language="java"><![CDATA[
        ...
        
        public class ContextAccountImpl implements ContextAccount {

          private Account account;
	      ...
	
          public void insertStatus(ResultDocument resdoc, Element elem) throws Exception {
            ResultDocument.addObject(elem,"account",account);
          }
          
        }
      ]]></programlisting>
	</para>
	<para>
	  The resulting DOM fragment looks like this:
	</para>
	<para>
      <programlisting language="xml"><![CDATA[
        <formresult serial="1199439160721">
          ...
          <data>
            <account accountNo="2000123" currency="EUR" balance="332.54" openingDate="2003-11-04 09:15:38"/>
          </data>
          ...
        </formresult>
      ]]></programlisting>
    </para>
    <para>
      The <literal>data</literal> element is the ContextResource's root node as configured
      in the configuration file. Calling <literal>addObject</literal> with the additional
      <literal>account</literal> argument, the serialized bean isn't added directly to the
      data element, but an additional element is used. The bean's properties are serialized
      as attributes of this element.
    </para>
    <para>
      The <literal>debit</literal> property is renamed to <literal>balance</literal> using
      the <literal>@Alias</literal> annotation. The <literal>comment</literal> property is
      excluded using the <literal>@Exclude</literal> annotation. The <literal>openingDate</literal>
      property is serialized using the built-in <literal>DateSerializer</literal>, which can
      be customized using the <literal>@DateSerializer</literal> annotation. Thus you can
      provide your own date format pattern (must be a pattern supported by
      <literal>java.text.SimpleDateFormat</literal>).
    </para>
    <para>
      Only simple type properties, i.e. properties which can be serialized to string values, can
      be represented as attributes. If the <literal>Account</literal> bean would have an additional
      property <literal>customer</literal> of a bean type, e.g. a <literal>Customer</literal> class, 
      this property would be serialized as a child element:  
    </para>
    <para>
      <programlisting language="xml"><![CDATA[
        <formresult serial="1199439160721">
          ...
          <data>
            <account accountNo="2000123" balance="EUR" debit="332.54" openingDate="2003-11-04 09:15:38">
              <customer customerId="100000" firstName="Mike" lastName="Foo"/>
            </account>
          </data>
          ...
        </formresult>
      ]]></programlisting>
    </para>
    <para>
      <literal>Collections</literal> and <literal>Arrays</literal> are represented using
      an element for each entry. The element name is derived from the the simple name
      of the entry's class (without package name and starting lowercase):
    </para>
    <para>
      <programlisting language="xml"><![CDATA[
        <formresult serial="1199439160721">
          ...
          <data>
            <account accountNo="2000000" currency="EUR" balance="3124.49" openingDate="2003-10-23 08:05:10"/>
            <account accountNo="2000123" currency="EUR" balance="332.54" openingDate="2003-11-04 09:15:38"/>
            <account accountNo="2001405" currency="EUR" balance="25123.11" openingDate="2005-01-13 10:10:10"/>
          </data>
          ...
        </formresult>
      ]]></programlisting>
    </para>
    <para>
      The element name can be changed using the <literal>@ClassNameAlias</literal> annotation, e.g.
      to rename the <literal>account</literal> element to <literal>bankaccount</literal>:
    </para>
    <para>
	  <programlisting language="java"><![CDATA[
      @ClassNameAlias("bankaccount")
      public class Account {
        ...
      }
      ]]></programlisting>
	</para>
    <para>
      <literal>Maps</literal> are represented using an <literal>entry</literal> element for each
      map entry. Key and value are represented by child elements (whereas the element names are
      derived from the class names):
    </para>
    <para>
      <programlisting language="xml"><![CDATA[
        <formresult serial="1199439160721">
          ...
          <data>
            <entry>
              <long>2000000</long>
              <account accountNo="2000000" currency="EUR" debit="3124.49" openingDate="2003-10-23 08:05:34"/>
            </entry>
            <entry>
              <key>2001405</key>
              <account accountNo="2001405" currency="EUR" debit="25123.11" openingDate="2005-01-13 10:10:34"/>
            </entry>
            <entry>
              <key>2000123</key>
              <account accountNo="2000123" currency="EUR" debit="332.54" openingDate="2003-11-04 09:15:34"/>
            </entry>
          </data>
          ...
        </formresult>
      ]]></programlisting>
    </para>
    <para>
      Circular object references are handled by adding a <literal>xpathref</literal> attribute to
      the according element. Its value is an absolute XPath expression referencing the according
      object's element:
    </para>
    <para>
      <programlisting language="xml"><![CDATA[
      <formresult serial="1199702214819">
        ...
        <data>
          <account accountNo="2000123">
            <customer customerId="100000">
              <accounts>
                <account accountNo="2000000">
                  <customer xpathref="/formresult/data[1]/account[1]/customer[1]"/>
                </account>
                <account xpathref="/formresult/data[1]/account[1]"/>
                <account accountNo="2001405">
                  <customer xpathref="/formresult/data[1]/account[1]/customer[1]"/>
                </account>
              </accounts>
            </customer>
          </account>
        </data>
        ...
      </formresult>
      ]]></programlisting>
    </para>
    <para>
      In this example the <literal>Account</literal> bean has a reference to a <literal>Customer</literal>
      bean, which itself has a reference to all of its <literal>Accounts</literal>. You can see that all
      beans, which were already serialized (as ancestors in the tree) contain an according back-reference.
    </para>
    <para>
      Strings that contain XML code can be inserted as XML fragment the the resulting document by using
      the <literal>@XMLFragmentSerializer</literal>:
    </para>
    <para>
      <programlisting language="java"><![CDATA[
        public class FragmentBean {

            private String myFragment = "<foo><bar baz=\"true\"/>character data</foo>";

            @XMLFragmentSerializer
            public String getMyFragment() {
                return myFragment;
            }
        }
      ]]></programlisting>
    </para>
    <para>
      The XML, that is returned by the <literal>getMyFragment</literal> method is not treated
      as a simple string, but as an XML fragment and thus, the content is not escaped, when
      inserted in the document:
    </para>
    <para>
      <programlisting language="java"><![CDATA[
        <?xml version="1.0" encoding="utf-8"?>
        <result>
           <myFragment>
              <foo>
                 <bar baz="true"/>character data</foo>
           </myFragment>
        </result>
      ]]></programlisting>
    </para>
    </section>
    
    <section xml:id="object2xml_customserializers">
    <title>Custom serializers</title>
    
    <para>
      If you don't like the default serialization mechanism or you use unsupported types, you can
      write your own serializers. There are two types of serializers: <literal>SimpleTypeSerializers</literal>, 
      which can produce <literal>String</literal> values (e.g. for primitive types), 
      and <literal>ComplexTypeSerializers</literal>, which can produce structured XML data
      (e.g. for bean types). 
    </para>
    <para>
      Implementing your own serializer just requires to implement the <literal>SimpleTypeSerializer</literal>
      or <literal>ComplexTypeSerializer</literal> interface and create a custom annotation to be able
      to attach your serializer to a bean property.
    </para>
    <para>
      Let's look at an example of a <literal>SimpleTypeSerializer</literal>: 
      a custom <literal>String</literal> serializer, which allows to configure if 
      <literal>Strings</literal> should be ouput lower- or uppercase. Here's the implementation:
    </para>
    <para>
	  <programlisting language="java"><![CDATA[
        ...
        import de.schlund.pfixcore.oxm.impl.AnnotationAware;
        import de.schlund.pfixcore.oxm.impl.SimpleTypeSerializer;
        import de.schlund.pfixcore.oxm.impl.annotation.StringSerializer;
        ...

        public class StringTypeSerializer implements SimpleTypeSerializer, AnnotationAware {

          private boolean doLowerCase;
	
          public void setAnnotation(Annotation annotation) {
            StringSerializer s=(StringSerializer)annotation;
            doLowerCase=s.value();
          }
		
          public String serialize(Object obj, SerializationContext context) throws SerializationException {
            if(obj instanceof String) {
              String str=(String)obj;
              if(doLowerCase) str=str.toLowerCase();
              else str=str.toUpperCase();
              return str;
            } 
            throw new SerializationException("Illegal type: "+obj.getClass().getName());
          }
        }
      ]]></programlisting>
    </para>
    <para>
      The serializer implements the <literal>SimpleTypeSerializer</literal> interface.
      Its <literal>serialize</literal> method checks if the passed object is of type <literal>String</literal>
      and calls <literal>toLowerCase</literal> or <literal>toUpperCase</literal> before returning
      the new <literal>String</literal>. The <literal>doLowerCase</literal> property controls which method is used.
      This property is set within the <literal>setAnnotation</literal> method. The method is defined
      in the <literal>AnnotationAware</literal> interface. This method is called by the framework
      after the serializer is instantiated and passes the annotation set at the according bean
      property. So you can access the configured values and configure your serializer.
      Let's look at the according annotation definition:
    </para>
    <para>
	  <programlisting language="java"><![CDATA[
        ...
        
        @SimpleTypeSerializerClass(StringTypeSerializer.class)
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface StringSerializer {
          boolean value();
        }
      ]]></programlisting>
    </para>
    <para>
      You have to annotate the custom annotation with a <literal>SimpleTypeSerializerClass</literal>
      annotation with the serializer class as value, make the annotation available to
      methods and fields using the <literal>@Target</literal> annotation and make it visible
      at runtime using the <literal>@Retention</literal> annotation. The rest of the annotation
      definition can be done according to your needs. In the example we just define a boolean
      property indicating if the <literal>String</literal> should be converted to lower- or uppercase. Here you
      see how the annotation is applied to serialize a customer's lastname as uppercase:
    </para>
    <para>
	  <programlisting language="java"><![CDATA[
      public class Customer {
        ...
        @StringSerializer(false)
        public String getLastName() {...}
      }
      ]]></programlisting>
	</para>
	<para>
	  Let's look at an example of a <literal>ComplexTypeSerializer</literal>. We want to customize
	  the serialization of a <literal>Customer</literal> bean: the <literal>firstName</literal> and
	  <literal>lastName</literal> properties should be output together within a <literal>name</literal>
	  element:
	</para>
	<para>
      <programlisting language="java"><![CDATA[
      public class Customer {
        ...
        public long getCustomerId() {...}
        public String getFirsstName() {...}
        public String getLastName() {...}
        public List<Account> getAccounts() {...}
        ...
      }
      ]]></programlisting>
    </para>
    <para>
      The serializer just implements <literal>ComplexTypeSerializer</literal>. We don't need to
      implement <literal>AnnotationAware</literal> because our annotation will have no parameter
      we may want to read:
    </para>
    <para>
      <programlisting language="java"><![CDATA[
      public class CustomerTypeSerializer implements ComplexTypeSerializer {

        public void serialize(Object obj, SerializationContext context, XMLWriter writer) throws SerializationException {
          if(obj instanceof Customer) {
            Customer customer=(Customer)obj;
            writer.writeStartElement("name");
            writer.writeCharacters(customer.getFirstName()+" "+customer.getLastName());
            writer.writeEndElement("name");
            context.serialize(customer.getAccounts(),writer);
          } else throw new SerializationException("Illegal type: "+obj.getClass().getName());
        }
       
      }
      ]]></programlisting>
    </para>
    <para>
      The <literal>serialize</literal> method gets a <literal>XMLWriter</literal> object, which
      is used to write the <literal>name</literal> element. Then the passed <literal>SerializationContext</literal>
      is used to serialize the customer's accounts using the default serialization mechanism.
    </para>
    <para>Finally we implement a custom annotation:</para>
    <para>
	  <programlisting language="java"><![CDATA[
      @ComplexTypeSerializerClass(de.schlund.pfixcore.example.bank.oxm.CustomerTypeSerializer.class)
      @Target({ElementType.METHOD,ElementType.FIELD})
      @Retention(RetentionPolicy.RUNTIME)
      public @interface CustomerSerializer {}
	  ]]></programlisting>
    </para>
    <para>Here we apply the annotation to the <literal>Account</literal> bean's 
      <literal>customer</literal> property:</para>
    	<para>
      <programlisting language="java"><![CDATA[
      public class Account {
        ...
        @CustomerSerializer
        public Customer getCustomer() {...}
        ...
      }
      ]]></programlisting>
    </para>
    <para>
      Here's an excerpt of the resulting XML:
    </para>
    <para>
      <programlisting language="xml"><![CDATA[
      <formresult serial="1199705488403">
        ...
        <data>
          <account accountNo="2000000" balance="3124.49" currency="EUR" openingDate="2003-10-23 08:05:22">
            <customer>
              <name>Mike Foo</name>
              <account accountNo="..."/>
              <account accountNo="..."/>
              ...
            </customer>
          </account>
        </data>
        ...
      </formresult>
      ]]></programlisting>
    </para>
    
    </section>

  </section>
  
  <section xml:id="iwrapperannotations">
    <title>Annotation-based IWrapper creation</title>
    <para>
      The annotation-based IWrapper creation provides an alternative to the usual,
      XML configuration based, IWrapper creation. Using this approach you create IWrappers
      from standard Java Beans by adding the necessary configuration data in the form
      of annotations.
    </para>
    <para>
      The IWrappers are automatically created during the build process using the Sun JVM's <literal>apt</literal>
      tool and a custom <literal>AnnotationProcessor</literal> which analyzes the Java bean's
      source code and generates the according IWrapper sources.
    </para>
    <para>
      You're making a bean to a template for an <literal>IWrapper</literal> by adding an 
      <literal>@IWrapper</literal> annotation to its class declaration. By default every 
      bean property that is of a so-called builtin type, i.e. has a pre-defined 
      <literal>IWrapperParamCaster</literal> implementation, will be automatically added
      as an IWrapper parameter.
    </para>
    <para>
      Builtin types are <literal>boolean, byte, double, float, int, long,
      java.lang.Boolean, java.lang.Byte, java.lang.Double, java.lang.Float, java.lang.Integer, 
      java.lang.Long, java.lang.String, java.util.Date</literal> and <literal>Arrays</literal>
      with components of these types.
    </para>
    <para>
      Bean properties of an unknown type are either ignored or require a <literal>@Caster</literal>
      annotation specifying an appropriate caster. Bean properties can be annotated at their
      getter methods or at the field itself, if it's public. If a property of a builtin type should
      be skipped you can mark the according property with a <literal>@Transient</literal> annotation.
    </para>
    <para>
      Bean based IWrappers can be used to create new beans or fill existing beans with
      the IWrapper's state. Therefore the <literal>IWrapperToBean</literal> class provides
      the two static methods <literal>&lt;T&gt; T createBean(IWrapper wrapper, Class&lt;T&gt; beanClass)</literal>
      and <literal>populateBean(IWrapper wrapper, Object obj)</literal>.
    </para>
    <section xml:id="iwrapperannotations_reference">
      <title>IWrapper annotations</title>
      <para>
        Every IWrapper configuration element known from the XML configuration has an annotation
        counterpart. Besides there are some special annotations like <literal>@IWrapper</literal>
        and <literal>@Transient</literal>. In the following we'll give a short overview of
        all avaible annotations:
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target(ElementType.TYPE)
        @Retention(RetentionPolicy.RUNTIME)
        public @interface IWrapper {
          String name() default "";
          Class<? extends IHandler> ihandler() default IHandler.class;
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@IWrapper</literal> annotation is used to mark a class as template for
        an IWrapper. The <literal>name</literal> attribute denotes the class name of the
        generated IWrapper class (without package). By default the bean name with the
        suffix <literal>Wrapper</literal> is used (and the same package). The <literal>ihandler</literal>
        attribute denotes the <literal>IHandler</literal> implementation class.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Param {
          String name() default "";
          boolean mandatory() default true;
          boolean trim() default true;
          String missingscode() default "";
          String[] defaults() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Param(name="MyValue",mandatory=false)
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Param</literal> annotation is used to mark a bean property as parameter
        and configure its <literal>name</literal> and all the other options known from the
        IWrapper XML configuration. This annotation is optional, leaving it out, the property name
        is used as name and the other attributes are set to their default values.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Caster {
          Class<? extends IWrapperParamCaster> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Caster(type=SomeClassCaster.class)
          public SomeClass getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Caster</literal> annotation denotes the caster implementation class.
        The nested <literal>properties</literal> attribute can be used to set properties via
        <literal>@Property</literal> annotations. That's the same as the <literal>cparam</literal>
        elements in the XML configuration (the params/properties are set using according methods
        prefixed with <literal>put_</literal>).
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Property {
          String name();
          String value();
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Property</literal> annotation is used as nested annotation within
        the <literal>properties</literal> array attribute of various annotations. It consists
        of simple <literal>name/value</literal> pairs. 
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface PreCheck {
          Class<? extends IWrapperParamPreCheck> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @PreCheck(
            type=de.schlund.pfixcore.generator.prechecks.RegexpCheck.class,
            properties={
              @Property(name="regexp",value="/^(M|L|XL)$/")
            }
          )
          public String getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@PreCheck</literal> annotation denotes the precheck implementation class
        with optional properties/parameters.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface PostCheck {
          Class<? extends IWrapperParamPostCheck> type();
          Property[] properties() default {};
        }
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @PostCheck(
            type=de.schlund.pfixcore.generator.postchecks.IntegerRange.class,
            properties={
              @Property(name="range",value="0:2")
            }
          )
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@PostCheck</literal> annotation denotes the postcheck implementation class
        with optional properties/parameters.
      </para>
      <para>
      <programlisting language="java"><![CDATA[
        @Target({ElementType.METHOD,ElementType.FIELD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface Transient {}
        
        @IWrapper(name="MyBeanWrapper",ihandler=MyBeanHandler.class)
        public class MyBean {
          ...
          @Transient
          public int getValue() {...}
        }
      ]]></programlisting>
      </para>
      <para>
        The <literal>@Transient</literal> annotation can be used to avoid that a bean property
        of a builtin type is made to an IWrapper parameter.
      </para>
    
    </section>
    
  </section>

</chapter>
