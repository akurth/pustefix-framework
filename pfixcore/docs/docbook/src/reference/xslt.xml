<?xml version="1.0"?>
<chapter xml:id="xslt" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0CR7/xsd/docbook.xsd"
>
  <title>Core Pustefix tag library</title>
  <para>
    Pustefix includes a small library of tags defined as XSLT templates which implement low level functionality common to all
    Pustefix application. These templates are mostly concerned with creating links to Pustefix pages or external URLs, sending
    data via HTML forms (including the necessary error handling) and including XML ressources (<emphasis>Include Parts</emphasis>).
  </para>
  <para>
    All core tags reside in their own namespace. The prefix usually used is
    <code>pfx</code>, and the namespace is
    <code>http://www.schlund.de/pustefix/core</code>. You are not supposed to enter your own private project 
    specific tags into this namespace.
  </para>

  <para>
    The following table lists these tags together with a very short explanation what they do. Refer to the relevant subsections
    below to find a detailed explanation on their relevant attributes, subnodes and how to use them.
  </para>

<para>
  <table rules="all" frame="box">
    <caption>The Core Pustefix XSLT Tags</caption>
    <thead>
      <tr>
        <th>Tag name</th>
        <th>Short information</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>pfx:document</td>
        <td>The top-most container for all Pustefix pages, see <xref linkend="xslt.structure"/></td>
      </tr>
      <tr>
        <td>pfx:frameset, pfx:frame</td>
        <td>Used to define pages with framesets and frames, see <xref linkend="xslt.structure"/></td>
      </tr>
      <tr>
        <td>pfx:button</td>
        <td>This tag creates simple links to internal Pustefix pages (possibly submitting parameters for requests)</td>
      </tr>
      <tr>
        <td>pfx:url</td>
        <td>Used to create only the content of the href attribute of a link to an internal page.</td>
      </tr>
      <tr>
        <td>pfx:elink</td>
        <td>
          This tag creates links to external URLs where care must be taken to strip the session ID from the referer header to not leak
          sensitive information to the outside world
        </td>
      </tr>
      <tr>
        <td>pfx:include</td>
        <td>
          This tag references a file via its href attribute, and includes a named snippet of xml content contained in this file
          via the part attribute.
        </td>
      </tr>
      <tr>
        <td>pfx:maincontent</td>
        <td>This tag is used to include "computed" include parts.</td>
      </tr>
      <tr>
        <td>pfx:image</td>
        <td>
          This tag references images to be included in the final page (via
          img-tags).
        </td>
      </tr>
      <tr>
        <td>pfx:forminput</td>
        <td>This tag creates a HTML form.</td>
      </tr>
      <tr>
        <td>pfx:xinp</td>
        <td>Used to create HTML form elements.</td>
      </tr>
      <tr>
        <td>pfx:checkfield</td>
        <td>This tag supplies content depending on the error state of a special form field.</td>
      </tr>
      <tr>
        <td>pfx:checkerror</td>
        <td>Used to check for the presence of any error condition.</td>
      </tr>
      <tr>
        <td>pfx:checkmessage</td>
        <td>Used to check for the presence of any page message.</td>
      </tr>
      <tr>
        <td>pfx:checkactive, pfx:checknotactive</td>
        <td>These tags check for visibility (or not) of pages or for the activity (or not) of handlers.</td>
      </tr>
      <tr>
        <td>pfx:themeselect, pfx:langselect</td>
        <td>Used to select content depending on a matching theme or currently selected language.</td>
      </tr>
      <tr>
        <td>pfx:editconsole, pfx:webserviceconsole</td>
        <td>create panels of shortcut links useful during development.</td>
      </tr>
    </tbody>
  </table>
</para>

  <section xml:id="xslt.structure">
    <title>Defining the structure of a document</title>
    <para>
      This section describes the format for those documents serving as the structure defining
      xml source of the finally transformed documents. These can be found in the xml
      subdirectory of your project.
    </para>
    <para>
      The explanation keeps an eye on the expected usage patterns of these documents.
    </para>
    <para>
      There are basically two kind of "pages" you deliver with Pustefix.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Pages that have no frames and may deliver html or any other text based format.
        </para>
      </listitem>
      <listitem>
        <para>
          Pages that contain an arbitrary amount of frames and framesets. Those usually deliver html.
        </para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Structure of a Type 1 document</title>
      <para>
        For a html delivering page without frames:
      </para>
      <programlisting language="xml"><![CDATA[
<pfx:document xmlns:pfx="http://www.schlund.de/pustefix/core">
  <html>
    <!--
      Any content valid for an html document
    -->
  </html>
</pfx:document>]]></programlisting>
      <para>
        If you don't want to deliver html, just ommit the &lt;html&gt; tag. The following
        could be used to implement a CSS stylesheet.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:document>.foo { color: #ffff00; font-family: Helvetica; }</pfx:document>]]></programlisting>
      <para>
        The rule of thumb is: Whatever you put between &lt;pfx:document&gt; is up to you and
        will be delivered just as you write it there. Just remember that the &lt;html&gt; is
        not automatically inserted for you, you have to write it yourself.
      </para>
    </section>
    <section>
      <title>Structure of a Type 2 document</title>
      <para>
        There are only subtle differences. A document is a Type 2 doc by definition
        whenever there is a &lt;pfx:frameset&gt; and possibly a &lt;head&gt; node as the
        only direct children of &lt;pfx:document&gt;.
      </para>
      <programlisting language="xml"><![CDATA[
<pfx:document xmlns:pfx="http://www.schlund.de/pustefix/core">
  <head>
    <!--
      Again, put anything you want to appear in the head of the _top frame! This means
      page title, script stuff or stylesheets.
    -->
  </head>
  <pfx:frameset rows="20,*">
    <pfx:frame name="navi">
      <html>
        <head>...</head>
        <body>
          <!-- Any HTML content -->
        </body>
      </html>
    </pfx:frame>
    <pfx:frame name="main">
      <html>
        <body>
          <!-- Any HTML content -->
        </body>
      </html>
    </pfx:frame>
  </pfx:frameset>
</pfx:document>]]></programlisting>
      <para>
        As you can see there is NO &lt;html&gt; tag just below &lt;pfx:document&gt;.
        This is the one important difference between Type 1) and Type 2). As a rule you
        could say that you only have to insert the &lt;html&gt; yourself wherever the
        "real" content is. In a Type 1) doc this is the whole content of the
        &lt;pfx:document&gt; tag, so we need to set it there. But for a Type 2) doc,
        the "real" content is the content of the &lt;pfx:frame&gt; tags, so you need to
        set it there.
      </para>
    </section>
  </section>

  <section xml:id="xslt.links">
    <title>Creating links to internal and external pages</title>
    <para>Pustefix provides tags that allow you create links to internal and external pages.</para>
	<section xml:id="xslt.pfx.button">
	  <title>pfx:button</title>
	  <para>
        The <literal>&lt;pfx:button&gt;</literal> tag is responsible for generating links to other
        pages inside the pustefix environment. In fact, it not always creates a link, but depending on
        the fact if the target page is accessible ("invisible") or not, or if the target page is the
        same as the current page ("active", aka "the target page is already active") it can display
        completely different content, and only when the target page is accessible and is different
        from the current page, a <literal>&lt;a href="..."&gt;...&lt;/a&gt;</literal> is put around it.
      </para>
      <para>
        The template takes care of constructing the correct url with session information embedded
        and builds up valid, url encoded query strings.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:button page="APage" pageflow="AFlow" jumptopage="APage" jumptopageflow="AFlow" forcestop="true|false|step" startwithflow="true|false">
  <!--
    Control the submit commands
  -->
  <pfx:command page="APage" name="SELWRP">prefix</pfx:command>
  <pfx:argument name="AName">AValue</pfx:argument>
  <pfx:anchor frame="AFrame">AnAnchor</pfx:anchor>

  <!--
    These three optional child nodes can be used to display different
    content depending on the situation:
  -->
  <pfx:invisible>
    <!-- Displayed when link is not accessible -->
  </pfx:invisible>
  <pfx:normal>
    <!-- Displayed when link is accessible -->
  </pfx:normal>
  <pfx:active>
    <!-- Displayed when current page == link target -->
  </pfx:active>
  <!--
    Displayed link content
  -->
</pfx:button>]]></programlisting>
      <para>
        The <literal>&lt;pfx:button&gt;</literal> tag supports the following attributes:
      </para>
      <table rules="all" frame="box">
        <caption>Attributes of the pfx:button tag</caption>
        <thead>
          <tr>
            <th>Attribute name</th>
            <th>Mandatory?</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>page</td>
            <td>optional</td>
            <td>defaults to the current page. Used to give the target page where the link points to. Note: leaving this empty also implies mode="force".</td>
          </tr>
          <tr>
            <td>pageflow / jumptopage / jumptopageflow / forcestop</td>
            <td>optional</td>
            <td>These attributes work the same as for form submit controls</td>
          </tr>
          <tr>
            <td>startwithflow</td>
            <td>optional</td>
            <td>
              <para>Defaults to false. When set to true, the request will not go to a page directly, but start with the a processing of the chosen pageflow to determine the page to use.</para>
              <para>The meaning of the page attribute also changes: If the submitted page is part of the chosen pageflow, the flow will be queried for the page to use up to the point in the flow where the given page is, which is then used in any case. In other words, this constitutes an end point for the search of a matching page in the flow.</para>
            </td>
          </tr>
          <tr>
            <td>mode</td>
            <td>optional</td>
            <td>
              <para>Default is empty. When set to force, a link is created and the matching CSS is used even in the active button state, i.e. whenever the target page is the current page.</para>
              <para>When set to desc, the button state is not only active when the current page == target page, but also when the current page is a descendent page of the target page.</para>
            </td>
          </tr>
          <tr>
            <td>nodata</td>
            <td>optional</td>
            <td>Default to false. Normally, whenever you use a pfx:argument tag to attach parameters to the query string, the system automatically also adds the parmeter __sendingdata=1 to the query string, thereby signalling to the backend system, that it should process incoming data. Set this attribute to true to prohibit this behaviour.</td>
          </tr>
          <tr>
            <td>frame / target</td>
            <td>optional</td>
            <td>Works the same as for submit controls</td>
          </tr>
          <tr>
            <td>normalclass / activeclass / invisibleclass</td>
            <td>optional</td>
            <td>defaults are: core_button_normal, core_button_active and core_button_invisible. These three attributes define the CSS classes to be used for the three different states of a pfx:button</td>
          </tr>
        </tbody>
      </table>
      <section>
        <title>Commands and arguments</title>
        <para>
		  It is possible to use the same children to control the submit behaviour as it is done
		  with form controls.
        </para>
      </section>
      <section>
        <title>Link contents</title>
        <para>
          The <literal>pfx:button</literal> template allows you to change the link content depending
          on the status of the target page.
        </para>
        <itemizedlist>
          <listitem>
            <para>Content of pfx:invisible will be only displayed when the target page is not accessible.</para>
          </listitem>
          <listitem>
            <para>Content of pfx:active will be only displayed when the target page is the current page.</para>
          </listitem>
          <listitem>
            <para>Content of pfx:normal will be only displayed when the target page is different from the current page and when it's accessible.</para>
          </listitem>
        </itemizedlist>
        <para>
          Content outside of these tags will be used in any case. If you only want to have different content for
          the invisible case, just put the content for the active and normal case inside pfx:normal, and add a
          pfx:invisible child with the differing content. The content of a pfx:normal node serves as the fallback
          for the other two cases.
        </para>
        <note>
          <para>
            Note that only in the normal (regardless if the content comes from a dedicated pfx:normal child node or not)
            a link is put around the generated content.
          </para>
        </note>
        <para>
          Note also, that for differences between the three cases that can be expressed with CSS, you don't need to
          use these special child nodes. The system makes sure to use the three associated classes explained above to
          allow styling.
        </para>
        <para>
          It is also possible to change to content, depending on whether a page has already been visited or
          not.
        </para>
        <itemizedlist>
          <listitem>
            <para>Content of pfx:visited will be only displayed when the link has been already visited at least once in this session.</para>
          </listitem>
          <listitem>
            <para>Content of pfx:visited will be only displayed when the link has not been visited in this session.</para>
          </listitem>
        </itemizedlist>
        <para>
          The two tags above may also be put inside pfx:normal and pfx:invisible tags to express different content for accessible
          (or inaccessible) pages depending on the fact if they have been visited at least once already.
        </para>
        <para>
          This makes of course not much sense with pfx:active, because a page where this applies is always the current page
          and by that is always visited.
        </para>
      </section>
    </section>
    <section xml:id="xslt.pfx.url"> 
      <title>pfx:url</title>
      <para>
        This tag takes mostly the same attributes as <literal>&lt;pfx:button&gt;</literal>, but it only creates the URL and does not build up
        any content or generate a whole link. You can use this template if you just need the pure URL string.	  
	  </para>
	</section>
    <section xml:id="xslt.pfx.elink"> 
      <title>pfx:elink</title>
      <para>
        When creating links to external URLs care must be taken to ensure that no sensitive data (especially the session ID)
        leaks into log files of remote servers via the referer header. To make sure that this can't happen, all links to
        external sites must be propagated via a special servlet, the <literal>de.schlund.pfixxml.DerefServer</literal>.
      </para>
      <para>
        Every Pustefix project has this servlet configured to be accessible under the path <filename>/xml/deref</filename>.
        To make the handling of external URLs easier, there also exists a special tag <literal>&lt;pfx:elink&gt;</literal>
        that automates the creation of the correct link.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:elink href="http://some.host/location" target="_popup|SomeName">
  <!--
    Optional, use the <pfx:host> child instead of the href attribute whenever you
    need to construct the URL with additional code (e.g. from data only available
    at runtime)
  -->
  <pfx:host>...</pfx:host>

  <!--
    Optional, use as many of <pfx:argument> tags as you need to supply the
    parameters for the query string.
  -->
  <pfx:argument name="SomeName">...</pfx:argument>

  <!--
    Place content of the link here
  -->
</pfx:elink>]]></programlisting>
	</section>
  </section>

  <section>
    <title>Including text and images</title>
    <para>
      There are two types of ressources that need to be included into a Pustefix page. Textual content ("Include Parts") is
      included with the help of the <literal>&lt;pfx:include&gt;</literal> tag while images are included via the
      <literal>&lt;pfx:image&gt;</literal> tag. Both tags make sure to register the ressources in the runtime system, so at all
      times the system knows which ressources a certain page uses. This information is used to check if the page is still
      up-to-date or needs rebuilding (by comparing file modification times of the ressources with the creation time of the page itself).
    </para>
    <para>
      Of course this check can be disabled for a "live" system, as there is typically no need to check for changed ressources.
    </para>
    <section xml:id="xslt.pfx.include">
      <title>Include parts (&lt;pfx:include&gt;)</title>
      <para>
        Include parts contain the content that is displayed on your pages.
        The parts are organized into include files. Every part has the same structure:
      </para>
      <para>
        The children of the part tag are theme tags (at least one). The name attribute
        of the theme tag is the name of a theme as it is defined in the projects
        depend.xml.in file. Often these themes are just the project name or "default",
        which is used as the fallback when no more specific theme name matches
        (see here on how to define themes in the depend.xml.in file).
      </para>
      <note>
        <para>
          Earlier versions of Pustefix had no special themeing, the only thing that
          was used was the project name itself and "default" as the fallback. Still today,
          the default value for the "themes" attribute in the root node of the depend.xml.in
          file (when not given explicitely) is just "&lt;ProjectName&gt; default", which
          makes the new system behave exactly as the old one did.
        </para>
      </note>
      <para>
        The resolution of the matching theme is done at the time the part is included
        (see below). Every page "knows" which themes are defined for it, and therefore it
        is possible to decide which product branch to use on generation time. The language
        on the other hand can be changed dynamically while the user clicks through the
        application, so the selection of the right language subtree (if more than one is
        present) is done at runtime.
      </para>
      <programlisting language="xml"><![CDATA[<include_parts>
  <part name="Foo">
    <theme name="default">
      <pfx:langselect>
        <pfx:lang name="default">
          <!--
            The default content of part Foo goes here...
          -->
        </pfx:lang>
        <pfx:lang name="en_GB">
          <!--
            Default content in british english goes here...
          -->
        </pfx:lang>
        <pfx:lang name="en_*">
          <!--
            Default content in any other english language goes here...
          -->
        </pfx:lang>
      </pfx:langselect>
    </theme>
    <theme name="Theme_A">
      <!--
        The default content for theme Theme_A goes here...
      -->
    </theme>
  </part>

  <part name="Baz">
    <!-- Other parts -->
  </part>
</include_parts>]]></programlisting>
      <para>
        A part is referenced with two attributes: The filename of the include file that
        contains it, and the name of the part.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:include href="MyProject/txt/MyIncludefile" part="Foo" noerror="true|false" noedit="true|false"/>]]></programlisting>
      <para>
        <table rules="all" frame="box">
          <caption>Attributes of the pfx:include tag</caption>
          <thead>
            <tr>
              <th>Attribute name</th>
              <th>Mandatory?</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>href</td>
              <td>optional</td>
              <td>If not given, it defaults to the current include part file</td>
            </tr>
            <tr>
              <td>part</td>
              <td>mandatory</td>
              <td>The name of the part to include</td>
            </tr>
            <tr>
              <td>noerror</td>
              <td>optional</td>
              <td>Defaults to false. Set this to true to imply that no warning sign should be generated when the include is not found. Only set this when you know what you do.</td>
            </tr>
            <tr>
              <td>noedit</td>
              <td>optional</td>
              <td>Defaults to false. Set this to true to imply that this include part should not be editable via the pustefix editor. Only set this when you know what you do.</td>
            </tr>
          </tbody>
        </table>
      </para>
      <para>
        Using this tag results in the matching product branch of the include part to be
        inserted in place of the tag.
      </para>
    </section>
    <section>
      <title>Generated include requests (&lt;pfx:maincontent&gt;)</title>
      <para>
        Looking at the example naturally leads to the question how it is possible to
        generate different pages with only a small number of structural xml files and
        always the same XSLT stylesheets. The answer is that at least one of the include
        parts isn't included via the pfx:include tag (which only handles static attribute values)
        but instead the filename of the include part is auto generated from the name of the
        page that is to be produced.
      </para>
      <para>
        Looking at this page, one can see that the two transformations which produce BazPage.xml resp. BazPage.xsl have the page name supplied through the use of an XSLT transformation parameter. Using this parameter, the tag pfx:maincontent constructs an include request depending on the page name.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:maincontent part="content" path="MyProject/txt/pages" prefix="main_"/>]]></programlisting>
      <para>
        <table rules="all" frame="box">
          <caption>Attributes of the pfx:maincontent tag</caption>
          <thead>
            <tr>
              <th>Attribute name</th>
              <th>Mandatory?</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>path</td>
              <td>optional</td>
              <td>If not given, but a XSLT parameter $maincontentpath has been defined in the depend.xml.in file, the value of the parameter is used. If there's even no $maincontentpath parameter, it defaults to PROJECTNAME/txt/pages</td>
            </tr>
            <tr>
              <td>prefix</td>
              <td>optional</td>
              <td>defaults to main_</td>
            </tr>
            <tr>
              <td>postfix</td>
              <td>optional</td>
              <td>defaults to .xml</td>
            </tr>
            <tr>
              <td>part</td>
              <td>optional</td>
              <td>defaults to content</td>
            </tr>
          </tbody>
        </table>
      </para>
      <para>
        For the page "home" this is equivalent to <![CDATA[<pfx:include href="MyProject/txt/pages/main_home.xml" part="content"/>]]> and of course similar for every other page.
      </para>
      <para>
        Starting with this page specific include, the content of the page can be included from many different include parts.
      </para>
    </section>
    <section id="xslt.pfx.image">
      <title>Displaying images (&lt;pfx:image&gt;)</title>
      <para>
        HTML <literal>&lt;img&gt;</literal> tags are usually not written directly, instead they are generated by using
        the <literal>&lt;pfx:image&gt;</literal> tag. Using this tag makes sure that the used image is registered in the
        runtime system as a dependency of the current target that's being generated.
      </para>
      <para>
        One important feature of the <literal>&lt;pfx:image&gt;</literal> tag is that it inserts the natural height and
        width of the requested image unless they are explicitely given (as attributes width and height of course).
      </para>
      <programlisting language="xml"><![CDATA[<pfx:image src="some/path/to/img.gif" themed-path="some/path" themed-img="img.gif"/>]]></programlisting>
      <para>
        <table rules="all" frame="box">
          <caption>Attributes of the pfx:image tag</caption>
          <thead>
            <tr>
              <th>Attribute name</th>
              <th>Mandatory?</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>src</td>
              <td>optional</td>
              <td>
                <para>
                  The src path references an image in the file system. It must be given as a path relative to the
                  docroot (typically this means something like <filename>MyProject/img/foo.gif</filename>.
                  Note that you need to define an alias for the image directories in your project.xml config file
                  for Apache to be able to find the image.
                </para>
                <para>
                  Note that you can either specify the src attribute OR both of themed-path and themed-img
                </para>
              </td>
            </tr>
            <tr>
              <td>themed-path &amp; themed-img</td>
              <td>optional</td>
              <td>
                <para>
                  These two attributes allow for themed images. The mechanism uses the same theme fallback queue
                  as it is used for include parts. The algorithm to find the image to use is quite easy:
                </para>
                <para>
                  Build an image path by concatenating themed-path, a <literal>/</literal> sign, the most specific theme, a <literal>/</literal> sign,
                  and themed-img. Check if this image exists. If yes, use it as the <literal>src</literal> attribute for the resulting
                  <literal>img</literal> tag. If not, take the next specific theme from the fallback queue (if it exists) and try again,
                  until the image is found.
                </para>
                <para>
                  Example: The themes fallback list is "foo bar default", themed-path is "MyProject/img" and themed-img is "test.gif".
                  The image file names that are tried one after the other are
                </para>
                <itemizedlist>
                  <listitem>MyProject/img/foo/test.gif</listitem>
                  <listitem>MyProject/img/bar/test.gif</listitem>
                  <listitem>MyProject/img/default/test.gif</listitem>
                </itemizedlist>
              </td>
            </tr>
            <tr>
              <td>other attributes</td>
              <td>optional</td>
              <td>
                <para>
                  All other attributes given (e.g. <literal>alt</literal>, <literal>width</literal>,
                  <literal>height</literal>, <literal>title</literal>, etc. are copied unchanged into the resulting img tag      
                </para>
              </td>
            </tr>
          </tbody>
        </table>
      </para>
    </section>
  </section>

  <section>
    <title>Handling HTML forms</title>
    <para></para>
  </section>

  <section>
    <title>Miscellaneous utility tags</title>
    <para>Pustefix also provides several utility tags, that might be helpful in your application.</para>
    <section xml:id="xslt.utility.active">
      <title>Checking page status</title>
      <para>
        The <literal>&lt;pfx:checkactive&gt;</literal> and <literal>&lt;pfx:checknotactive&gt;</literal> allow you
        to check from the XSL-stylesheet, whether a specific IHandler currently is active or not.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:checkactive page="APageName" prefix="AHandlerName">
  <!--
    Content to be displayed, if the handler is active
  -->
</pfx:checkactive>]]></programlisting>
      <para>
        <table rules="all" frame="box">
          <caption>Attributes of the pfx:checkactive and pfx:checknotactive tags</caption>
          <thead>
            <tr>
              <th>Attribute name</th>
              <th>Mandatory?</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>page</td>
              <td>optional</td>
              <td>
                <para>
                  When using the page attribute, the content of the tag is only displayed if the referenced page is accessible.
                  This is an easy way to display complete subparts of a page depending on the accessibility of another page.
                </para>
              </td>
            </tr>
            <tr>
              <td>prefix</td>
              <td>optional</td>
              <td>
                <para>
                  When using the prefix, the content of the tag is only displayed if a referenced handler on the current
                  page is active. The prefix is the same name as used in the servlet property file for the handler.
                </para>
                <para>
                  You can only use one of the attributes page and prefix.
                </para>
              </td>
            </tr>
          </tbody>
        </table>
      </para>
    </section>
    <section xml:id="xslt.pfx:langselect">
      <title>Displaying content based on the language</title>
      <para>
        The selection mechanism of <literal>&lt;pfx:langselect&gt;</literal> allows to select matching content anywhere
        inside a include part depending on the current language that is set in the running session.
        The <literal>&lt;pfx:lang name="default"&gt;</literal> tag is acting as the fallback for all languages that don't
        have a better, more specific named <literal>&lt;pfx:lang&gt;</literal> node.
      </para>
      <programlisting language="xml"><![CDATA[<pfx:langselect>
  <pfx:lang name="en_*">...</pfx:lang>
  <pfx:lang name="en_GB">...</pfx:lang>
  <pfx:lang name="default">...</pfx:lang>
</pfx:langselect>]]></programlisting>
      <para>
        The system doesn't enforce but expects languages to be of the standard form of ISO language codes. In this case,
        a <literal>&lt;pfx:lang&gt;</literal> node with a name attribute ending in an asterisk (<literal>*</literal>) can be used to
        create a fallback for a whole "family" of languages. In the example above, the <literal>en_*</literal> node will serve as a fallback
        for all language codes starting with en_ except <literal>en_GB</literal> (which has a more specific node below).
      </para>
    </section>
    <section xml:id="xslt.pfx:themeselect">
      <title>Displaying content based on the theme</title>
      <para>
        The selection mechanism of <literal>&lt;pfx:themeselect&gt;</literal> allows to select matching content anywhere inside a
        include part depending on the same selection mechanism that is used to select the include part the first hand as described
        in <xref linkend="xslt.pfx.include"/>
      </para>
      <programlisting language="xml"><![CDATA[<pfx:themeselect>
  <pfx:theme name="ATheme">...</pfx:theme>
  <pfx:theme name="default">...</pfx:theme>
</pfx:themeselect>]]></programlisting>
      <para>
        Of course this makes most sense, when the containing include part uses a general theme, so there are
        specialized themes in the theme fallback queues to select from.
      </para>
      <note>
        <para>
          This tag is only to be used in very special situations. Normally you would like to use different themes
          for the include part to register itself correctly with the runtime system.
        </para>
      </note>
    </section>
    <section xml:id="xslt.consoles">
      <title>Using the Pustefix console</title>
      <para>
        Pustefix provides an edit-console and webservice-console that are helpful during debugging.
      </para>
      <para>
        Those consoles can be included in your pages using the <literal>&lt;pfx:editconsole&gt;</literal> and
        <literal>&lt;pfx:webserviceconsole&gt;</literal> tags.
      </para>
    </section>
  </section>

</chapter>