<?xml version="1.0" encoding="utf-8"?>
<document xmlns:pfx="http://www.schlund.de/pustefix/core">

  <properties>
    <title>Recursive Transformations</title>
  </properties>

  <body>

  <section name="Recursive Transformations">

  <p>
    The XML/XSLT System of Pustefix is responsible for generating the
    final stylesheet that represents the static content of a page.  This
    stylesheet is then used together with the DOM tree that holds the
    result of the request (as given by the business logic) to produce the
    final HTML output.
  </p>

  <p>The figure below shows the typical transformations and files that
    are involved in producing the final stylesheet
    <code>BazPage.xsl</code>.</p>
  <p>
    Note that we only discuss the common case here, arbitrary complex
    and deep transformation trees are in fact possible.
  </p>
    
  <subsection name="Typical transformation steps used to generate a single page">

  <img src="images/targets.png"/>

  <p>
    <span style="background-color: #eb613d; border: black solid 1px;">red boxes</span> are supplied
    by the framework, you don't need to create them yourself and as an application programmer, you
    can't change them. Currently this is only the case for
    <code>core/xsl/master.xsl</code>, <code>core/xsl/metatags.xsl</code>, <code>core/xsl/customizemaster.xsl</code>
    and other stylesheets that make up the core environment (these are not shown as they are
    included into master.xsl and metatags.xsl via <code>xsl:include</code> transparently for the
    user).
  </p>

  <p>
    <span style="background-color: #94bd5e; border: black solid 1px;">green boxes</span> are the result of
    XSL transformations.
  </p>

  <p>
    All the <span style="background-color: #99ccff; border: black solid 1px;">blue boxes</span>
    represent files that you need to create yourself. The <code>&lt;prj&gt;/xsl/skin.xsl</code> and
    <code>&lt;prj&gt;/xsl/metatags.xsl</code> files are special, as they are not a target (see below) but just another
    XSLT stylesheet that can be included via <code>xsl:include</code> into 
    <code>master.xsl</code> and <code>metatags.xsl</code> resp. <code>&lt;prj&gt;/xsl/skin.xsl</code>
    contains the project specific templates that should apply on the last transformation stage,
    while <code>&lt;prj&gt;/xsl/metatags.xsl</code> contains the project specific templates that apply only
    on the first stage.</p>
  <p>
    There are projects that don't use a <code>&lt;prj&gt;/xsl/skin.xsl</code>
    stylesheet at all or include even more stylesheets.
    Making master.xsl aware of the presence of the
    <code>&lt;prj&gt;/xsl/skin.xsl</code> stylesheet is
    part of the transformation from
    <code>core/xsl/master.xsl</code> +
    <code>core/xsl/customizemaster.xsl</code> =&gt;
    <code>master.xsl</code>
  </p>
  <p>
    It'a also posible that a project doesn't use a <code>&lt;prj&gt;/xsl/metatags.xsl</code> stylesheet or
    includes more stylesheets: Similar to <code>master.xsl</code> it's the responsibility of the transformation from
    <code>core/xsl/metatags.xsl</code> +
    <code>core/xsl/customizemaster.xsl</code> =&gt;
    <code>metatags.xsl</code> to customize the resulting <code>metatags.xsl</code> to include the stylesheets.
  </p>
  <p>
    The <code>&lt;prj&gt;/xml/FooBase.xml</code> file defines the <i>structure</i> of
    the "BazPage" page (e.g. frames, the outer table structure if you do the
    layout with tables or divs and the like). You define one of these
    <b>structural xml</b> files for every layout you want to use in your project (the number of
    structural xml files is typically quite small, as many pages share the same layout).
  </p>
  
  <p><span style="-moz-border-radius: 2em; background-color: #99ccff; padding-right:2px; padding-left:2px; border: black solid 1px;">blue discs</span> represent <b>include parts</b>.
    These are little snippets of XML code that make up the actual
    content of the page. As can be seen from the diagram, they can
    include themselves recursively. Include parts have a <i>name</i>
    and are organized into so called <b>include documents</b>. These
    can hold an arbitrary number of parts. Learn more about include parts and the way they are used below.
  </p>

  <div style="border: 1px red solid; background: #eeaaaa;"> There is one important restriction:
    Stylesheets that are used via &lt;xsl:include&gt; (pictured above by
    the blue dotted lines) <b>must be real files</b> on the
    filesystem. There is no possibility to include "virtual" stylesheets
    (that means stylesheets that are the result of a recursive
    transformation themself) currently!
  </div>
  
  </subsection>
  </section>
  <section name="Targets">
  <p>
    A <b>target</b> is everything that is the result of a XSLT
    transformation as seen in the figure above. It is also obvious
    that a target can be used to create new targets. For the sake of
    completeness, the initial XML or XSL files that are used in
    transformations are called targets, too.
  </p>
  <p>
    The Pustefix system knows four different types of targets:
  </p>

  <table>
    <tr>
      <th nowrap="nowrap">Main Category</th>
      <th>Type</th>
      <th>Example</th>
      <th>Notes</th>
    </tr>
    <tr>
      <td rowspan="2" nowrap="nowrap">Leaf targets</td>
      <td>XML</td>
      <td>
        <code>FooBase.xml</code>
      </td>
      <td rowspan="2">
        Leaf targets are targets that are not the result of a XSL
        transformation, but are read directly from files.  You only
        edit leaf targets, never virtual targets. The distinction
        between XML/XSL is made depending on the purpose the target
        serves. A XML target is read into the system without doing any
        special processing, while a XSL target is compiled into a
        <code>templates</code> object that is able to transform XML
        input.
      </td>
    </tr>
    <tr>
      <td>XSL</td>
      <td>
        <code>core/xsl/metatags.xsl</code>, <code>core/xsl/master.xsl</code>
      </td>
    </tr>
    <tr>
      <td rowspan="2" nowrap="nowrap">Virtual targets</td>
      <td>XML</td>
      <td>
        <code>BazPage.xml</code>
      </td>
      <td rowspan="2">
        Virtual targets are the result of a XSL transformation. They
        don't exist as files (in fact they do, but only to cache the
        result on the harddisk. These cache files must never be edited
        by hand). The difference between the XML/XSL type is analog
        to the leaf targets</td>
    </tr>
    <tr>
      <td>XSL</td>
      <td><code>BazPage.xsl</code>
      </td>
    </tr>
  </table>

  <a name="include_parts"/>
  </section>
  <section name="Include parts">
  <p>Include parts contain the content that is displayed on your pages.
    The parts are organized into include files. Every part has the
    same structure:</p>

  <p>The children of the <code>part</code> tag are
    <code>product</code> tags (at least one). The <code>name</code>
    attribute of the <code>product</code> tag is the name of a project
    defined in the Pustefix environment or "default". The latter
    matches when a part is referenced out of a project that
    has no exact match on a <code>product</code> tag's <code>name</code> attribute ("product branch").</p>

  <p>The children of the <code>product</code> tag are <code>lang</code> tags (at least one). 
    The <code>name</code> attribute of the <code>lang</code> tag is
    the name of a language or "default". The latter matches when a part is
    referenced with a language that has no exact match on a <code>lang</code> 
    tags's <code>name</code> attribute.</p>

  <p>Note that the resolution of the matching <code>product</code> is done at the time the part is included (see below).
    Every page "knows" to which project it belongs, and therefore it
    is possible to decide which product branch to use on generation
    time. The language on the other hand can be changed dynamically
    while the user clicks through the application, so the selection
    of the right <code>lang</code> subtree to use is done at runtime.</p>
  
  
  <xmlcode>
    <include_parts xmlns:ixsl="http://www.w3.org/1999/XSL/Transform"
                   xmlns:pfx="http://www.schlund.de/pustefix/core">
      <part name="Foo">
        <product name="default">
          <lang  name="default">
            <xmlnote>
              The <b>default</b> content of part <b>Foo</b> goes here...
            </xmlnote>
          </lang>
          <lang name="fr">
            <xmlnote>
              Default content in <b>french</b> goes here...
            </xmlnote>
          </lang>
        </product>
        <product name="MyProject">
          <lang name="default">
            <xmlnote>
              The default content for product <b>MyProject</b> goes here...
            </xmlnote>
          </lang>
          <lang name="fr">
            <xmlnote>
              Content for <b>MyProject</b> in <b>french</b> goes here...
            </xmlnote>
          </lang>
        </product>
      </part>
      <xmlnote/>
      <part name="Baz">
        <xmlnote>Other parts...</xmlnote>
      </part>
    </include_parts>
  </xmlcode>

  <p>A part is referenced with two attributes: The filename of the include file that contains it, and the name of the part.</p>

  <xmlcode>
    <include href="MyProject/txt/MyIncludefile" part="Foo"/>
  </xmlcode>

  <p>Using this tag results in the matching product branch of the include part to be inserted in place of the tag.</p>
  
  <subsection name="Generated include requests">

  <p>Looking at the example naturally leads to the question how it is
    possible to generate different pages with only a small number of
    structural xml files and always the same XSLT stylesheets.  The
    answer is that at least one of the include parts isn't included
    via the <code>pfx:include</code> tag (which only handles static
    attribute values) but instead the filename of the include part is auto generated from the
    name of the page that is to be produced.</p>

  <p>Looking at <a href="depend.html#stdpage">this page</a>, one can see that the two
    transformations which produce <code>BazPage.xml</code> resp. <code>BazPage.xsl</code> have the
    page name supplied through the use of an XSLT transformation parameter.  Using this parameter,
    the tag <code>pfx:maincontent</code> constructs an include request depending on the page
    name.</p>

  <xmlcode>
    <pfx:maincontent part="content" path="MyProject/txt/pages" prefix="main_"/>
    <xmlnote>
      <table>
        <tr>
          <th>Attribute</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>path</td>
          <td>Optional, defaults to <code>PRODUCTNAME/txt/pages</code></td>
        </tr>
        <tr>
          <td>prefix</td>
          <td>Optional, defaults to <code>main_</code>.</td>
        </tr>
        <tr>
          <td>postfix</td>
          <td>Optional, defaults to <code>.xml</code></td>
        </tr>
        <tr>
          <td>part</td>
          <td>Optional, defaults to <code>content</code></td>
        </tr>
      </table>
      <br/>
    </xmlnote>
  </xmlcode>

  <p>For the page "home" this is equivalent to</p>

  <xmlcode>
    <pfx:include href="MyProject/txt/pages/main_home.xml" part="content"/>
  </xmlcode>

  <p>and of course similar for every other page.</p>
  
  <p>Starting with this page specific include, the content of the page can be included from many different include parts.</p>
  </subsection>
  </section>
</body>
</document>
